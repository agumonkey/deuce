<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="DEUCE - Deuce is (not yet) Emacs under Clojure" name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{font-size:34px;display:inline;}h2.project-version{font-size:18px;margin-top:0;display:inline;margin-left:10px;}.toc-link{font-size:12px;margin-left:10px;color:#252519;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{font-size:34px;margin:0;}.docs-header{border-bottom:dotted #aaa 1px;padding-bottom:10px;margin-bottom:25px;}.toc h1{font-size:24px;}.toc{border-bottom:solid #bbb 1px;margin-bottom:40px;}.toc ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.toc li{list-style-type:none;padding-left:0;}.dependencies{}.dependencies table{font-size:16px;width:99.99%;border:none;margin-left:20px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{border-right:none;color:transparent;background-color:transparent;noshade:noshade;border-left:none;border-top:none;margin-bottom:-6px;height:0;border-bottom:dotted #bbb 1px;}.dependencies .dep-version{text-align:right;}.plugins ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.plugins li{list-style-type:none;padding-left:0;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;top:10px;right:20px;height:20px;overflow:hidden;text-align:right;}#floating-toc li{list-style-type:none;margin:0;padding:0;}</style><style type="text/css">body{margin:0;padding:0;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;font-size:16px;color:#252519;background-color:#F5F5FF;}h1{font-size:20px;margin-top:0;}h2{font-size:18px;}h3{font-size:16px;}a.anchor{text-decoration:none;color:#252519;}a.anchor:hover{color:#5050A6;}table{border-spacing:0;border-bottom:solid #ddd 1px;;margin-bottom:10px;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{width:410px;max-width:410px;vertical-align:top;margin:0px;padding-left:55px;padding-right:20px;border:none;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{vertical-align:top;font-size:10pt;overflow:hidden;background-color:#F5F5FF;width:55%;border-left:solid #E5E5EE 1px;padding-left:20px;border:none;margin:0px;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{background-color:ghostWhite;border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*! jQuery v1.7.1 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){cl||(cl=c.createElement("iframe"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode==="CSS1Compat"?"<!doctype html>":"")+"<html><body>"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,"display"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function cb(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function ca(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bE.test(a)?d(a,e):ca(a+"["+(typeof e=="object"||f.isArray(e)?b:"")+"]",e,c,d)});else if(!c&&b!=null&&typeof b=="object")for(var e in b)ca(a+"["+e+"]",b[e],c,d);else d(a,b)}function b_(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function b$(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bT,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=b$(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=b$(a,c,d,e,"*",g));return l}function bZ(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bP),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bC(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?bx:by,g=0,h=e.length;if(d>0){if(c!=="border")for(;g<h;g++)c||(d-=parseFloat(f.css(a,"padding"+e[g]))||0),c==="margin"?d+=parseFloat(f.css(a,c+e[g]))||0:d-=parseFloat(f.css(a,"border"+e[g]+"Width"))||0;return d+"px"}d=bz(a,b,b);if(d<0||d==null)d=a.style[b]||0;d=parseFloat(d)||0;if(c)for(;g<h;g++)d+=parseFloat(f.css(a,"padding"+e[g]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+e[g]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+e[g]))||0);return d+"px"}function bp(a,b){b.src?f.ajax({url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;if(b.nodeType===1){b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase();if(c==="object")b.outerHTML=a.outerHTML;else if(c!=="input"||a.type!=="checkbox"&&a.type!=="radio"){if(c==="option")b.selected=a.defaultSelected;else if(c==="input"||c==="textarea")b.defaultValue=a.defaultValue}else a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value);b.removeAttribute(f.expando)}}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c+(i[c][d].namespace?".":"")+i[c][d].namespace,i[c][d],i[c][d].data)}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?parseFloat(d):j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.1",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a&&typeof a=="object"&&"setInterval"in a},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h){var i=a.length;if(typeof c=="object"){for(var j in c)e.access(a,j,c[j],f,g,d);return a}if(d!==b){f=!h&&f&&e.isFunction(d);for(var k=0;k<i;k++)g(a[k],c,f?d.call(a[k],k,g(a[k],c)):d,h);return a}return i?g(a[0],c):b},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?m(g):h==="function"&&(!a.unique||!o.has(g))&&c.push(g)},n=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,l=j||0,j=0,k=c.length;for(;c&&l<k;l++)if(c[l].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}i=!1,c&&(a.once?e===!0?o.disable():c=[]:d&&d.length&&(e=d.shift(),o.fireWith(e[0],e[1])))},o={add:function(){if(c){var a=c.length;m(arguments),i?k=c.length:e&&e!==!0&&(j=a,n(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){i&&f<=k&&(k--,f<=l&&l--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&o.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(i?a.once||d.push([b,c]):(!a.once||!e)&&n(b,c));return this},fire:function(){o.fireWith(this,arguments);return this},fired:function(){return!!e}};return o};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p,q=c.createElement("div"),r=c.documentElement;q.setAttribute("className","t"),q.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=q.getElementsByTagName("*"),e=q.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=q.getElementsByTagName("input")[0],b={leadingWhitespace:q.firstChild.nodeType===3,tbody:!q.getElementsByTagName("tbody").length,htmlSerialize:!!q.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:q.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0},i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete q.test}catch(s){b.deleteExpando=!1}!q.addEventListener&&q.attachEvent&&q.fireEvent&&(q.attachEvent("onclick",function(){b.noCloneEvent=!1}),q.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),q.appendChild(i),k=c.createDocumentFragment(),k.appendChild(q.lastChild),b.checkClone=k.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,k.removeChild(i),k.appendChild(q),q.innerHTML="",a.getComputedStyle&&(j=c.createElement("div"),j.style.width="0",j.style.marginRight="0",q.style.width="2px",q.appendChild(j),b.reliableMarginRight=(parseInt((a.getComputedStyle(j,null)||{marginRight:0}).marginRight,10)||0)===0);if(q.attachEvent)for(o in{submit:1,change:1,focusin:1})n="on"+o,p=n in q,p||(q.setAttribute(n,"return;"),p=typeof q[n]=="function"),b[o+"Bubbles"]=p;k.removeChild(q),k=g=h=j=q=i=null,f(function(){var a,d,e,g,h,i,j,k,m,n,o,r=c.getElementsByTagName("body")[0];!r||(j=1,k="position:absolute;top:0;left:0;width:1px;height:1px;margin:0;",m="visibility:hidden;border:0;",n="style='"+k+"border:5px solid #000;padding:0;'",o="<div "+n+"><div></div></div>"+"<table "+n+" cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",a=c.createElement("div"),a.style.cssText=m+"width:0;height:0;position:static;top:0;margin-top:"+j+"px",r.insertBefore(a,r.firstChild),q=c.createElement("div"),a.appendChild(q),q.innerHTML="<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>",l=q.getElementsByTagName("td"),p=l[0].offsetHeight===0,l[0].style.display="",l[1].style.display="none",b.reliableHiddenOffsets=p&&l[0].offsetHeight===0,q.innerHTML="",q.style.width=q.style.paddingLeft="1px",f.boxModel=b.boxModel=q.offsetWidth===2,typeof q.style.zoom!="undefined"&&(q.style.display="inline",q.style.zoom=1,b.inlineBlockNeedsLayout=q.offsetWidth===2,q.style.display="",q.innerHTML="<div style='width:4px;'></div>",b.shrinkWrapBlocks=q.offsetWidth!==2),q.style.cssText=k+m,q.innerHTML=o,d=q.firstChild,e=d.firstChild,h=d.nextSibling.firstChild.firstChild,i={doesNotAddBorder:e.offsetTop!==5,doesAddBorderForTableAndCells:h.offsetTop===5},e.style.position="fixed",e.style.top="20px",i.fixedPosition=e.offsetTop===20||e.offsetTop===15,e.style.position=e.style.top="",d.style.overflow="hidden",d.style.position="relative",i.subtractsBorderForOverflowNotVisible=e.offsetTop===-5,i.doesNotIncludeMarginInBodyOffset=r.offsetTop!==j,r.removeChild(a),q=a=null,f.extend(b,i))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h=null;if(typeof a=="undefined"){if(this.length){h=f.data(this[0]);if(this[0].nodeType===1&&!f._data(this[0],"parsedAttrs")){e=this[0].attributes;for(var i=0,j=e.length;i<j;i++)g=e[i].name,g.indexOf("data-")===0&&(g=f.camelCase(g.substring(5)),l(this[0],g,h[g]));f._data(this[0],"parsedAttrs",!0)}}return h}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split("."),d[1]=d[1]?"."+d[1]:"";if(c===b){h=this.triggerHandler("getData"+d[1]+"!",[d[0]]),h===b&&this.length&&(h=f.data(this[0],a),h=l(this[0],a,h));return h===b&&d[1]?this.data(d[0]):h}return this.each(function(){var b=f(this),e=[d[0],c];b.triggerHandler("setData"+d[1]+"!",e),f.data(this,a,c),b.triggerHandler("changeData"+d[1]+"!",e)})},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){typeof a!="string"&&(c=a,a="fx");if(c===b)return f.queue(this[0],a);return this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise()}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,a,b,!0,f.attr)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,a,b,!0,f.prop)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.nodeName.toLowerCase()]||f.valHooks[this.type];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.nodeName.toLowerCase()]||f.valHooks[g.type];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;h<g;h++)e=d[h],e&&(c=f.propFix[e]||e,f.attr(a,e,""),a.removeAttribute(v?e:c),u.test(e)&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/\bhover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};
f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=[],j,k,l,m,n,o,p,q,r,s,t;g[0]=c,c.delegateTarget=this;if(e&&!c.target.disabled&&(!c.button||c.type!=="click")){m=f(this),m.context=this.ownerDocument||this;for(l=c.target;l!=this;l=l.parentNode||this){o={},q=[],m[0]=l;for(j=0;j<e;j++)r=d[j],s=r.selector,o[s]===b&&(o[s]=r.quick?H(l,r.quick):m.is(s)),o[s]&&q.push(r);q.length&&i.push({elem:l,matches:q})}}d.length>e&&i.push({elem:this,matches:d.slice(e)});for(j=0;j<i.length&&!c.isPropagationStopped();j++){p=i[j],c.currentTarget=p.elem;for(k=0;k<p.matches.length&&!c.isImmediatePropagationStopped();k++){r=p.matches[k];if(h||!c.namespace&&!r.namespace||c.namespace_re&&c.namespace_re.test(r.namespace))c.data=r.data,c.handleObj=r,n=((f.event.special[r.origType]||{}).handle||r.handler).apply(p.elem,g),n!==b&&(c.result=n,n===!1&&(c.preventDefault(),c.stopPropagation()))}}return c.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0)}),d._submit_attached=!0)})},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on.call(this,a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.type+"."+e.namespace:e.type,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.POS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling(a.parentNode.firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){if(f.isFunction(a))return this.each(function(b){var c=f(this);c.text(a.call(this,b,c.text()))});if(typeof a!="object"&&a!==b)return this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a));return f.text(this)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function()
{for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){if(a===b)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(var c=0,d=this.length;c<d;c++)this[c].nodeType===1&&(f.cleanData(this[c].getElementsByTagName("*")),this[c].innerHTML=a)}catch(e){this.empty().append(a)}}else f.isFunction(a)?this.each(function(b){var c=f(this);c.html(a.call(this,b,c.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,bp)}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||!bc.test("<"+a.nodeName)?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g;b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);var h=[],i;for(var j=0,k;(k=a[j])!=null;j++){typeof k=="number"&&(k+="");if(!k)continue;if(typeof k=="string")if(!_.test(k))k=b.createTextNode(k);else{k=k.replace(Y,"<$1></$2>");var l=(Z.exec(k)||["",""])[1].toLowerCase(),m=bg[l]||bg._default,n=m[0],o=b.createElement("div");b===c?bh.appendChild(o):U(b).appendChild(o),o.innerHTML=m[1]+k+m[2];while(n--)o=o.lastChild;if(!f.support.tbody){var p=$.test(k),q=l==="table"&&!p?o.firstChild&&o.firstChild.childNodes:m[1]==="<table>"&&!p?o.childNodes:[];for(i=q.length-1;i>=0;--i)f.nodeName(q[i],"tbody")&&!q[i].childNodes.length&&q[i].parentNode.removeChild(q[i])}!f.support.leadingWhitespace&&X.test(k)&&o.insertBefore(b.createTextNode(X.exec(k)[0]),o.firstChild),k=o.childNodes}var r;if(!f.support.appendChecked)if(k[0]&&typeof (r=k.length)=="number")for(i=0;i<r;i++)bn(k[i]);else bn(k);k.nodeType?h.push(k):h=f.merge(h,k)}if(d){g=function(a){return!a.type||be.test(a.type)};for(j=0;h[j];j++)if(e&&f.nodeName(h[j],"script")&&(!h[j].type||h[j].type.toLowerCase()==="text/javascript"))e.push(h[j].parentNode?h[j].parentNode.removeChild(h[j]):h[j]);else{if(h[j].nodeType===1){var s=f.grep(h[j].getElementsByTagName("script"),g);h.splice.apply(h,[j+1,0].concat(s))}d.appendChild(h[j])}}return h},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bq=/alpha\([^)]*\)/i,br=/opacity=([^)]*)/,bs=/([A-Z]|^ms)/g,bt=/^-?\d+(?:px)?$/i,bu=/^-?\d/,bv=/^([\-+])=([\-+.\de]+)/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Left","Right"],by=["Top","Bottom"],bz,bA,bB;f.fn.css=function(a,c){if(arguments.length===2&&c===b)return this;return f.access(this,a,c,!0,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)})},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bz(a,"opacity","opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bv.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(bz)return bz(a,c)},swap:function(a,b,c){var d={};for(var e in b)d[e]=a.style[e],a.style[e]=b[e];c.call(a);for(e in b)a.style[e]=d[e]}}),f.curCSS=f.css,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){var e;if(c){if(a.offsetWidth!==0)return bC(a,b,d);f.swap(a,bw,function(){e=bC(a,b,d)});return e}},set:function(a,b){if(!bt.test(b))return b;b=parseFloat(b);if(b>=0)return b+"px"}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return br.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bq,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bq.test(g)?g.replace(bq,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){var c;f.swap(a,{display:"inline-block"},function(){b?c=bz(a,"margin-right","marginRight"):c=a.style.marginRight});return c}})}),c.defaultView&&c.defaultView.getComputedStyle&&(bA=function(a,b){var c,d,e;b=b.replace(bs,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b)));return c}),c.documentElement.currentStyle&&(bB=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f===null&&g&&(e=g[b])&&(f=e),!bt.test(f)&&bu.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f||0,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),bz=bA||bB,f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)});var bD=/%20/g,bE=/\[\]$/,bF=/\r?\n/g,bG=/#.*$/,bH=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bI=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bJ=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bK=/^(?:GET|HEAD)$/,bL=/^\/\//,bM=/\?/,bN=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bO=/^(?:select|textarea)/i,bP=/\s+/,bQ=/([?&])_=[^&]*/,bR=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bS=f.fn.load,bT={},bU={},bV,bW,bX=["*/"]+["*"];try{bV=e.href}catch(bY){bV=c.createElement("a"),bV.href="",bV=bV.href}bW=bR.exec(bV.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bS)return bS.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bN,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bO.test(this.nodeName)||bI.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bF,"\r\n")}}):{name:b.name,value:c.replace(bF,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b_(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b_(a,b);return a},ajaxSettings:{url:bV,isLocal:bJ.test(bW[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bX},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bZ(bT),ajaxTransport:bZ(bU),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?cb(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cc(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bH.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bG,"").replace(bL,bW[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bP),d.crossDomain==null&&(r=bR.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bW[1]&&r[2]==bW[2]&&(r[3]||(r[1]==="http:"?80:443))==(bW[3]||(bW[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),b$(bT,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bK.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bM.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bQ,"$1_="+x);d.url=y+(y===d.url?(bM.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bX+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=b$(bU,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)ca(g,a[g],c,e);return d.join("&").replace(bD,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cd=f.now(),ce=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cd++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=b.contentType==="application/x-www-form-urlencoded"&&typeof b.data=="string";if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(ce.test(b.url)||e&&ce.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(ce,l),b.url===j&&(e&&(k=k.replace(ce,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var cf=a.ActiveXObject?function(){for(var a in ch)ch[a](0,1)}:!1,cg=0,ch;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ci()||cj()}:ci,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,cf&&delete ch[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n),m.text=h.responseText;try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cg,cf&&(ch||(ch={},f(a).unload(cf)),ch[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var ck={},cl,cm,cn=/^(?:toggle|show|hide)$/,co=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,cp,cq=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cr;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(cu("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),e===""&&f.css(d,"display")==="none"&&f._data(d,"olddisplay",cv(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(cu("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(cu("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]),h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cv(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cn.test(h)?(o=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),o?(f._data(this,"toggle"+i,o==="show"?"hide":"show"),j[o]()):j[h]()):(k=co.exec(h),l=j.cur(),k?(m=parseFloat(k[2]),n=k[3]||(f.cssNumber[i]?"":"px"),n!=="px"&&(f.style(this,i,(m||1)+n),l=(m||1)/j.cur()*l,f.style(this,i,l+n)),k[1]&&(m=(k[1]==="-="?-1:1)*m+l),j.custom(l,m,n)):j.custom(l,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:cu("show",1),slideUp:cu("hide",1),slideToggle:cu("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a,b,c,d){return c+d*a},swing:function(a,b,c,d){return(-Math.cos(a*Math.PI)/2+.5)*d+c}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cr||cs(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){e.options.hide&&f._data(e.elem,"fxshow"+e.prop)===b&&f._data(e.elem,"fxshow"+e.prop,e.start)},h()&&f.timers.push(h)&&!cp&&(cp=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cr||cs(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(cp),cp=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(["width","height"],function(a,b){f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)}}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?f.fn.offset=function(a){var b=this[0],c;if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);try{c=b.getBoundingClientRect()}catch(d){}var e=b.ownerDocument,g=e.documentElement;if(!c||!f.contains(g,b))return c?{top:c.top,left:c.left}:{top:0,left:0};var h=e.body,i=cy(e),j=g.clientTop||h.clientTop||0,k=g.clientLeft||h.clientLeft||0,l=i.pageYOffset||f.support.boxModel&&g.scrollTop||h.scrollTop,m=i.pageXOffset||f.support.boxModel&&g.scrollLeft||h.scrollLeft,n=c.top+l-j,o=c.left+m-k;return{top:n,left:o}}:f.fn.offset=function(a){var b=this[0];if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);var c,d=b.offsetParent,e=b,g=b.ownerDocument,h=g.documentElement,i=g.body,j=g.defaultView,k=j?j.getComputedStyle(b,null):b.currentStyle,l=b.offsetTop,m=b.offsetLeft;while((b=b.parentNode)&&b!==i&&b!==h){if(f.support.fixedPosition&&k.position==="fixed")break;c=j?j.getComputedStyle(b,null):b.currentStyle,l-=b.scrollTop,m-=b.scrollLeft,b===d&&(l+=b.offsetTop,m+=b.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(b.nodeName))&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),e=d,d=b.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&c.overflow!=="visible"&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),k=c}if(k.position==="relative"||k.position==="static")l+=i.offsetTop,m+=i.offsetLeft;f.support.fixedPosition&&k.position==="fixed"&&(l+=Math.max(h.scrollTop,i.scrollTop),m+=Math.max(h.scrollLeft,i.scrollLeft));return{top:l,left:m}},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each(["Left","Top"],function(a,c){var d="scroll"+c;f.fn[d]=function(c){var e,g;if(c===b){e=this[0];if(!e)return null;g=cy(e);return g?"pageXOffset"in g?g[a?"pageYOffset":"pageXOffset"]:f.support.boxModel&&g.document.documentElement[d]||g.document.body[d]:e[d]}return this.each(function(){g=cy(this),g?g.scrollTo(a?f(g).scrollLeft():c,a?c:f(g).scrollTop()):this[d]=c})}}),f.each(["Height","Width"],function(a,c){var d=c.toLowerCase();f.fn["inner"+c]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,d,"padding")):this[d]():null},f.fn["outer"+c]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,d,a?"margin":"border")):this[d]():null},f.fn[d]=function(a){var e=this[0];if(!e)return a==null?null:this;if(f.isFunction(a))return this.each(function(b){var c=f(this);c[d](a.call(this,b,c[d]()))});if(f.isWindow(e)){var g=e.document.documentElement["client"+c],h=e.document.body;return e.document.compatMode==="CSS1Compat"&&g||h&&h["client"+c]||g}if(e.nodeType===9)return Math.max(e.documentElement["client"+c],e.body["scroll"+c],e.documentElement["scroll"+c],e.body["offset"+c],e.documentElement["offset"+c]);if(a===b){var i=f.css(e,d),j=parseFloat(i);return f.isNumeric(j)?j:i}return this.css(d,typeof a=="string"?a:a+"px")}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>deuce -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name"><a href="http://hraberg.github.io/deuce/">deuce</a></h1><h2 class="project-version">0.1.0-SNAPSHOT</h2><br /><p>DEUCE - Deuce is (not yet) Emacs under Clojure</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.7.0</td></tr><tr><td class="dep-name">clojure-lanterna</td><td class="dotted"><hr /></td><td class="dep-version">0.9.3</td></tr><tr><td class="dep-name">com.taoensso/timbre</td><td class="dotted"><hr /></td><td class="dep-version">4.3.1</td></tr><tr><td class="dep-name">org.tcrawley/dynapath</td><td class="dotted"><hr /></td><td class="dep-version">0.2.3</td></tr><tr><td class="dep-name">org.flatland/ordered</td><td class="dotted"><hr /></td><td class="dep-version">1.5.3</td></tr><tr><td class="dep-name">fipp</td><td class="dotted"><hr /></td><td class="dep-version">0.5.1</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#data_readers.clj">data_readers.clj</a></li><li><a href="#deuce.main">deuce.main</a></li><li><a href="#deuce.emacs-lisp">deuce.emacs-lisp</a></li><li><a href="#deuce.emacs.keyboard">deuce.emacs.keyboard</a></li><li><a href="#deuce.emacs.casefiddle">deuce.emacs.casefiddle</a></li><li><a href="#deuce.emacs.composite">deuce.emacs.composite</a></li><li><a href="#deuce.emacs.lread">deuce.emacs.lread</a></li><li><a href="#deuce.emacs.indent">deuce.emacs.indent</a></li><li><a href="#deuce.emacs.floatfns">deuce.emacs.floatfns</a></li><li><a href="#deuce.emacs.insdel">deuce.emacs.insdel</a></li><li><a href="#deuce.emacs.font">deuce.emacs.font</a></li><li><a href="#deuce.emacs.textprop">deuce.emacs.textprop</a></li><li><a href="#deuce.emacs.doc">deuce.emacs.doc</a></li><li><a href="#deuce.emacs.editfns">deuce.emacs.editfns</a></li><li><a href="#deuce.emacs.minibuf">deuce.emacs.minibuf</a></li><li><a href="#deuce.emacs.menu">deuce.emacs.menu</a></li><li><a href="#deuce.emacs.fileio">deuce.emacs.fileio</a></li><li><a href="#deuce.emacs.window">deuce.emacs.window</a></li><li><a href="#deuce.emacs.fns">deuce.emacs.fns</a></li><li><a href="#deuce.emacs.data">deuce.emacs.data</a></li><li><a href="#deuce.emacs.callproc">deuce.emacs.callproc</a></li><li><a href="#deuce.emacs.bytecode">deuce.emacs.bytecode</a></li><li><a href="#deuce.emacs.ccl">deuce.emacs.ccl</a></li><li><a href="#deuce.emacs.buffer">deuce.emacs.buffer</a></li><li><a href="#deuce.emacs.chartab">deuce.emacs.chartab</a></li><li><a href="#deuce.emacs.filelock">deuce.emacs.filelock</a></li><li><a href="#deuce.emacs.casetab">deuce.emacs.casetab</a></li><li><a href="#deuce.emacs.coding">deuce.emacs.coding</a></li><li><a href="#deuce.emacs.marker">deuce.emacs.marker</a></li><li><a href="#deuce.emacs.category">deuce.emacs.category</a></li><li><a href="#deuce.emacs.print">deuce.emacs.print</a></li><li><a href="#deuce.emacs.xfaces">deuce.emacs.xfaces</a></li><li><a href="#deuce.emacs.macros">deuce.emacs.macros</a></li><li><a href="#deuce.emacs.dired">deuce.emacs.dired</a></li><li><a href="#deuce.emacs.undo">deuce.emacs.undo</a></li><li><a href="#deuce.emacs.charset">deuce.emacs.charset</a></li><li><a href="#deuce.emacs.process">deuce.emacs.process</a></li><li><a href="#deuce.emacs.character">deuce.emacs.character</a></li><li><a href="#deuce.emacs.xdisp">deuce.emacs.xdisp</a></li><li><a href="#deuce.emacs.eval">deuce.emacs.eval</a></li><li><a href="#deuce.emacs.cmds">deuce.emacs.cmds</a></li><li><a href="#deuce.emacs.dispnew">deuce.emacs.dispnew</a></li><li><a href="#deuce.emacs.keymap">deuce.emacs.keymap</a></li><li><a href="#deuce.emacs.xml">deuce.emacs.xml</a></li><li><a href="#deuce.emacs.terminal">deuce.emacs.terminal</a></li><li><a href="#deuce.emacs.syntax">deuce.emacs.syntax</a></li><li><a href="#deuce.emacs.search">deuce.emacs.search</a></li><li><a href="#deuce.emacs.callint">deuce.emacs.callint</a></li><li><a href="#deuce.emacs.alloc">deuce.emacs.alloc</a></li><li><a href="#deuce.emacs.term">deuce.emacs.term</a></li><li><a href="#deuce.emacs.emacs">deuce.emacs.emacs</a></li><li><a href="#deuce.emacs.frame">deuce.emacs.frame</a></li><li><a href="#deuce.emacs-lisp.globals">deuce.emacs-lisp.globals</a></li><li><a href="#deuce.emacs-lisp.printer">deuce.emacs-lisp.printer</a></li><li><a href="#deuce.emacs-lisp.cons">deuce.emacs-lisp.cons</a></li><li><a href="#deuce.emacs-lisp.parser">deuce.emacs-lisp.parser</a></li><li><a href="#deuce.emacs">deuce.emacs</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#data_readers.clj" name="data_readers.clj"><h1 class="project-name">data_readers.clj</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">{el/vec deuce.emacs-lisp/vector-reader
 el/sym deuce.emacs-lisp/symbol-reader}</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.main" name="deuce.main"><h1 class="project-name">deuce.main</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.main
  (:require [clojure.string :as s]
            [clojure.java.io :as io]
            [lanterna.screen :as sc]
            [lanterna.terminal :as te]
            [deuce.emacs]
            [deuce.emacs-lisp :as el]
            [deuce.emacs-lisp.globals :as globals]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns]
            [deuce.emacs.eval :as eval]
            [deuce.emacs.fns :as fns]
            [deuce.emacs.frame :as frame]
            [deuce.emacs.keymap :as keymap]
            [deuce.emacs.keyboard :as keyboard]
            [deuce.emacs.lread :as lread]
            [deuce.emacs.terminal :as terminal]
            [deuce.emacs.window :as window]
            [deuce.emacs.xdisp :as xdisp]
            [taoensso.timbre :as timbre]
            [taoensso.timbre.appenders.core :as timbre-appenders]
            [dynapath.util :as dp])
  (:import [java.io FileNotFoundException InputStreamReader]
           [java.awt Toolkit]
           [java.awt.datatransfer DataFlavor StringSelection]
           [clojure.lang ExceptionInfo]
           [deuce.emacs.data Buffer Window]
           [com.googlecode.lanterna.screen Screen])
  (:gen-class))</pre></td></tr><tr><td class="docs"><p>Start Deuce like this:
   lein trampoline run -Q --nrepl</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Using -Q will put you in <em>scratch</em>, with the keyboard enabled.
There's no minibuffer yet, so you have to switch buffer from the REPL.
Several keyboard commands fail or are a bit off (like move-end-of-line).</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Connect to nREPL from Emacs:
user> (in-ns 'deuce.emacs)  ;; We're now in Emacs Lisp</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Tail the log at ~/.deuce.d/deuce.log
Errors are also visible in the Echo Area</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn nrepl [port]
  (require 'clojure.tools.nrepl.server)
  (with-out-str
    ((resolve 'clojure.tools.nrepl.server/start-server)
     :port port
     :handler (try
                (require 'cider.nrepl)
                (resolve 'cider.nrepl/cider-nrepl-handler)
                (catch Exception _
                  (resolve 'clojure.tools.nrepl.server/default-handler)))))
  (println &quot;nrepl server listening on&quot; port))</pre></td></tr><tr><td class="docs"><p>The way this does this is probably utterly wrong, written by data inspection, not reading Emacs source.
But produces the expected result:</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-menu-bar []
  (when (data/symbol-value 'menu-bar-mode)
    (let [map-for-mode #(let [map (symbol (str % &quot;-map&quot;))]
                          (when (data/boundp map)
                            (data/symbol-value map)))
          ;; The consp check here is suspicious.
          ;; There's a &quot;menu-bar&quot; string in there which probably shouldn't be.
          menus-for-map #(map keymap/keymap-prompt (filter data/consp (fns/nthcdr 2 (fns/assq 'menu-bar %))))
          menu-bar-by-name #(data/symbol-value (symbol (str &quot;menu-bar-&quot; %)))
          final-items (map menu-bar-by-name (data/symbol-value 'menu-bar-final-items))
          final-menus (map keymap/keymap-prompt final-items)
          ;; Hack to create the same display order as Emacs.
          menu-bar (concat (remove (some-fn nil? symbol?) ;; This is to get rid of tmm-menu-bar-mouse
                                   (remove (set final-menus) ;; Remove Help that goes on the end.
                                           (mapcat menus-for-map [(keymap/current-global-map)
                                                                  (keymap/current-local-map)])))
                           final-menus)]
      (s/join &quot; &quot; menu-bar))))</pre></td></tr><tr><td class="docs"><p>Renders a single window using Lanterna. Scrolling is not properly taken care of.
Hard to bootstrap, requires fiddling when connected to nREPL inside Deuce atm.
Consider moving all this into deuce.emacs.dispnew</p>
</td><td class="codes"><pre class="brush: clojure">(declare ^Screen screen)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def colors {:bg :default :fg :default})
(def reverse-video {:styles #{:reverse}})
(def region-colors {:fg :default :bg :yellow})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn puts
  ([x y s] (puts x y s colors))
  ([x y s opts] (sc/put-string screen x y (str s) opts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pad [s cols]
  (format (str &quot;%-&quot; cols &quot;s&quot;) s))</pre></td></tr><tr><td class="docs"><p>If the screen gets messed up by other output like a stack trace you need to call this.</p>
</td><td class="codes"><pre class="brush: clojure">(defn blank []
  (sc/clear screen)
  (te/clear (.getTerminal screen))
  (sc/redraw screen))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doseq [f '[line-indexes pos-to-line point-coords]]
  (eval `(def ~f (ns-resolve 'deuce.emacs.cmds '~f))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-live-window [^Window window]
  (let [^Buffer buffer (window/window-buffer window)
        minibuffer? (window/window-minibuffer-p window)
        [header-line mode-line] (when-not minibuffer?
                                  [(buffer/buffer-local-value 'header-line-format buffer)
                                   (buffer/buffer-local-value 'mode-line-format buffer)])
        text (binding [buffer/*current-buffer* buffer]
               (editfns/buffer-string))
        line-indexes (line-indexes text)
        pos-to-line (partial pos-to-line line-indexes)
        point-coords (partial point-coords line-indexes)
        pt (- @(.pt buffer) (or @(.begv buffer) 0))
        line (pos-to-line pt)
        total-lines (- @(.total-lines window) (or (count (remove nil? [header-line mode-line])) 0))
        scroll (max (inc (- line total-lines)) 0)
        mark-active? (buffer/buffer-local-value 'mark-active buffer)
        selected-window? (= window (window/selected-window))]
    (let [lines (s/split text #&quot;\n&quot;)
          cols @(.total-cols window)
          top-line @(.top-line window)
          top-line (if header-line (inc top-line) top-line)
          screen-coords (fn [[x y]] [x  (+ top-line (- y scroll))])] ;; Not dealing with horizontal scroll.
      (when header-line
        (puts 0 (dec top-line) (pad (xdisp/format-mode-line header-line nil window buffer) cols) reverse-video))
      (let [[[rbx rby] [rex rey]]
            (if (and mark-active? selected-window?)
              [(screen-coords (point-coords (dec (editfns/region-beginning))))
               (screen-coords (point-coords (dec (editfns/region-end))))]
              [[-1 -1] [-1 -1]])]
        (dotimes [n total-lines]
          (let [screen-line (+ top-line n)
                text (pad (nth lines (+ scroll n) &quot; &quot;) cols)]
            (cond
             (= screen-line rby rey) (do
                                       (puts 0 screen-line (subs text 0 rbx))
                                       (puts rbx screen-line (subs text rbx rex) region-colors)
                                       (puts rex screen-line (subs text rex)))
             (= screen-line rby) (do
                                   (puts 0 screen-line (subs text 0 rbx))
                                   (puts rbx screen-line (subs text rbx) region-colors))
             (= screen-line rey) (do
                                   (puts 0 screen-line (subs text 0 rex) region-colors)
                                   (puts rex screen-line (subs text rex)))
             (&lt; rby screen-line rey) (puts 0 screen-line text region-colors)
             :else (puts 0 screen-line text)))))
      (when selected-window?
        (let [[px py] (screen-coords (point-coords (dec pt)))]
          (sc/move-cursor screen px py)))
      (when mode-line
        (puts 0 (+ top-line total-lines) (pad (xdisp/format-mode-line mode-line nil window buffer) cols) {:bg :white})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-window [^Window window x y width height]
  ;; We should walk the tree, splitting windows as we go.
  ;; top or left children in turn have next siblings all sharing this area.
  ;; A live window is a normal window with buffer.
  (reset! (.top-line window) y)
  (reset! (.left-col window) x)
  ;; &quot;normal&quot; size is a weight between 0 - 1.0, should hopfully add up.
  (reset! (.total-cols window) (long (* @(.normal-cols window) width)))
  (reset! (.total-lines window) (long (* @(.normal-lines window) height)))
  (condp some [window]
    window/window-live-p (render-live-window window)
    window/window-top-child (throw (UnsupportedOperationException.))
    window/window-left-child (throw (UnsupportedOperationException.))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def size (atom nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn update-terminal-size []
  (reset! size (te/get-size (.getTerminal screen))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn display-using-lanterna []
  (let [[width height] @size
        mini-buffer-window (window/minibuffer-window)
        mini-buffer (- height (window/window-total-height mini-buffer-window))
        menu-bar-mode (data/symbol-value 'menu-bar-mode)
        menu-bar (if menu-bar-mode 1 0)]
    (when menu-bar-mode
      (puts 0 0 (pad (render-menu-bar) width) reverse-video))
    (render-window (window/frame-root-window) 0 menu-bar
                   width (- mini-buffer menu-bar))
    (render-window (window/minibuffer-window) 0 mini-buffer
                   width (window/window-total-height mini-buffer-window))
    (sc/redraw screen)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def running (atom nil))
(def ^InputStreamReader in (InputStreamReader. System/in))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stop-ui []
  (reset! running :stop)
  (while @running
    (Thread/sleep 20)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn running? []
  (true? @running))</pre></td></tr><tr><td class="docs"><p>Not the real thing, but keeps the UI changing while using the REPL before we got a real command loop.</p>
</td><td class="codes"><pre class="brush: clojure">(defn start-render-loop []
  (reset! running true)
  (blank)
  (future
    (while (running?)
      (try
        (display-using-lanterna)
        (Thread/sleep 15)
        (catch Exception e
          (reset! running nil)
          (binding [*ns* (the-ns 'clojure.core)]
            (timbre/error e &quot;An error occured during the render loop&quot;))
          (throw e))))
    (reset! running nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def char-buffer (atom []))
(def event-buffer (atom []))</pre></td></tr><tr><td class="docs"><p>We bypass Lanterna with System/in but utilize their setup of private mode, see deuce.emacs.keyboard
We report our TERM as "lanterna" to allow terminal-init-lanterna to be run first, then init the real one.
All this has only been tested on TERM=xterm
input-decode-map is setup in term/xterm. We should also look in local-function-key-map
This interfers badly with Lanterna's get-size, occasionally locks up, needs fix.</p>
</td><td class="codes"><pre class="brush: clojure">(defn read-key []
  ;; Somewhere here we could maybe update the screen size, doesn't work.
  ;; (when-not (.ready in)
  ;;   (update-terminal-size))
  (let [c (.read in)]
;    (println c (char c))
    (swap! char-buffer conj (char c))
    (let [maybe-event (object-array @char-buffer)
          decoded (keymap/lookup-key (data/symbol-value 'input-decode-map) maybe-event)]
      (if (keymap/keymapp decoded)
        nil
;        (println &quot;potential input-decode prefix&quot; maybe-event)
        (let [_ (reset! char-buffer [])
              event (if (data/vectorp decoded) decoded maybe-event)
              _ (swap! event-buffer (comp vec concat) event)
              def (keymap/key-binding (object-array @event-buffer))]
;          (println maybe-event decoded event @event-buffer (if (keymap/keymapp def) &quot;(keymap)&quot; def))
          (if (and def (not (keymap/keymapp def)))
            (try
              ;; There are many more things that can happen here
              (el/setq last-event-frame (frame/selected-frame))
              (el/setq last-command-event (last @event-buffer))
              (el/setq last-nonmenu-event (last @event-buffer))
              ;; this-command-keys and this-command-keys-vector return the entire event-buffer as string or vector.
              ;; They are backed by one variable in C, this_command_keys.
              (el/setq this-command def)
              (el/setq this-original-command def) ;; Need to handle remap
              (el/setq deactivate-mark nil)
              (buffer/set-buffer (window/window-buffer (window/selected-window)))
              (reset! char-buffer [])
              (reset! event-buffer [])
              (eval/run-hooks 'pre-command-hook)
              (timbre/debug (format &quot;Command: %s&quot; def))
              (keyboard/command-execute def)
              (finally
               (eval/run-hooks 'post-command-hook)
               (when (data/symbol-value 'deactivate-mark)
                 (eval/funcall 'deactivate-mark))
               (el/setq this-command nil)
               (el/setq this-original-command nil)
               (el/setq last-prefix-arg (data/symbol-value 'current-prefix-arg))
               (el/setq last-command (data/symbol-value 'this-command))
               (el/setq real-last-command (data/symbol-value 'this-command))))
            (when-not (keymap/keymapp def)
              (reset! char-buffer [])
              (reset! event-buffer []))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn drain-input-stream [^InputStreamReader in]
  (while (.ready in)
    (.read in)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start-input-loop []
  (reset! running true)
  (drain-input-stream in)
  (future
    (while (running?)
      (try
        (read-key)
        (catch ExceptionInfo e
          (binding [*ns* (the-ns 'clojure.core)]
            (timbre/error (.getMessage e))))
        (catch Exception e
          ;; This is a simplification, but makes you aware of the error without tailing the log.
          ((ns-resolve 'deuce.emacs.lread 'echo) (.getMessage e))
          (binding [*ns* (the-ns 'clojure.core)]
            (timbre/error (el/cause e) &quot;An error occured during the input loop&quot;)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn init-clipboard []
  (let [clipboard (.getSystemClipboard (Toolkit/getDefaultToolkit))]
    (el/setq interprogram-cut-function
             #(let [selection (StringSelection. %)]
                (.setContents clipboard selection selection)))
    (el/setq interprogram-paste-function
             #(.getData clipboard DataFlavor/stringFlavor))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn inside-emacs? []
  (= &quot;dumb&quot; (System/getenv &quot;TERM&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start-ui []
  (start-render-loop)
  (start-input-loop))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare init-user-classpath)</pre></td></tr><tr><td class="docs"><p>Callback run by faces/tty-run-terminal-initialization based on deuce.emacs.term/tty-type returning "lanterna"
Has Emacs Lisp proxy in deuce.emacs.</p>
</td><td class="codes"><pre class="brush: clojure">(defn terminal-init-lanterna []
  (try
    (when-not (inside-emacs?)
      (init-user-classpath)
      ((ns-resolve 'deuce.emacs.terminal 'init-initial-terminal))
      (def screen (terminal/frame-terminal))
      ;; We need to deal with resize later, it queries and gets the result on System/in which we have taken over.
      ;; Initialize the real TERM, should setup input-decode-map and local-function-key-map
      (eval/eval '(tty-run-terminal-initialization (selected-frame)
                                                   (getenv-internal &quot;TERM&quot;)))
      (update-terminal-size)
      (init-clipboard)
      (start-ui))
    (catch Exception e
      (when screen
        (sc/stop screen))
      (timbre/error e &quot;An error occured during Lanterna init&quot;)
      (throw e))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def deuce-dot-d (str (doto (io/file (System/getProperty &quot;user.home&quot;) &quot;.deuce.d&quot;)
                        .mkdirs)))
(def ^:dynamic *emacs-compile-path* *compile-path*)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn init-user-classpath []
  (dp/add-classpath-url (ClassLoader/getSystemClassLoader) (.toURL (io/file deuce-dot-d)))
  (alter-var-root #'*emacs-compile-path* (constantly deuce-dot-d)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn load-user-init-file []
  (let [init-file (io/file deuce-dot-d &quot;init.clj&quot;)]
    (try
      (when (.exists init-file)
        (load-file (str init-file)))
      (catch Exception e
        (timbre/error e (format &quot;An error occurred while loading `%s':&quot; (str init-file)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn restart []
  (let [args (next (data/symbol-value 'command-line-args))]
    (terminal/delete-terminal)
    (some-&gt; 'deuce.main/-main resolve (apply args))
    (terminal-init-lanterna)
    :ok))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(timbre/merge-config!
 {:appenders
  {:deuce-buffer-appender
   {:min-level :debug :enabled? true :async? true
    :fn (fn [{:keys [output-fn] :as data}]
          (binding [buffer/*current-buffer* (buffer/get-buffer-create &quot;*Deuce*&quot;)]
            (editfns/insert (str (output-fn data) \newline))))}
   :println (merge (timbre-appenders/println-appender)
                   {:enabled? (inside-emacs?)})
   :spit (merge (timbre-appenders/spit-appender {:fname (str (io/file deuce-dot-d &quot;deuce.log&quot;))})
                {:min-level :debug :enabled? true})}})</pre></td></tr><tr><td class="docs"><p>We want to support emacs -q initially. -q is --no-init-file</p>
</td><td class="codes"><pre class="brush: clojure">(defn -main [&amp; args]
  (timbre/debug &quot;Starting Deuce&quot;)
  (let [option #(hash-set (str &quot;-&quot; %) (str &quot;--&quot; %))
        inhibit-window-system (atom nil)
        args (map
              #(condp some [%]
                 (option &quot;script&quot;) &quot;-scriptload&quot;
                 (option &quot;version&quot;) (do (printf &quot;GNU Emacs %s\n&quot; (data/symbol-value 'emacs-version))
                                        (printf &quot;%s\n&quot; (data/symbol-value 'emacs-copyright))
                                        (printf &quot;GNU Emacs comes with ABSOLUTELY NO WARRANTY.\n&quot;)
                                        (printf &quot;You may redistribute copies of Emacs\n&quot;)
                                        (printf &quot;under the terms of the GNU General Public License.\n&quot;)
                                        (printf &quot;For more information about these matters, &quot;)
                                        (printf &quot;see the file named COPYING.\n&quot;)
                                        (flush)
                                        (System/exit 0))
                 (option &quot;batch&quot;) (do (el/setq noninteractive true) nil)
                 (option &quot;nrepl&quot;) (nrepl 7888)
                 #{&quot;-nw&quot; &quot;--no-window-system,&quot;} (do (reset! inhibit-window-system true))
                 %) args)]
    (el/setq command-line-args (alloc/cons &quot;src/bootstrap-emacs&quot; (apply alloc/list (remove nil? args))))
    (lread/load &quot;deuce-loadup.el&quot;)
    (when (data/symbol-value 'init-file-user)
      (load-user-init-file))
    ;; /* Enter editor command loop.  This never returns.  */
    (keyboard/recursive-edit)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs-lisp" name="deuce.emacs-lisp"><h1 class="project-name">deuce.emacs-lisp</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs-lisp
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [clojure.pprint :as pp]
            [clojure.walk :as w]
            [deuce.emacs-lisp.cons :as cons])
  (:use [taoensso.timbre :as timbre
         :only (trace debug info warn error fatal spy)])
  (:import [clojure.lang Var ExceptionInfo IMeta]
           [java.io Writer]
           [java.lang.reflect Method])
  (:refer-clojure :exclude [defmacro and or cond let while eval set compile]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(timbre/merge-config! {:timestamp-opts {:pattern &quot;HH:mm:ss,SSS&quot;}
                       :appenders {:println {:min-level :error}}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(timbre/set-level! :debug)
(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(create-ns 'deuce.emacs)
(create-ns 'deuce.emacs-lisp.globals)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare clojure-special-forms throw throw* defvar el-&gt;clj eval emacs-lisp-backquote defvar-helper*)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn vector-reader [v]
  (object-array (vec v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn symbol-reader [s]
  (symbol nil s))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sym [s]
  (c/cond
    (true? s)'#el/sym &quot;true&quot;
    (nil? s) '#el/sym &quot;nil&quot;
    :else (symbol nil (name s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn not-null? [object]
  (when-not (c/or (nil? object) (c/= () object) (false? object))
    object))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn global [s]
  (ns-resolve 'deuce.emacs-lisp.globals (sym s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fun [s]
  (condp some [s]
    fn? s
    var? (fun @s)
    symbol? (c/let [f (ns-resolve 'deuce.emacs (sym s))]
              ;; Not sure we want alias handling leaking down to here.
              ;; On the other hand, 24.3 uses defalias + lambda as primary macros.
              ;; Hack to protect against backquote alias, needs proper fix.
              (if-let [alias (c/and (not= '#el/sym &quot;\\`&quot; s)
                                    (-&gt; f meta :alias))]
                (if (symbol? alias) ;; See binding/mode-specific-command-prefix
                  (fun alias)
                  alias)
                f))
    (every-pred seq? (comp '#{lambda keymap} first)) s ;; symbol-function should really be permissive about this.
    (throw* 'invalid-function (list s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn maybe-sym [x]
  (if (symbol? x) (sym x) x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn emacs-lisp-error [tag value]
  (proxy [ExceptionInfo] [(str tag) {:tag tag :value value}]
    (getMessage [] (str this))
    (toString []
      (str (cons (:tag (.data ^ExceptionInfo this))
                 (c/let [d (:value (.-data ^ExceptionInfo this))]
                   (if (seq? d) d [d])))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn throw* [tag value]
  (throw (emacs-lisp-error tag value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn scope [&amp;env]
  (c/set (remove #(re-find #&quot;__\d+&quot; (name %)) (keys &amp;env))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *dynamic-vars* {})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def symbol-plists (atom {}))</pre></td></tr><tr><td class="docs"><p>There's also an obsolete (as of Emacs 22.2) concept of frame locals.
See deuce.emacs.data/make-variable-frame-local and deuce.emacs.frame/modify-frame-parameters
This is the set of variables which can potentially be buffer local, values are stored in local-var-alist on Buffer.
It's initialized by deuce.emacs.buffer/init-buffer-locals</p>
</td><td class="codes"><pre class="brush: clojure">(def buffer-locals (atom #{}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn el-var-buffer-local [needs-to-exist? name]
  (when-let [buffer ((fun 'current-buffer))]
    (c/let [buffer-local (@(:local-var-alist buffer) name)]
      (if-not needs-to-exist?
        (c/or buffer-local
              (when (contains? @buffer-locals name)
                (c/let [v (Var/create)]
                  (swap! (:local-var-alist buffer) assoc name v)
                  v)))
        (when (c/and buffer-local (bound? buffer-local)) buffer-local)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn el-var [name]
  ((some-fn *dynamic-vars* (partial el-var-buffer-local true) global) name))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn el-var-get* [name]
  (c/let [name (sym name)]
    (if-let [v (el-var name)]
      @v
      (throw* 'void-variable (list name)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(c/defmacro el-var-get [name]
  (c/let [name (sym name)]
    (if (c/and (symbol? name) (name &amp;env))
      `(if (var? ~name)
         (if (bound? ~name) @~name
             (throw* '~'void-variable (list '~name)))
         ~name)
      `(el-var-get* '~name))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn el-var-set-default* [name value]
  (if-let [v (global name)]
    (alter-var-root v (constantly value))
    @(global (defvar-helper* 'deuce.emacs-lisp.globals name value))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(c/defmacro el-var-set-default [name value]
  (c/let [name (sym name)]
    `(el-var-set-default* '~name ~value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn el-var-set* [name-or-var value]
  (if-let [^Var v (c/or (c/and (var? name-or-var) name-or-var)
                        ((some-fn *dynamic-vars* (partial el-var-buffer-local false)) name-or-var))]
    (if (c/or (c/and (.hasRoot v) (not (.getThreadBinding v))) (not (bound? v)))
      (alter-var-root v (constantly value))
      (var-set v value))
    (el-var-set-default* name-or-var value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(c/defmacro el-var-set [name value]
  (c/let [name (sym name)]
    `(el-var-set* ~(if (c/and (symbol? name) (name &amp;env))
                     `~name
                     `'~name)
                  ~value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn dynamic-binding? []
  (not (el-var-get lexical-binding)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(c/defmacro with-local-el-vars [name-vals-vec &amp; body]
  (c/let [vars (vec (map sym (take-nth 2 name-vals-vec)))
          vals (vec (take-nth 2 (rest name-vals-vec)))]
    `(c/let [vars# (hash-map ~@(interleave (map #(list 'quote %) vars)
                                           (map #(do `(c/or (*dynamic-vars* '~%) (global '~%)
                                                            (.setDynamic (Var/create)))) vars)))]
       (with-bindings (zipmap (map vars# '~vars) ~vals)
         (binding [*dynamic-vars* (if (dynamic-binding?) (merge *dynamic-vars* vars#) {})]
           (c/let [{:syms ~vars} vars#]
             ~@body))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *disallow-undefined* #{})</pre></td></tr><tr><td class="docs"><p>build cached invoker to use once target is resolved?</p>
</td><td class="codes"><pre class="brush: clojure">(defn delayed-eval* [expr]
  (binding [*disallow-undefined* (conj *disallow-undefined* (first expr))]
    (eval expr)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(c/defmacro delayed-eval [expr]
  `(delayed-eval* '~expr))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn expand-dotted-lists [x]
  (if (c/or (cons/dotted-list? x) (cons/dotted-pair? x))
    (apply cons/list x)
    x))</pre></td></tr><tr><td class="docs"><p>Break this up and explain what the different branches are doing and why.</p>
</td><td class="codes"><pre class="brush: clojure">(defn el-&gt;clj [x]
  (cond-&gt; (condp some [x]
            #{()} nil
            seq? (c/let [[fst &amp; rst] x]
                   (if (c/and (symbol? fst)
                              (not= 'progn fst)
                              (-&gt; (fun fst) meta :macro))
                     (if (c/or (clojure-special-forms fst) ('#{let lambda} fst)) ;; defun defvar ?
                       (if (= 'quote fst)
                         (if-let [s (c/and (symbol? (first rst)) (not (next rst)) (first rst))]
                           (list 'quote (if (= &quot;deuce.emacs&quot; (namespace s)) (sym s) s))
                           (if (= '(()) rst) () x))
                         (apply cons/list (c/cons (symbol &quot;deuce.emacs-lisp&quot; (name fst)) rst)))
                       (apply cons/list x))
                     (if (#{`el-var-get `el-var-set `el-var-set-default `delayed-eval
                            '#el/sym &quot;\\,&quot; '#el/sym &quot;\\,@&quot;} fst)
                       x
                       (if (=  '#el/sym &quot;\\`&quot; fst)
                         (emacs-lisp-backquote x) ;; See below, we dont want to duplicate this if not necessary.
                         (if (c/and (symbol? fst)
                                    (not (namespace fst))
                                    (not (fun fst)))
                           (if (*disallow-undefined* fst)
                             (do (debug fst &quot;RECURSIVE UNDEFINED DISALLOWED&quot;)
                                 `(throw* '~'void-function '~fst))
                             (do (debug fst &quot;NOT DEFINED&quot;)
                                 (list `delayed-eval x)))
                           (expand-dotted-lists (c/cons
                                                 (if (seq? fst) (el-&gt;clj fst) fst)
                                                 (map el-&gt;clj rst))))))))
            symbol? (if (namespace x)
                      (if (-&gt; (resolve x) meta :macro) (resolve x) x)
                      (if (#{'#el/sym &quot;\\,&quot; '#el/sym &quot;\\,@&quot; '.} x)
                        x
                        (list `el-var-get x)))
            x)
    (instance? IMeta x) (some-&gt; (with-meta (meta x)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^Throwable cause [^Throwable e]
  (if-let [e (.getCause e)]
    (recur e)
    e))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^Method clojure-syntax-quote
  (doto
      (.getDeclaredMethod clojure.lang.LispReader$SyntaxQuoteReader
                          &quot;syntaxQuote&quot;
                          (into-array [Object]))
    (.setAccessible true)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn syntax-quote* [form]
  (.invoke clojure-syntax-quote nil (into-array [form])))</pre></td></tr><tr><td class="docs"><p>Emacs Lisp allows an atom to be spliced if it is in the last position, like this:
(let ((upat 'x) (sym 'x))
  `(match ,sym ,@upat))
=> (match x . x)
Doesn't handle this wonderful case:
`,@2 => 2</p>
</td><td class="codes"><pre class="brush: clojure">(defn maybe-splice-dotted-list [x]
  (if ((some-fn seq? nil?) x) x `(. ~x)))</pre></td></tr><tr><td class="docs"><p>There's a version of this already defined as macro in backquote.el, use it / override it?
What's their relationship?</p>
</td><td class="codes"><pre class="brush: clojure">(defn emacs-lisp-backquote [form]
  (w/postwalk
   #(c/cond
      (c/and (seq? %) (seq? (last %)) (= `unquote-splicing (first (last %))))
      (if (butlast %)
        (concat (butlast %) `((unquote-splicing (maybe-splice-dotted-list ~(second (last %))))))
        (second (last %)))
      (c/and (seq? %) (= '#el/sym &quot;\\`&quot; (first %)))
      (el-&gt;clj (syntax-quote* (second %)))
      (= '#el/sym &quot;\\,&quot; %) `unquote
      (= '#el/sym &quot;\\,@&quot; %) `unquote-splicing
      :else %) form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn compile [emacs-lisp]
  (try
    (when emacs-lisp (c/eval (if (meta emacs-lisp) (with-meta emacs-lisp nil) emacs-lisp)))
    (catch ExceptionInfo e
      (throw e))
    (catch RuntimeException e
      (do
        (error (-&gt; e cause .getMessage) (with-out-str (pp/pprint emacs-lisp)))
        (throw e)))))</pre></td></tr><tr><td class="docs"><p>Defined in eval.clj</p>
</td><td class="codes"><pre class="brush: clojure">(defn eval [body &amp; [lexical]]
  (binding [*ns* (the-ns 'deuce.emacs)
            *compile-files* false]
    (with-bindings (if lexical {(global 'lexical-binding) true} {})
      (maybe-sym (compile (el-&gt;clj body))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parse-doc-string [[doc &amp; rst :as body]]
  (if (string? doc)
    [doc rst]
    [nil body]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn meta-walk [inner outer form]
  (cond-&gt; (w/walk inner outer form)
    (instance? IMeta form) (with-meta (meta form))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn normalize-form-for-macro
  ([form] (normalize-form-for-macro identity form))
  ([f form]
   (meta-walk (partial normalize-form-for-macro f) identity (f form))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn def-helper-process-var* [f needs-intern? name doc interactive emacs-lisp? el-arglist]
  (c/let [m (merge {:doc doc}
                   (when interactive {:interactive (second interactive)})
                   (when emacs-lisp?
                     {:el-arglist el-arglist
                      :el-file (when-let [file (el-var 'load-file-name)]
                                 @file)}))]
    (if (var? f)
      (do
        (alter-meta! f merge m)
        (alter-var-root f (constantly (with-meta @f (meta f))))
        (when needs-intern?
          (intern 'deuce.emacs (with-meta name (dissoc (meta f) :name)) @f)
          (ns-unmap 'deuce.emacs needs-intern?)))
      (with-meta f m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(c/defmacro def-helper* [what name arglist &amp; body]
  (c/let [[docstring body] (parse-doc-string body)
          name (sym name)
          el-arglist arglist
          rest-arg (maybe-sym (second (drop-while (complement '#{&amp;rest}) arglist)))
          [arg &amp; args :as arglist] (map sym (replace '{&amp;rest &amp;} arglist))
          [arglist &amp;optional optional-args] (if (= '&amp;optional arg)
                                              [() arg args]
                                              (partition-by '#{&amp;optional} arglist))
          arglist (concat arglist (when &amp;optional ['&amp; (vec optional-args)]))
          [[interactive] body] (split-with #(c/and (seq? %)
                                                   (= 'interactive (first %))) body)
          emacs-lisp? (= (the-ns 'deuce.emacs) *ns*)
          macro? (= `c/defmacro what)
          doc (apply str docstring)
          arglist (w/postwalk maybe-sym arglist)
          the-args (remove '#{&amp;} (flatten arglist))
          needs-intern? (when (c/and (re-find #&quot;/&quot; (c/name name)) (not= '/ name))
                          (sym (s/replace (c/name name) &quot;/&quot; &quot;SLASH&quot;)))
          not-implemented? (c/or (= [docstring] body) (empty? body))]
    `(def-helper-process-var*
       (~what ~(if needs-intern? needs-intern? name) ~(vec arglist)
              ~(when not-implemented?
                 `(binding [*ns* (the-ns 'clojure.core)]
                    (warn ~(c/name name) &quot;NOT IMPLEMENTED&quot;)))
              ~(if emacs-lisp?
                 `(c/let ~(if rest-arg
                            `[~rest-arg (if-let [r# ~rest-arg] (apply cons/list r#) nil)]
                            [])
                    (c/let [result# (with-local-el-vars ~(vec (mapcat #(c/list % %) the-args))
                                      (progn ~@body))]
                      ;; There's something wrong with the returned forms, hence the prewalk
                      (if ~macro?
                        (normalize-form-for-macro (el-&gt;clj result#))
                        result#)))
                 `(do ~@body)))
       '~needs-intern? '~name ~doc '~interactive '~emacs-lisp? '~el-arglist)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def override? '#{apply-partially})</pre></td></tr><tr><td class="docs"><p>Define NAME as a function.
  The definition is (lambda ARGLIST [DOCSTRING] BODY...).
  See also the function `interactive'.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro defun
  {:arglists '([NAME ARGLIST [DOCSTRING] BODY...])}
  [name arglist &amp; body]
  (c/let [name (sym name)]
    `(do ~(when-not (override? name)
            `(def-helper* defn ~name ~arglist ~@body))
         '~name)))</pre></td></tr><tr><td class="docs"><p>Return a lambda expression.
  A call of the form (lambda ARGS DOCSTRING INTERACTIVE BODY) is
  self-quoting; the result of evaluating the lambda expression is the
  expression itself.  The lambda expression may then be treated as a
  function, i.e., stored as the function value of a symbol, passed to
  <code>funcall' or</code>mapcar', etc.</p>

<p>  ARGS should take the same form as an argument list for a `defun'.
  DOCSTRING is an optional documentation string.
   If present, it should describe how to call the function.
   But documentation strings are usually not useful in nameless functions.
  INTERACTIVE should be a call to the function `interactive', which see.
  It may also be omitted.
  BODY should be a list of Lisp expressions.</p>

<p>Defined in subr.el</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro lambda
  {:arglists '([ARGS [DOCSTRING] [INTERACTIVE] BODY])}
  [&amp; cdr]
  (c/let [[args &amp; body] cdr
          [docstring _] (parse-doc-string body)
          doc (apply str docstring)
          vars (scope &amp;env)
          vars (vec (remove (c/set args) vars))]
    ;; This is wrong as it won't share updates between original definition and the lambda var.
    ;; Yet to see if this ends up being a real issue. A few days later: Indeed it is!
    `(c/let [closure# (zipmap '~vars
                              (map #(c/let [^Var v# (if (dynamic-binding?) ;; Temporary hack.
                                                      (if (var? %) % (Var/create %))
                                                      (Var/create (if (var? %) (deref %) %)))]
                                      (.setDynamic v#))
                                   ~vars))]
       (with-meta
         (def-helper* fn lambda ~args
           (binding [*dynamic-vars* (if (dynamic-binding?)
                                      (merge *dynamic-vars* closure#) {})]
             (c/let [{:syms ~vars} closure#]
               (progn ~@body)))) {:doc ~doc}))))</pre></td></tr><tr><td class="docs"><p>Return a function that is a partial application of FUN to ARGS.
  ARGS is a list of the first N arguments to pass to FUN.
  The result is a new function which does the same as FUN, except that
  the first N arguments are fixed at the values with which this function
  was called.</p>

<p>Defined in subr.el</p>
</td><td class="codes"><pre class="brush: clojure">(defn apply-partially
  [fun &amp; args]
  (fn partial [&amp; new-args]
    (apply (deuce.emacs-lisp/fun fun) (concat args new-args))))</pre></td></tr><tr><td class="docs"><p>Define a compiler-only macro.
  This is like `defmacro', but macro expansion occurs only if the call to
  FUNC is compiled (i.e., not interpreted).  Compiler macros should be used
  for optimizing the way calls to FUNC are compiled; the form returned by
  BODY should do the same thing as a call to the normal function called
  FUNC, though possibly more efficiently.  Note that, like regular macros,
  compiler macros are expanded repeatedly until no further expansions are
  possible.  Unlike regular macros, BODY can decide to "punt" and leave the
  original function call alone by declaring an initial `&amp;whole foo' parameter
  and then returning foo.</p>

<p>Defined in cl-macs.el. Optimizes existing fns which complicates things a lot.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro define-compiler-macro
  {:arglists '([FUNC ARGS &amp;rest BODY])}
  [func args &amp; body])</pre></td></tr><tr><td class="docs"><p>Do BODYFORM, protecting with UNWINDFORMS.
  If BODYFORM completes normally, its value is returned
  after executing the UNWINDFORMS.
  If BODYFORM exits nonlocally, the UNWINDFORMS are executed anyway.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro unwind-protect
  {:arglists '([BODYFORM UNWINDFORMS...])}
  [bodyform &amp; unwindforms]
  `(try
     ~(el-&gt;clj bodyform)
     (finally (progn ~@unwindforms))))</pre></td></tr><tr><td class="docs"><p>Regain control when an error is signaled.
  Executes BODYFORM and returns its value if no error happens.
  Each element of HANDLERS looks like (CONDITION-NAME BODY...)
  where the BODY is made of Lisp expressions.</p>

<p>  A handler is applicable to an error
  if CONDITION-NAME is one of the error's condition names.
  If an error happens, the first applicable handler is run.</p>

<p>  The car of a handler may be a list of condition names instead of a
  single condition name; then it handles all of them.  If the special
  condition name `debug' is present in this list, it allows another
  condition in the list to run the debugger if `debug-on-error' and the
  other usual mechanisms says it should (otherwise, `condition-case'
  suppresses the debugger).</p>

<p>  When a handler handles an error, control returns to the `condition-case'
  and it executes the handler's BODY...
  with VAR bound to (ERROR-SYMBOL . SIGNAL-DATA) from the error.
  (If VAR is nil, the handler can't access that information.)
  Then the value of the last BODY form is returned from the `condition-case'
  expression.</p>

<p>  See also the function `signal' for more info.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro condition-case
  {:arglists '([VAR BODYFORM &amp;rest HANDLERS])}
  [var bodyform &amp; handlers]
  (c/let [var (if (= () var) nil var)]
    `(try
       ~(el-&gt;clj bodyform)
       (catch ExceptionInfo e#
         (c/let [~(if var var (gensym &quot;_&quot;)) (cons/pair (:tag (ex-data e#))
                                                       (:value (ex-data e#)))]
           (case (:tag (ex-data e#))
             ~@(apply concat (for [[c &amp; h] handlers
                                   :let [c (if (seq? c) c [c])]]
                               (apply concat (for [c c] `[~(sym c) (progn ~@h)]))))
             (throw e#)))))))</pre></td></tr><tr><td class="docs"><p>Try each clause until one succeeds.
  Each clause looks like (CONDITION BODY...).  CONDITION is evaluated
  and, if the value is non-nil, this clause succeeds:
  then the expressions in BODY are evaluated and the last one's
  value is the value of the cond-form.
  If no clause succeeds, cond returns nil.
  If a clause has one element, as in (CONDITION),
  CONDITION's value if non-nil is returned from the cond-form.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro cond
  {:arglists '([CLAUSES...])}
  [&amp; clauses]
  `(c/cond
     ~@(-&gt;&gt; clauses
            (map #(do [`(not-null? ~(el-&gt;clj (first %)))
                       (if (= 1 (count %)) (el-&gt;clj (first %)) `(progn ~@(rest %)))]))
            (apply concat))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(c/defmacro setq-helper* [default? sym-vals]
  (c/let [emacs-lisp? (= (the-ns 'deuce.emacs) *ns*)]
    `(c/let
         ~(reduce into []
                  (for [[s v] (partition 2 2 nil sym-vals)
                        :let [s (sym s)]]
                    [(sym s) (if default?
                               `(el-var-set-default ~s ~(if emacs-lisp? (el-&gt;clj v) v))
                               `(el-var-set ~s ~(if emacs-lisp? (el-&gt;clj v) v)))]))
       ~(first (last (partition 2 2 nil sym-vals))))))</pre></td></tr><tr><td class="docs"><p>Set each SYM to the value of its VAL.
  The symbols SYM are variables; they are literal (not evaluated).
  The values VAL are expressions; they are evaluated.
  Thus, (setq x (1+ y)) sets <code>x' to the value of</code>(1+ y)'.
  The second VAL is not computed until after the first SYM is set, and so on;
  each VAL can use the new value of variables set earlier in the `setq'.
  The return value of the `setq' form is the value of the last VAL.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro setq
  {:arglists '([[SYM VAL]...])}
  [&amp; sym-vals]
  `(setq-helper* false ~sym-vals))</pre></td></tr><tr><td class="docs"><p>Return the argument, without evaluating it.  <code>(quote x)' yields</code>x'.
  Warning: `quote' does not construct its return value, but just returns
  the value that was pre-constructed by the Lisp reader (see info node
  `(elisp)Printed Representation').
  This means that '(a . b) is not identical to (cons 'a 'b): the former
  does not cons.  Quoting should be reserved for constants that will
  never be modified by side-effects, unless you like self-modifying code.
  See the common pitfall in info node `(elisp)Rearrangement' for an example
  of unexpected results when a quoted object is modified.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro ^:clojure-special-form quote
  {:arglists '([ARG])}
  [arg]
  `(quote ~arg))</pre></td></tr><tr><td class="docs"><p>Revisit using Atoms, will make closure capture easier. We use the <em>dynamic-vars</em> var for dynamic scope anyway.
Bindings refering to other bindings and modifying them don't work properly.
The vars must be created here instead of in with-local-el-vars (which might be removed).
Everytime you make a 'sane' assumption you're bound to find some Emacs Lisp breaking it:
(let* ((x 2) (y (setq x 4))) (+ x y)) => 8
Also: Needs to support delayed-eval referring to earlier bindings on rhs. (currently requires the binding to be in &amp;env).
Need to deal with dots in symbols here. desktop.el has things like (let ((q.txt "something..")))</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro let-helper* [can-refer? varlist &amp; body]
  (c/let [varlist (map #(if (symbol? %) [% nil] %) varlist)
          illegal-symbols (into {} (map #(c/let [v (name (first %))]
                                           (when (re-find #&quot;\.&quot; v)
                                             [(first %)
                                              (sym (s/replace v &quot;.&quot; &quot;_dot_&quot;))]))
                                        varlist))
          all-vars (map (comp sym first) (w/postwalk-replace illegal-symbols varlist))
          temps (zipmap all-vars (repeatedly #(gensym &quot;local__&quot;)))]
    `(c/let ~(vec (concat
                   (interleave (map (if can-refer? identity temps) all-vars)
                               (map (comp el-&gt;clj second) varlist))
                   (when-not can-refer? (interleave all-vars (map temps all-vars)))))
       (with-local-el-vars ~(interleave all-vars all-vars)
         (progn ~@(if (seq illegal-symbols) (w/postwalk-replace illegal-symbols body) body))))))</pre></td></tr><tr><td class="docs"><p>Bind variables according to VARLIST then eval BODY.
  The value of the last form in BODY is returned.
  Each element of VARLIST is a symbol (which is bound to nil)
  or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).
  All the VALUEFORMs are evalled before any symbols are bound.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro let
  {:arglists '([VARLIST BODY...])}
  [varlist &amp; body]
  `(let-helper* false ~varlist ~@body))</pre></td></tr><tr><td class="docs"><p>Define SYMBOL as a constant variable.
  This declares that neither programs nor users should ever change the
  value.  This constancy is not actually enforced by Emacs Lisp, but
  SYMBOL is marked as a special variable so that it is never lexically
  bound.</p>

<p>  The `defconst' form always sets the value of SYMBOL to the result of
  evalling INITVALUE.  If SYMBOL is buffer-local, its default value is
  what is set; buffer-local values are not affected.  If SYMBOL has a
  local binding, then this form sets the local binding's value.
  However, you should normally not make local bindings for variables
  defined with this form.</p>

<p>  The optional DOCSTRING specifies the variable's documentation string.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro defconst
  {:arglists '([SYMBOL INITVALUE [DOCSTRING]])}
  [symbol initvalue &amp; [docstring]]
  (c/let [symbol (sym symbol)]
    `(do
       (-&gt; (intern (create-ns 'deuce.emacs-lisp.globals)
                   '~symbol
                   ~(el-&gt;clj initvalue))
           (alter-meta! merge {:doc ~(apply str docstring)}))
       '~symbol)))</pre></td></tr><tr><td class="docs"><p>Eval FIRST and BODY sequentially; return value from FIRST.
  The value of FIRST is saved during the evaluation of the remaining args,
  whose values are discarded.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro prog1
  {:arglists '([FIRST BODY...])}
  [first &amp; body]
  `(c/let [result# ~(el-&gt;clj first)]
     (progn ~@body)
     result#))</pre></td></tr><tr><td class="docs"><p>Eval FORM1, FORM2 and BODY sequentially; return value from FORM2.
  The value of FORM2 is saved during the evaluation of the
  remaining args, whose values are discarded.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro prog2
  {:arglists '([FORM1 FORM2 BODY...])}
  [form1 form2 &amp; body]
  `(progn ~form1
          (prog1 ~form2
                 ~@body)))</pre></td></tr><tr><td class="docs"><p>Set the default value of variable VAR to VALUE.
  VAR, the variable name, is literal (not evaluated);
  VALUE is an expression: it is evaluated and its value returned.
  The default value of a variable is seen in buffers
  that do not have their own values for the variable.</p>

<p>  More generally, you can use multiple variables and values, as in
    (setq-default VAR VALUE VAR VALUE...)
  This sets each VAR's default value to the corresponding VALUE.
  The VALUE for the Nth VAR can refer to the new default values
  of previous VARs.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro setq-default
  {:arglists '([[VAR VALUE]...])}
  [&amp; var-values]
  `(setq-helper* true ~var-values))</pre></td></tr><tr><td class="docs"><p>Eval args until one of them yields non-nil, then return that value.
  The remaining args are not evalled at all.
  If all args return nil, return nil.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro or
  {:arglists '([CONDITIONS...])}
  [&amp; conditions]
  `(c/or ~@(map #(do `(not-null? ~(el-&gt;clj %))) conditions)))</pre></td></tr><tr><td class="docs"><p>If TEST yields non-nil, eval BODY... and repeat.
  The order of execution is thus TEST, BODY, TEST, BODY and so on
  until TEST returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro while
  {:arglists '([TEST BODY...])}
  [test &amp; body]
  `(c/while (not-null? ~(el-&gt;clj test)) (progn ~@body)))</pre></td></tr><tr><td class="docs"><p>Define NAME as a macro.
  The actual definition looks like
   (macro lambda ARGLIST [DOCSTRING] [DECL] BODY...).
  When the macro is called, as in (NAME ARGS...),
  the function (lambda ARGLIST BODY...) is applied to
  the list ARGS... as it appears in the expression,
  and the result should be a form to be evaluated instead of the original.</p>

<p>  DECL is a declaration, optional, which can specify how to indent
  calls to this macro, how Edebug should handle it, and which argument
  should be treated as documentation.  It looks like this:
    (declare SPECS...)
  The elements can look like this:
    (indent INDENT)
    Set NAME's `lisp-indent-function' property to INDENT.</p>

<pre><code>(debug DEBUG)
Set NAME's `edebug-form-spec' property to DEBUG.  (This is
equivalent to writing a `def-edebug-spec' for the macro.)

(doc-string ELT)
Set NAME's `doc-string-elt' property to ELT.
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro defmacro
  {:arglists '([NAME ARGLIST [DOCSTRING] [DECL] BODY...])}
  [name arglist &amp; body]
  (c/let [name (sym name)]
    `(do
       ~(when-not ((ns-interns 'deuce.emacs-lisp) name)
          `(def-helper* c/defmacro ~name ~arglist ~@body))
       '~name)))</pre></td></tr><tr><td class="docs"><p>Like `quote', but preferred for objects which are functions.
  In byte compilation, `function' causes its argument to be compiled.
  `quote' cannot do that.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro function
  {:arglists '([ARG])}
  [arg]
  (if (c/and (seq? arg) (symbol? (first arg)) (= 'lambda (sym (first arg))))
    (el-&gt;clj arg)
    `(quote ~arg)))</pre></td></tr><tr><td class="docs"><p>Eval args until one of them yields nil, then return nil.
  The remaining args are not evalled at all.
  If no arg yields nil, return the last arg's value.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro and
  {:arglists '([CONDITIONS...])}
  [&amp; conditions]
  `(c/and ~@(map #(do `(not-null? ~(el-&gt;clj %))) conditions)))</pre></td></tr><tr><td class="docs"><p>Eval BODY forms sequentially and return value of last one.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro progn
  {:arglists '([BODY...])}
  [&amp; body]
  `(do ~@(map el-&gt;clj body)))</pre></td></tr><tr><td class="docs"><p>Bind variables according to VARLIST then eval BODY.
  The value of the last form in BODY is returned.
  Each element of VARLIST is a symbol (which is bound to nil)
  or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).
  Each VALUEFORM can refer to the symbols already bound by this VARLIST.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro ^:clojure-special-form let*
  {:arglists '([VARLIST BODY...])}
  [varlist &amp; body]
  `(let-helper* true ~varlist ~@body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn defvar-helper* [ns symbol &amp; [initvalue docstring]]
  (c/let [symbol (sym symbol)
          ^Var default (global symbol)
          m (meta default)]
    (-&gt;
     ^Var (intern (create-ns ns)
                  symbol
                  (c/or (when default
                          (.getRawRoot default))
                        initvalue))
     .setDynamic
     (alter-meta! merge (merge m {:doc (apply str docstring)})))
    symbol))</pre></td></tr><tr><td class="docs"><p>Define SYMBOL as a variable, and return SYMBOL.
  You are not required to define a variable in order to use it, but
  defining it lets you supply an initial value and documentation, which
  can be referred to by the Emacs help facilities and other programming
  tools.  The `defvar' form also declares the variable as "special",
  so that it is always dynamically bound even if `lexical-binding' is t.</p>

<p>  The optional argument INITVALUE is evaluated, and used to set SYMBOL,
  only if SYMBOL's value is void.  If SYMBOL is buffer-local, its
  default value is what is set; buffer-local values are not affected.
  If INITVALUE is missing, SYMBOL's value is not set.</p>

<p>  If SYMBOL has a local binding, then this form affects the local
  binding.  This is usually not what you want.  Thus, if you need to
  load a file defining variables, with this form or with `defconst' or
  `defcustom', you should always load that file <em>outside</em> any bindings
  for these variables.  (<code>defconst' and</code>defcustom' behave similarly in
  this respect.)</p>

<p>  The optional argument DOCSTRING is a documentation string for the
  variable.</p>

<p>  To define a user option, use <code>defcustom' instead of</code>defvar'.
  The function `user-variable-p' also identifies a variable as a user
  option if its DOCSTRING starts with *, but this behavior is obsolete.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro defvar
  {:arglists '([SYMBOL &amp;optional INITVALUE DOCSTRING])}
  [symbol &amp; [initvalue docstring]]
  (c/let [emacs-lisp? (= (the-ns 'deuce.emacs) *ns*)]
    `(defvar-helper* 'deuce.emacs-lisp.globals '~(sym symbol)
       ~(if emacs-lisp? (el-&gt;clj initvalue) initvalue) ~docstring)))</pre></td></tr><tr><td class="docs"><p>Throw to the catch for TAG and return VALUE from it.
  Both TAG and VALUE are evalled.</p>

<p>defined as fn in eval.clj</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro ^:clojure-special-form throw
  {:arglists '([TAG VALUE])}
  [tag value]
  `(throw* ~tag ~value))</pre></td></tr><tr><td class="docs"><p>Eval BODY allowing nonlocal exits using `throw'.
  TAG is evalled to get the tag to use; it must not be nil.</p>

<p>  Then the BODY is executed.
  Within BODY, a call to <code>throw' with the same TAG exits BODY and this</code>catch'.
  If no throw happens, `catch' returns the value of the last BODY form.
  If a throw happens, it specifies the value to return from `catch'.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro ^:clojure-special-form catch
  {:arglists '([TAG BODY...])}
  [tag &amp; body]
  `(try
     (progn ~@body)
     (catch ExceptionInfo e#
       (if (= ~(el-&gt;clj tag) (:tag (ex-data e#)))
         (:value (ex-data e#))
         (throw e#)))
     (catch Exception e#
       (c/let [tag# (resolve ~tag)]
         (if (c/and tag# (instance? tag# (cause e#)))
           e#
           (throw e#))))))</pre></td></tr><tr><td class="docs"><p>If COND yields non-nil, do THEN, else do ELSE...
  Returns the value of THEN or the value of the last of the ELSE's.
  THEN must be one expression, but ELSE... can be zero or more expressions.
  If COND yields nil, and there are no ELSE's, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro ^:clojure-special-form if
  {:arglists '([COND THEN ELSE...])}
  [cond then &amp; else]
  `(c/cond (not-null? ~(el-&gt;clj cond)) ~(el-&gt;clj then)
           :else (progn ~@else)))</pre></td></tr><tr><td class="docs"><p>Execute BODY, saving and restoring current buffer's restrictions.
  The buffer's restrictions make parts of the beginning and end invisible.
  (They are set up with <code>narrow-to-region' and eliminated with</code>widen'.)
  This special form, `save-restriction', saves the current buffer's restrictions
  when it is entered, and restores them when it is exited.
  So any `narrow-to-region' within BODY lasts only until the end of the form.
  The old restrictions settings are restored
  even in case of abnormal exit (throw or error).</p>

<p>  The value returned is the value of the last form in BODY.</p>

<p>  Note: if you are using both <code>save-excursion' and</code>save-restriction',
  use `save-excursion' outermost:
      (save-excursion (save-restriction ...))</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro save-restriction
  {:arglists '([&amp;rest BODY])}
  [&amp; body]
  `(c/let [current-buffer# ~(with-meta `((fun 'current-buffer)) {:tag 'deuce.emacs.data.Buffer})
           begv# @(.begv current-buffer#)
           zv# @(.zv current-buffer#)]
     (try
       (progn ~@body)
       (finally
         ((fun 'narrow-to-region) begv# zv#)))))</pre></td></tr><tr><td class="docs"><p>Save point, mark, and current buffer; execute BODY; restore those things.
  Executes BODY just like `progn'.
  The values of point, mark and the current buffer are restored
  even in case of abnormal exit (throw or error).
  The state of activation of the mark is also restored.</p>

<p>  This construct does not save `deactivate-mark', and therefore
  functions that change the buffer will still cause deactivation
  of the mark at the end of the command.  To prevent that, bind
  <code>deactivate-mark' with</code>let'.</p>

<p>  If you only want to save the current buffer but not point nor mark,
  then just use <code>save-current-buffer', or even</code>with-current-buffer'.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro save-excursion
  [&amp; body]
  `(c/let [current-buffer# ((fun 'current-buffer))
           point# ((fun 'point))
           mark# ((fun 'mark-marker))]
     (try
       (progn ~@body)
       (finally
         ((fun 'set-buffer) current-buffer#)
         ((fun 'goto-char) point#)
         ((fun 'set-marker) mark# ((fun 'marker-position) mark#) current-buffer#)))))</pre></td></tr><tr><td class="docs"><p>Specify a way of parsing arguments for interactive use of a function.
  For example, write
   (defun foo (arg buf) "Doc string" (interactive "P\nbbuffer: ") .... )
   to make ARG be the raw prefix argument, and set BUF to an existing buffer,
   when `foo' is called as a command.
  The "call" to `interactive' is actually a declaration rather than a function;
   it tells `call-interactively' how to read arguments
   to pass to the function.
  When actually called, `interactive' just returns nil.</p>

<p>  Usually the argument of `interactive' is a string containing a code letter
   followed optionally by a prompt.  (Some code letters do not use I/O to get
   the argument and do not use prompts.)  To get several arguments, concatenate
   the individual strings, separating them by newline characters.
  Prompts are passed to format, and may use % escapes to print the
   arguments that have already been read.
  If the argument is not a string, it is evaluated to get a list of
   arguments to pass to the function.
  Just `(interactive)' means pass no args when calling interactively.</p>

<p>  Code letters available are:
  a -- Function name: symbol with a function definition.
  b -- Name of existing buffer.
  B -- Name of buffer, possibly nonexistent.
  c -- Character (no input method is used).
  C -- Command name: symbol with interactive function definition.
  d -- Value of point as number.  Does not do I/O.
  D -- Directory name.
  e -- Parameterized event (i.e., one that's a list) that invoked this command.
       If used more than once, the Nth `e' returns the Nth parameterized event.
       This skips events that are integers or symbols.
  f -- Existing file name.
  F -- Possibly nonexistent file name.
  G -- Possibly nonexistent file name, defaulting to just directory name.
  i -- Ignored, i.e. always nil.  Does not do I/O.
  k -- Key sequence (downcase the last event if needed to get a definition).
  K -- Key sequence to be redefined (do not downcase the last event).
  m -- Value of mark as number.  Does not do I/O.
  M -- Any string.  Inherits the current input method.
  n -- Number read using minibuffer.
  N -- Numeric prefix arg, or if none, do like code `n'.
  p -- Prefix arg converted to number.  Does not do I/O.
  P -- Prefix arg in raw form.  Does not do I/O.
  r -- Region: point and mark as 2 numeric args, smallest first.  Does no I/O.
  s -- Any string.  Does not inherit the current input method.
  S -- Any symbol.
  U -- Mouse up event discarded by a previous k or K argument.
  v -- Variable name: symbol that is user-variable-p.
  x -- Lisp expression read but not evaluated.
  X -- Lisp expression read and evaluated.
  z -- Coding system.
  Z -- Coding system, nil if no prefix arg.</p>

<p>  In addition, if the string begins with `*', an error is signaled if
    the buffer is read-only.
  If `@' appears at the beginning of the string, and if the key sequence
   used to invoke the command includes any mouse events, then the window
   associated with the first of those events is selected before the
   command is run.
  If the string begins with <code>^' and</code>shift-select-mode' is non-nil,
   Emacs first calls the function `handle-shift-selection'.
  You may use <code>@',</code>*', and `^' together.  They are processed in the
   order that they appear, before reading any arguments.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro interactive
  &quot;Specify a way of parsing arguments for interactive use of a function.
  For example, write
   (defun foo (arg buf) \&quot;Doc string\&quot; (interactive \&quot;P\\nbbuffer: \&quot;) .... )
   to make ARG be the raw prefix argument, and set BUF to an existing buffer,
   when `foo' is called as a command.
  The \&quot;call\&quot; to `interactive' is actually a declaration rather than a function;
   it tells `call-interactively' how to read arguments
   to pass to the function.
  When actually called, `interactive' just returns nil.
  Usually the argument of `interactive' is a string containing a code letter
   followed optionally by a prompt.  (Some code letters do not use I/O to get
   the argument and do not use prompts.)  To get several arguments, concatenate
   the individual strings, separating them by newline characters.
  Prompts are passed to format, and may use % escapes to print the
   arguments that have already been read.
  If the argument is not a string, it is evaluated to get a list of
   arguments to pass to the function.
  Just `(interactive)' means pass no args when calling interactively.
  Code letters available are:
  a -- Function name: symbol with a function definition.
  b -- Name of existing buffer.
  B -- Name of buffer, possibly nonexistent.
  c -- Character (no input method is used).
  C -- Command name: symbol with interactive function definition.
  d -- Value of point as number.  Does not do I/O.
  D -- Directory name.
  e -- Parameterized event (i.e., one that's a list) that invoked this command.
       If used more than once, the Nth `e' returns the Nth parameterized event.
       This skips events that are integers or symbols.
  f -- Existing file name.
  F -- Possibly nonexistent file name.
  G -- Possibly nonexistent file name, defaulting to just directory name.
  i -- Ignored, i.e. always nil.  Does not do I/O.
  k -- Key sequence (downcase the last event if needed to get a definition).
  K -- Key sequence to be redefined (do not downcase the last event).
  m -- Value of mark as number.  Does not do I/O.
  M -- Any string.  Inherits the current input method.
  n -- Number read using minibuffer.
  N -- Numeric prefix arg, or if none, do like code `n'.
  p -- Prefix arg converted to number.  Does not do I/O.
  P -- Prefix arg in raw form.  Does not do I/O.
  r -- Region: point and mark as 2 numeric args, smallest first.  Does no I/O.
  s -- Any string.  Does not inherit the current input method.
  S -- Any symbol.
  U -- Mouse up event discarded by a previous k or K argument.
  v -- Variable name: symbol that is user-variable-p.
  x -- Lisp expression read but not evaluated.
  X -- Lisp expression read and evaluated.
  z -- Coding system.
  Z -- Coding system, nil if no prefix arg.
  In addition, if the string begins with `*', an error is signaled if
    the buffer is read-only.
  If `@' appears at the beginning of the string, and if the key sequence
   used to invoke the command includes any mouse events, then the window
   associated with the first of those events is selected before the
   command is run.
  If the string begins with `^' and `shift-select-mode' is non-nil,
   Emacs first calls the function `handle-shift-selection'.
  You may use `@', `*', and `^' together.  They are processed in the
   order that they appear, before reading any arguments.&quot;
  {:arglists '([&amp;optional ARGS])}
  [&amp; args])</pre></td></tr><tr><td class="docs"><p>Save the current buffer; execute BODY; restore the current buffer.
  Executes BODY just like `progn'.</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro save-current-buffer
  {:arglists '([&amp;rest BODY])}
  [&amp; body]
  `(c/let [current-buffer# ((fun 'current-buffer))]
     (try
       (progn ~@body)
       (finally
         ((fun 'set-buffer) current-buffer#)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def clojure-special-forms
  (-&gt;&gt; (ns-map 'deuce.emacs-lisp)
       (filter (comp :clojure-special-form meta val))
       (into {})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn check-type [pred x]
  (if ((fun pred) x)
    x
    (deuce.emacs-lisp/throw 'wrong-type-argument (cons/list pred x))))</pre></td></tr><tr><td class="docs"><p>Navgeet's helper macro, will revisit, basically condition-case but for use from Clojure</p>
</td><td class="codes"><pre class="brush: clojure">(c/defmacro try-with-tag [&amp; exprs]
  (c/let [catch-clauses (c/filter #(c/= (first %) 'catch) exprs)
          finally-clause (c/filter #(c/= (first %) 'finally) exprs)
          try-exprs (c/remove #(c/or (c/= (first %) 'finally) (c/= (first %) 'catch)) exprs)]
    `(try ~@try-exprs
          ~@(for [expr catch-clauses]
              (c/let [[_ tag e &amp; exprs] expr]
                `(catch ExceptionInfo e#
                   (if (= ~tag (:tag (ex-data e#)))
                     (c/let [~e e#]
                       (do ~@exprs))
                     (throw e#)))))
          ~@finally-clause)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.keyboard" name="deuce.emacs.keyboard"><h1 class="project-name">deuce.emacs.keyboard</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.keyboard
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [clojure.java.shell :as sh]
            [lanterna.common]
            [deuce.emacs.callint :as callint]
            [deuce.emacs.casefiddle :as casefiddle]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns]
            [deuce.emacs.macros :as macros]
            [deuce.emacs.term :as term]
            [deuce.emacs.terminal :as terminal]
            [deuce.emacs-lisp.parser :as parser])
  (:import [sun.misc Signal SignalHandler]
           [com.googlecode.lanterna.terminal Terminal])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Last input event that was part of a command.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar last-command-event nil)</pre></td></tr><tr><td class="docs"><p>If not -1, an object to be read as next command input event.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar unread-command-char nil)</pre></td></tr><tr><td class="docs"><p>Function to call to handle deferred actions, after each command.
  This function is called with no arguments after each command
  whenever `deferred-action-list' is non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar deferred-action-function nil)</pre></td></tr><tr><td class="docs"><p>Last input event.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar last-input-event nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means menu bar, specified Lucid style, needs to be recomputed.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar lucid-menu-bar-dirty-flag nil)</pre></td></tr><tr><td class="docs"><p>Number of input events between auto-saves.
  Zero means disable autosaving due to number of characters typed.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-save-interval nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means generate motion events for mouse motion.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar track-mouse nil)</pre></td></tr><tr><td class="docs"><p>Non-nil if the key sequence activating this command was shift-translated.
  Shift-translation occurs when there is no binding for the key sequence
  as entered, but a binding was found by changing an upper-case letter
  to lower-case, or a shifted function key to an unshifted one.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar this-command-keys-shift-translated nil)</pre></td></tr><tr><td class="docs"><p>Normal hook run before each command is executed.
  If an unhandled error happens in running this hook,
  the function in which the error occurred is unconditionally removed, since
  otherwise the error might happen repeatedly and make Emacs nonfunctional.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar pre-command-hook nil)</pre></td></tr><tr><td class="docs"><p>Keymap that translates key sequences to key sequences during input.
  This is used mainly for mapping key sequences into some preferred
  key events (symbols).</p>

<p>  The `read-key-sequence' function replaces any subsequence bound by
  `local-function-key-map' with its binding.  More precisely, when the
  active keymaps have no binding for the current key sequence but
  `local-function-key-map' binds a suffix of the sequence to a vector or
  string, `read-key-sequence' replaces the matching suffix with its
  binding, and continues with the new sequence.</p>

<p>  If the binding is a function, it is called with one argument (the prompt)
  and its return value (a key sequence) is used.</p>

<p>  The events that come from bindings in `local-function-key-map' are not
  themselves looked up in `local-function-key-map'.</p>

<p>  For example, suppose <code>local-function-key-map' binds</code>ESC O P' to [f1].
  Typing <code>ESC O P' to</code>read-key-sequence' would return [f1].  Typing
  `C-x ESC O P' would return [?\C-x f1].  If [f1] were a prefix key,
  typing `ESC O P x' would return [f1 x].</p>

<p>  `local-function-key-map' has a separate binding for each terminal
  device.  See Info node `(elisp)Multiple Terminals'.  If you need to
  define a binding on all terminals, change `function-key-map'
  instead.  Initially, `local-function-key-map' is an empty keymap that
  has `function-key-map' as its parent on all terminal devices.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar local-function-key-map nil
  &quot;Keymap that translates key sequences to key sequences during input.
  This is used mainly for mapping key sequences into some preferred
  key events (symbols).
  The `read-key-sequence' function replaces any subsequence bound by
  `local-function-key-map' with its binding.  More precisely, when the
  active keymaps have no binding for the current key sequence but
  `local-function-key-map' binds a suffix of the sequence to a vector or
  string, `read-key-sequence' replaces the matching suffix with its
  binding, and continues with the new sequence.
  If the binding is a function, it is called with one argument (the prompt)
  and its return value (a key sequence) is used.
  The events that come from bindings in `local-function-key-map' are not
  themselves looked up in `local-function-key-map'.
  For example, suppose `local-function-key-map' binds `ESC O P' to [f1].
  Typing `ESC O P' to `read-key-sequence' would return [f1].  Typing
  `C-x ESC O P' would return [?\\C-x f1].  If [f1] were a prefix key,
  typing `ESC O P x' would return [f1 x].
  `local-function-key-map' has a separate binding for each terminal
  device.  See Info node `(elisp)Multiple Terminals'.  If you need to
  define a binding on all terminals, change `function-key-map'
  instead.  Initially, `local-function-key-map' is an empty keymap that
  has `function-key-map' as its parent on all terminal devices.&quot;)</pre></td></tr><tr><td class="docs"><p>List of active absolute time timers in order of increasing time.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar timer-list nil)</pre></td></tr><tr><td class="docs"><p>The ERASE character as set by the user with stty.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar tty-erase-char nil)</pre></td></tr><tr><td class="docs"><p>Command to run when `help-char' character follows a prefix key.
  This command is used only when there is no actual binding
  for that character after that prefix key.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar prefix-help-command nil)</pre></td></tr><tr><td class="docs"><p>When `input-method-function' is called, hold the previous echo area message.
  This variable exists because `read-event' clears the echo area
  before running the input method.  It is nil if there was no message.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar input-method-previous-message nil)</pre></td></tr><tr><td class="docs"><p>List of input events to recognize as meaning Help.
  These work just like the value of `help-char' (see that).</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar help-event-list nil)</pre></td></tr><tr><td class="docs"><p>Maximum mouse movement between clicks to make a double-click.
  On window-system frames, value is the number of pixels the mouse may have
  moved horizontally or vertically between two clicks to make a double-click.
  On non window-system frames, value is interpreted in units of 1/8 characters
  instead of pixels.</p>

<p>  This variable is also the threshold for motion of the mouse
  to count as a drag.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar double-click-fuzz nil)</pre></td></tr><tr><td class="docs"><p>Alist of system-specific X windows key symbols.
  Each element should have the form (N . SYMBOL) where N is the
  numeric keysym code (sans the "system-specific" bit 1&lt;&lt;28)
  and SYMBOL is its name.</p>

<p>  `system-key-alist' has a separate binding for each terminal device.
  See Info node `(elisp)Multiple Terminals'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar system-key-alist nil)</pre></td></tr><tr><td class="docs"><p>List of events to be processed as input by input methods.
  These events are processed after `unread-command-events', but
  before actual keyboard input.
  If there's an active input method, the events are given to
  `input-method-function'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar unread-input-method-events nil)</pre></td></tr><tr><td class="docs"><p>Nonzero means echo unfinished commands after this many seconds of pause.
  The value may be integer or floating point.
  If the value is zero, don't echo at all.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar echo-keystrokes 1)</pre></td></tr><tr><td class="docs"><p>List of events to be processed as input by input methods.
  These events are processed before `unread-command-events'
  and actual keyboard input, but are not given to `input-method-function'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar unread-post-input-method-events nil)</pre></td></tr><tr><td class="docs"><p>A mask of additional modifier keys to use with every keyboard character.
  Emacs applies the modifiers of the character stored here to each keyboard
  character it reads.  For example, after evaluating the expression
      (setq extra-keyboard-modifiers ?\C-x)
  all input characters will have the control modifier applied to them.</p>

<p>  Note that the character ?\C-@, equivalent to the integer zero, does
  not count as a control character; rather, it counts as a character
  with no modifiers; thus, setting `extra-keyboard-modifiers' to zero
  cancels any modification.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar extra-keyboard-modifiers nil
  &quot;A mask of additional modifier keys to use with every keyboard character.
  Emacs applies the modifiers of the character stored here to each keyboard
  character it reads.  For example, after evaluating the expression
      (setq extra-keyboard-modifiers ?\\C-x)
  all input characters will have the control modifier applied to them.
  Note that the character ?\\C-@, equivalent to the integer zero, does
  not count as a control character; rather, it counts as a character
  with no modifiers; thus, setting `extra-keyboard-modifiers' to zero
  cancels any modification.&quot;)</pre></td></tr><tr><td class="docs"><p>Non-nil means to always spawn a subshell instead of suspending.
  (Even if the operating system has support for stopping a process.)</p>
</td><td class="codes"><pre class="brush: clojure">(defvar cannot-suspend nil)</pre></td></tr><tr><td class="docs"><p>Normal hook run after each command is executed.
  If an unhandled error happens in running this hook,
  the function in which the error occurred is unconditionally removed, since
  otherwise the error might happen repeatedly and make Emacs nonfunctional.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar post-command-hook nil)</pre></td></tr><tr><td class="docs"><p>How long to display an echo-area message when the minibuffer is active.
  If the value is not a number, such messages don't time out.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-message-timeout 2)</pre></td></tr><tr><td class="docs"><p>If non-nil, don't ignore events produced by disabled menu items and tool-bar.</p>

<p>  Help functions bind this to allow help on disabled menu items
  and tool-bar buttons.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar enable-disabled-menus-and-buttons nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, the function that implements the current input method.
  It's called with one argument, a printing character that was just read.
  (That means a character with code 040...0176.)
  Typically this function uses `read-event' to read additional events.
  When it does so, it should first bind `input-method-function' to nil
  so it will not be called recursively.</p>

<p>  The function should return a list of zero or more events
  to be used as input.  If it wants to put back some events
  to be reconsidered, separately, by the input method,
  it can add them to the beginning of `unread-command-events'.</p>

<p>  The input method function can find in `input-method-previous-message'
  the previous echo area message.</p>

<p>  The input method function should refer to the variables
  <code>input-method-use-echo-area' and</code>input-method-exit-on-first-char'
  for guidance on what to do.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar input-method-function nil)</pre></td></tr><tr><td class="docs"><p>Per-terminal keymap that overrides all other local keymaps.
  If this variable is non-nil, it is used as a keymap instead of the
  buffer's local map, and the minor mode keymaps and text property keymaps.
  It also replaces `overriding-local-map'.</p>

<p>  This variable is intended to let commands such as `universal-argument'
  set up a different keymap for reading the next command.</p>

<p>  `overriding-terminal-local-map' has a separate binding for each
  terminal device.
  See Info node `(elisp)Multiple Terminals'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar overriding-terminal-local-map nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, the function that implements the display of help.
  It's called with one argument, the help string to display.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar show-help-function nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, an active region automatically sets the primary selection.
  If the value is `only', only temporarily active regions (usually made
  by mouse-dragging or shift-selection) set the window selection.</p>

<p>  This takes effect only when Transient Mark mode is enabled.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar select-active-regions nil)</pre></td></tr><tr><td class="docs"><p>The last command executed.
  Normally a symbol with a function definition, but can be whatever was found
  in the keymap, or whatever the variable `this-command' was set to by that
  command.</p>

<p>  The value `mode-exit' is special; it means that the previous command
  read an event that told it to exit, and it did so and unread that event.
  In other words, the present command is the event that made the previous
  command exit.</p>

<p>  The value `kill-region' is special; it means that the previous command
  was a kill command.</p>

<p>  `last-command' has a separate binding for each terminal device.
  See Info node `(elisp)Multiple Terminals'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar last-command nil)</pre></td></tr><tr><td class="docs"><p>Translate table for local keyboard input, or nil.
  If non-nil, the value should be a char-table.  Each character read
  from the keyboard is looked up in this char-table.  If the value found
  there is non-nil, then it is used instead of the actual input character.</p>

<p>  The value can also be a string or vector, but this is considered obsolete.
  If it is a string or vector of length N, character codes N and up are left
  untranslated.  In a vector, an element which is nil means "no translation".</p>

<p>  This is applied to the characters supplied to input methods, not their
  output.  See also `translation-table-for-input'.</p>

<p>  This variable has a separate binding for each terminal.
  See Info node `(elisp)Multiple Terminals'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar keyboard-translate-table nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means inhibit local map menu bar menus.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-local-menu-bar-menus nil)</pre></td></tr><tr><td class="docs"><p>List of warnings to be displayed after this command.
  Each element must be a list (TYPE MESSAGE [LEVEL [BUFFER-NAME]]),
  as per the args of `display-warning' (which see).
  If this variable is non-nil, `delayed-warnings-hook' will be run
  immediately after running `post-command-hook'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar delayed-warnings-list nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means `overriding-local-map' applies to the menu bar.
  Otherwise, the menu bar continues to reflect the buffer's local map
  and the minor mode maps regardless of `overriding-local-map'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar overriding-local-map-menu-flag nil)</pre></td></tr><tr><td class="docs"><p>The frame in which the most recently read event occurred.
  If the last event came from a keyboard macro, this is set to `macro'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar last-event-frame nil)</pre></td></tr><tr><td class="docs"><p>Last input event in a command, except for mouse menu events.
  Mouse menus give back keys that don't look like mouse events;
  this variable holds the actual mouse event that led to the menu,
  so that you can determine whether the command was run by mouse or not.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar last-nonmenu-event nil)</pre></td></tr><tr><td class="docs"><p>Keymap defining bindings for special events to execute at low level.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar special-event-map nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means prompt with menus when appropriate.
  This is done when reading from a keymap that has a prompt string,
  for elements that have prompt strings.
  The menu is displayed on the screen
  if X menus were enabled at configuration
  time and the previous event was a mouse click prefix key.
  Otherwise, menu prompting uses the echo area.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar menu-prompting true)</pre></td></tr><tr><td class="docs"><p>The parent keymap of all `local-function-key-map' instances.
  Function key definitions that apply to all terminal devices should go
  here.  If a mapping is defined in both the current
  `local-function-key-map' binding and this variable, then the local
  definition will take precedence.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar function-key-map nil)</pre></td></tr><tr><td class="docs"><p>Contents of active region prior to buffer modification.
  If `select-active-regions' is non-nil, Emacs sets this to the
  text in the region before modifying the buffer.  The next
  `deactivate-mark' call uses this to set the window selection.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar saved-region-selection nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, always suppress point adjustment.</p>

<p>  The default value is nil, in which case, point adjustment are
  suppressed only after special commands that set
  `disable-point-adjustment' (which see) to non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar global-disable-point-adjustment nil)</pre></td></tr><tr><td class="docs"><p>Interval between polling for input during Lisp execution.
  The reason for polling is to make C-g work to stop a running program.
  Polling is needed only when using X windows and SIGIO does not work.
  Polling is automatically disabled in all other cases.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar polling-period 2)</pre></td></tr><tr><td class="docs"><p>Keymap that overrides all other local keymaps.
  If this variable is non-nil, it is used as a keymap--replacing the
  buffer's local map, the minor mode keymaps, and char property keymaps.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar overriding-local-map nil)</pre></td></tr><tr><td class="docs"><p>Form to evaluate when Emacs starts up.
  Useful to set before you dump a modified Emacs.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar top-level nil)</pre></td></tr><tr><td class="docs"><p>Keymap that decodes input escape sequences.
  This is used mainly for mapping ASCII function key sequences into
  real Emacs function key events (symbols).</p>

<p>  The `read-key-sequence' function replaces any subsequence bound by
  <code>input-decode-map' with its binding.  Contrary to</code>function-key-map',
  this map applies its rebinding regardless of the presence of an ordinary
  binding.  So it is more like `key-translation-map' except that it applies
  before `function-key-map' rather than after.</p>

<p>  If the binding is a function, it is called with one argument (the prompt)
  and its return value (a key sequence) is used.</p>

<p>  The events that come from bindings in `input-decode-map' are not
  themselves looked up in `input-decode-map'.</p>

<p>  This variable is keyboard-local.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar input-decode-map nil)</pre></td></tr><tr><td class="docs"><p>Last command that may be repeated.
  The last command executed that was not bound to an input event.
  This is the command `repeat' will try to repeat.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar last-repeatable-command nil)</pre></td></tr><tr><td class="docs"><p>Number of input events read from the keyboard so far.
  This does not include events generated by keyboard macros.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar num-nonmacro-input-events nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, any keyboard input throws to this symbol.
  The value of that variable is passed to `quit-flag' and later causes a
  peculiar kind of quitting.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar throw-on-input nil)</pre></td></tr><tr><td class="docs"><p>Same as `last-command', but never altered by Lisp code.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar real-last-command nil)</pre></td></tr><tr><td class="docs"><p>Character to recognize as meaning Help.
  When it is read, do `(eval help-form)', and display result if it's a string.
  If the value of `help-form' is nil, this char can be read normally.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar help-char (int \backspace))</pre></td></tr><tr><td class="docs"><p>If non-nil, suppress point adjustment after executing a command.</p>

<p>  After a command is executed, if point is moved into a region that has
  special properties (e.g. composition, display), we adjust point to
  the boundary of the region.  But, when a command sets this variable to
  non-nil, we suppress the point adjustment.</p>

<p>  This variable is set to nil before reading a command, and is checked
  just after executing the command.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar disable-point-adjustment nil)</pre></td></tr><tr><td class="docs"><p>Enter debugger on this event.  When Emacs
  receives the special event specified by this variable, it will try to
  break into the debugger as soon as possible instead of processing the
  event normally through `special-event-map'.</p>

<p>  Currently, the only supported values for this
  variable are <code>sigusr1' and</code>sigusr2'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar debug-on-event nil)</pre></td></tr><tr><td class="docs"><p>List of deferred actions to be performed at a later time.
  The precise format isn't relevant here; we just check whether it is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar deferred-action-list nil)</pre></td></tr><tr><td class="docs"><p>Number of complete key sequences read as input so far.
  This includes key sequences read from keyboard macros.
  The number is effectively the number of interactive command invocations.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar num-input-keys nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, function to output error messages.
  The arguments are the error data, a list of the form
   (SIGNALED-CONDITIONS . SIGNAL-DATA)
  such as just as `condition-case' would bind its variable to,
  the context (a string which normally goes at the start of the message),
  and the Lisp function within which the error was signaled.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar command-error-function nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means show the equivalent key-binding when M-x command has one.
  The value can be a length of time to show the message for.
  If the value is non-nil and not a number, we wait 2 seconds.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar suggest-key-bindings true)</pre></td></tr><tr><td class="docs"><p>List of commands which should not update the selection.
  Normally, if `select-active-regions' is non-nil and the mark remains
  active after a command (i.e. the mark was not deactivated), the Emacs
  command loop sets the selection to the text in the region.  However,
  if the command is in this list, the selection is not updated.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar selection-inhibit-update-commands '(handle-switch-frame handle-select-window))</pre></td></tr><tr><td class="docs"><p>List of menu bar items to move to the end of the menu bar.
  The elements of the list are event types that may have menu bar bindings.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar menu-bar-final-items nil)</pre></td></tr><tr><td class="docs"><p>Expression evaluating to the image spec for a tool-bar separator.
  This is used internally by graphical displays that do not render
  tool-bar separators natively.  Otherwise it is unused (e.g. on GTK).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar tool-bar-separator-image-expression nil)</pre></td></tr><tr><td class="docs"><p>Maximum time between mouse clicks to make a double-click.
  Measured in milliseconds.  The value nil means disable double-click
  recognition; t means double-clicks have no time limit and are detected
  by position only.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar double-click-time 500)</pre></td></tr><tr><td class="docs"><p>Meta-prefix character code.
  Meta-foo as command input turns into this character followed by foo.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar meta-prefix-char (int \))</pre></td></tr><tr><td class="docs"><p>Number of seconds idle time before auto-save.
  Zero or nil means disable auto-saving due to idleness.
  After auto-saving due to this many seconds of idle time,
  Emacs also does a garbage collection if that seems to be warranted.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-save-timeout 30)</pre></td></tr><tr><td class="docs"><p>List of active idle-time timers in order of increasing time.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar timer-idle-list nil)</pre></td></tr><tr><td class="docs"><p>Normal hook run when clearing the echo area.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar echo-area-clear-hook nil)</pre></td></tr><tr><td class="docs"><p>The command now being executed.
  The command can set this variable; whatever is put here
  will be in `last-command' during the following command.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar this-command nil)</pre></td></tr><tr><td class="docs"><p>If an editing command sets this to t, deactivate the mark afterward.
  The command loop sets this to nil before each command,
  and tests the value when the command returns.
  Buffer modification stores t in this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar deactivate-mark nil)</pre></td></tr><tr><td class="docs"><p>Form to execute when character `help-char' is read.
  If the form returns a string, that string is displayed.
  If `help-form' is nil, the help char is not recognized.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar help-form nil)</pre></td></tr><tr><td class="docs"><p>List of events to be read as the command input.
  These events are processed first, before actual keyboard input.
  Events read from this list are not normally added to `this-command-keys',
  as they will already have been added once as they were read for the first time.
  An element of the form (t . EVENT) forces EVENT to be added to that list.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar unread-command-events nil)</pre></td></tr><tr><td class="docs"><p>Character to see next line of menu prompt.
  Type this character while in a menu prompt to rotate around the lines of it.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar menu-prompt-more-char (int \space))</pre></td></tr><tr><td class="docs"><p>The command bound to the current key sequence before remapping.
  It equals `this-command' if the original command was not remapped through
  any of the active keymaps.  Otherwise, the value of `this-command' is the
  result of looking up the original command in the active keymaps.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar this-original-command nil)</pre></td></tr><tr><td class="docs"><p>Keymap of key translations that can override keymaps.
  This keymap works like `function-key-map', but comes after that,
  and its non-prefix bindings override ordinary bindings.
  Another difference is that it is global rather than keyboard-local.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar key-translation-map nil)</pre></td></tr><tr><td class="docs"><p>DEUCE: For reference, this is the main low level read_char function in Emacs.
       We don't use nmaps (or most arguments yet).
       We use currentTimeMillis for internal times instead of Emacs style time.
       Maybe totally revamped, but let's start with something "similar" to Emacs.
       Is normally called from read<em>key</em>sequence (C internal version) from command<em>loop</em>1.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><pre><code>    To identify non-default function keys we can either use:
    com.googlecode.lanterna.input.BasicCharacterPattern in our own KeyMappingProfile,
    and add it to the terminal using addInputProfile.
    Or we can do what Emacs does, and use term/xterm.el and friends (or do something similar), which
    registers a parent to input-decode-map which read-key-sequence uses to translate things on a low level.
    (These two methods are essentially the same.)
    The Emacs one would be best, but xterm.el does more stuff as well, like actually trying to talk to the terminal.
    Example:
    Lanterna:  new BasicCharacterPattern(new Key(Key.Kind.ArrowUp), ESC_CODE, '[', 'A'),
    Emacs:    (define-key map "\e[A" [up])
              And the actual ones we need:
              (define-key map "\e[1;3A" [M-up])
              This is defined differently in Lanterna:
              new BasicCharacterPattern(new Key(Key.Kind.ArrowUp, false, true), ESC_CODE, ESC_CODE, '[', 'A'),
              But we also need shift, and Key.Kind is a closed enum:
              (define-key map "\eO2A" [S-up])
   The best approach is probably to have a close to empty Lanterna InputProfile and do all this using input-decode-map.
   Normal Ctrl would be control chars, and Meta basically \e + char, which is dealt with via the esc-map in Emacs.
   Lanterna enters the mode where it can read all chars roughly like this (see UnixTerminal/enterPrivateMode):
   (do (require '[clojure.java.shell :as sh])
     (sh/sh "/bin/sh" "-c" "/bin/stty -echo &lt; /dev/tty") ;; Disables echo, leave this out for manual testing.
     (sh/sh "/bin/sh" "-c" "/bin/stty -icanon &lt; /dev/tty") ;; Enable all chars for reading.
     (sh/sh "/bin/sh" "-c" "/bin/stty min 1 &lt; /dev/tty")) ;; Read single chars.
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><p>/* read a character from the keyboard; call the redisplay if needed */
/* commandflag 0 means do not autosave, but do redisplay.
   -1 means do not redisplay, but do autosave.
   1 means do both.  */</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>/* The arguments MAPS and NMAPS are for menu prompting.
   MAPS is an array of keymaps;  NMAPS is the length of MAPS.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>   PREV_EVENT is the previous input event, or nil if we are reading
   the first event of a key sequence (or not reading a key sequence).
   If PREV_EVENT is t, that is a "magic" value that says
   not to run input methods, but in other respects to act as if
   not reading a key sequence.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>   If USED<em>MOUSE</em>MENU is non-null, then we set *USED<em>MOUSE</em>MENU to 1
   if we used a mouse menu to read the input, or zero otherwise.  If
   USED<em>MOUSE</em>MENU is null, we don't dereference it.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>   Value is -2 when we find input on another keyboard.  A second call
   to read_char will read it.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>   If END<em>TIME is non-null, it is a pointer to an EMACS</em>TIME
   specifying the maximum time to wait until.  If no input arrives by
   that time, stop waiting and return nil.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>   Value is t if we showed a menu and the user rejected it.  */</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private read-char [commandflag maps prev-event used-mouse-menu end-time]
  (lanterna.common/block-on #(.readInput ^Terminal (terminal/frame-terminal)) []
                            (when end-time {:timeout (* 1000 (- end-time (System/currentTimeMillis)))}))  )</pre></td></tr><tr><td class="docs"><p>Convert the event description list EVENT-DESC to an event type.
  EVENT-DESC should contain one base event type (a character or symbol)
  and zero or more modifier names (control, meta, hyper, super, shift, alt,
  drag, down, double or triple).  The base must be last.
  The return value is an event type (a character or symbol) which
  has the same base event type and all the specified modifiers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun event-convert-list (event-desc)
  (let [[mods base] [(set (butlast event-desc)) (last event-desc)]]
    (parser/event-convert-list-internal mods base)))</pre></td></tr><tr><td class="docs"><p>Return t if command input is currently available with no wait.
  Actually, the value is nil only if we can be sure that no input is available;
  if there is a doubt, the value is t.</p>
</td><td class="codes"><pre class="brush: clojure">(defun input-pending-p ())</pre></td></tr><tr><td class="docs"><p>Return position information for buffer POS in WINDOW.
  POS defaults to point in WINDOW; WINDOW defaults to the selected window.</p>

<p>  Return nil if position is not visible in window.  Otherwise,
  the return value is similar to that returned by `event-start' for
  a mouse click at the upper left corner of the glyph corresponding
  to the given buffer position:
     (WINDOW AREA-OR-POS (X . Y) TIMESTAMP OBJECT POS (COL . ROW)
      IMAGE (DX . DY) (WIDTH . HEIGHT))
  The `posn-' functions access elements of such lists.</p>
</td><td class="codes"><pre class="brush: clojure">(defun posn-at-point (&amp;optional pos window))</pre></td></tr><tr><td class="docs"><p>Return the raw events that were read for this command.
  More generally, it returns the last key sequence read, either by
  the command loop or by `read-key-sequence'.
  Unlike `this-single-command-keys', this function's value
  shows the events before all translations (except for input methods).
  The value is always a vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defun this-single-command-raw-keys ())</pre></td></tr><tr><td class="docs"><p>Return vector of last 300 events, not counting those from keyboard macros.</p>
</td><td class="codes"><pre class="brush: clojure">(defun recent-keys ())</pre></td></tr><tr><td class="docs"><p>Return information about the way Emacs currently reads keyboard input.
  The value is a list of the form (INTERRUPT FLOW META QUIT), where
    INTERRUPT is non-nil if Emacs is using interrupt-driven input; if
      nil, Emacs is using CBREAK mode.
    FLOW is non-nil if Emacs uses ^S/^Q flow control for output to the
      terminal; this does not apply if Emacs uses interrupt-driven input.
    META is t if accepting 8-bit input with 8th bit as Meta flag.
      META nil means ignoring the top bit, on the assumption it is parity.
      META is neither t nor nil if accepting 8-bit input and using
      all 8 bits as the character code.
    QUIT is the character Emacs currently uses to quit.
  The elements of this list correspond to the arguments of
  `set-input-mode'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-input-mode ())</pre></td></tr><tr><td class="docs"><p>Execute CMD as an editor command.
  CMD must be a symbol that satisfies the `commandp' predicate.
  Optional second arg RECORD-FLAG non-nil
  means unconditionally put this command in `command-history'.
  Otherwise, that is done only if an arg is read using the minibuffer.
  The argument KEYS specifies the value to use instead of (this-command-keys)
  when reading the arguments; if it is nil, (this-command-keys) is used.
  The argument SPECIAL, if non-nil, means that this command is executing
  a special event, so ignore the prefix argument and don't clear it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun command-execute (cmd &amp;optional record-flag keys special)
  (el/check-type 'commandp cmd)
  (when-not special
    (el/setq current-prefix-arg (data/symbol-value 'prefix-arg))
    (el/setq prefix-arg nil))
  (if (or (data/stringp cmd) (data/vectorp cmd))
    (macros/execute-kbd-macro cmd (when-not special (data/symbol-value 'current-prefix-arg)))
    (callint/call-interactively cmd record-flag keys)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(Signal/handle (Signal. &quot;CONT&quot;)
               (proxy [SignalHandler] []
                 (handle [s] (term/resume-tty))))</pre></td></tr><tr><td class="docs"><p>Stop Emacs and return to superior process.  You can resume later.
  If `cannot-suspend' is non-nil, or if the system doesn't support job
  control, run a subshell instead.</p>

<p>  If optional arg STUFFSTRING is non-nil, its characters are stuffed
  to be read as terminal input by Emacs's parent, after suspension.</p>

<p>  Before suspending, run the normal hook `suspend-hook'.
  After resumption run the normal hook `suspend-resume-hook'.</p>

<p>  Some operating systems cannot stop the Emacs process and resume it later.
  On such systems, Emacs starts a subshell instead of suspending.</p>
</td><td class="codes"><pre class="brush: clojure">(defun suspend-emacs (&amp;optional stuffstring)
  (interactive)
  (term/suspend-tty)
  (.invoke
   (doto (.getDeclaredMethod Signal &quot;raise0&quot; (into-array [Integer/TYPE]))
     (.setAccessible true)) nil (object-array [(int 20)])))</pre></td></tr><tr><td class="docs"><p>Return the current depth in recursive edits.</p>
</td><td class="codes"><pre class="brush: clojure">(defun recursion-depth ()
  0)</pre></td></tr><tr><td class="docs"><p>Like `read-key-sequence' but always return a vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-key-sequence-vector (prompt &amp;optional continue-echo dont-downcase-last can-return-switch-frame cmd-loop))</pre></td></tr><tr><td class="docs"><p>Set mode of reading keyboard input.
  First arg INTERRUPT non-nil means use input interrupts;
   nil means use CBREAK mode.
  Second arg FLOW non-nil means use ^S/^Q flow control for output to terminal
   (no effect except in CBREAK mode).
  Third arg META t means accept 8-bit input (for a Meta key).
   META nil means ignore the top bit, on the assumption it is parity.
   Otherwise, accept 8-bit input and don't use the top bit for Meta.
  Optional fourth arg QUIT if non-nil specifies character to use for quitting.
  See also `current-input-mode'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-input-mode (interrupt flow meta &amp;optional quit))</pre></td></tr><tr><td class="docs"><p>Read a sequence of keystrokes and return as a string or vector.
  The sequence is sufficient to specify a non-prefix command in the
  current local and global maps.</p>

<p>  First arg PROMPT is a prompt string.  If nil, do not prompt specially.
  Second (optional) arg CONTINUE-ECHO, if non-nil, means this key echos
  as a continuation of the previous key.</p>

<p>  The third (optional) arg DONT-DOWNCASE-LAST, if non-nil, means do not
  convert the last event to lower case.  (Normally any upper case event
  is converted to lower case if the original event is undefined and the lower
  case equivalent is defined.)  A non-nil value is appropriate for reading
  a key sequence to be defined.</p>

<p>  A C-g typed while in this function is treated like any other character,
  and `quit-flag' is not set.</p>

<p>  If the key sequence starts with a mouse click, then the sequence is read
  using the keymaps of the buffer of the window clicked in, not the buffer
  of the selected window as normal.</p>

<p>  `read-key-sequence' drops unbound button-down events, since you normally
  only care about the click or drag events which follow them.  If a drag
  or multi-click event is unbound, but the corresponding click event would
  be bound, `read-key-sequence' turns the event into a click event at the
  drag's starting position.  This means that you don't have to distinguish
  between click and drag, double, or triple events unless you want to.</p>

<p>  `read-key-sequence' prefixes mouse events on mode lines, the vertical
  lines separating windows, and scroll bars with imaginary keys
  <code>mode-line',</code>vertical-line', and `vertical-scroll-bar'.</p>

<p>  Optional fourth argument CAN-RETURN-SWITCH-FRAME non-nil means that this
  function will process a switch-frame event if the user switches frames
  before typing anything.  If the user switches frames in the middle of a
  key sequence, or at the start of the sequence but CAN-RETURN-SWITCH-FRAME
  is nil, then the event will be put off until after the current key sequence.</p>

<p>  <code>read-key-sequence' checks</code>function-key-map' for function key
  sequences, where they wouldn't conflict with ordinary bindings.  See
  `function-key-map' for more details.</p>

<p>  The optional fifth argument CMD-LOOP, if non-nil, means
  that this key sequence is being read by something that will
  read commands one after another.  It should be nil if the caller
  will read just one key sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-key-sequence (prompt &amp;optional continue-echo dont-downcase-last can-return-switch-frame cmd-loop))</pre></td></tr><tr><td class="docs"><p>Return position information for pixel coordinates X and Y.
  By default, X and Y are relative to text area of the selected window.
  Optional third arg FRAME-OR-WINDOW non-nil specifies frame or window.
  If optional fourth arg WHOLE is non-nil, X is relative to the left
  edge of the window.</p>

<p>  The return value is similar to a mouse click position:
     (WINDOW AREA-OR-POS (X . Y) TIMESTAMP OBJECT POS (COL . ROW)
      IMAGE (DX . DY) (WIDTH . HEIGHT))
  The `posn-' functions access elements of such lists.</p>
</td><td class="codes"><pre class="brush: clojure">(defun posn-at-x-y (x y &amp;optional frame-or-window whole))</pre></td></tr><tr><td class="docs"><p>Start writing all keyboard characters to a dribble file called FILE.
  If FILE is nil, close any open dribble file.
  The file will be closed when Emacs exits.</p>
</td><td class="codes"><pre class="brush: clojure">(defun open-dribble-file (file)
  (interactive &quot;FOpen dribble file: &quot;))</pre></td></tr><tr><td class="docs"><p>Invoke the editor command loop recursively.
  To get out of the recursive edit, a command can do `(throw 'exit nil)';
  that tells this function to return.
  Alternatively, `(throw 'exit t)' makes this function signal an error.
  This function is called by the editor initialization to begin editing.</p>
</td><td class="codes"><pre class="brush: clojure">(defun recursive-edit ()
  ;; Increases command_loop_level, calls the internal C functions:
  ;;   recursive_edit_1 -&gt; command_loop -&gt; command_loop_2 -&gt; command_loop_1
  ;; Each adding some layers of condition case and other things (redisplay, buffer).
  ;; command_loop_1 is the real command loop. Calls read_key_sequence.
  (interactive))</pre></td></tr><tr><td class="docs"><p>Return the key sequence that invoked this command, as a vector.
  However, if the command has called `read-key-sequence', it returns
  the last key sequence that has been read.</p>

<p>  See also `this-command-keys'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun this-command-keys-vector ())</pre></td></tr><tr><td class="docs"><p>Exit all recursive editing levels.
  This also exits all active minibuffers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun top-level ()
  (interactive))</pre></td></tr><tr><td class="docs"><p>Read function name, then read its arguments and call it.</p>

<p>  To pass a numeric argument to the command you are invoking with, specify
  the numeric argument to this command.</p>

<p>  Noninteractively, the argument PREFIXARG is the prefix argument to
  give to the command you invoke, if it asks for an argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defun execute-extended-command (prefixarg)
  (interactive &quot;P&quot;)
  (el/setq prefix-arg prefixarg)
  (command-execute (symbol nil ((el/fun 'read-extended-command)))))</pre></td></tr><tr><td class="docs"><p>Discard the contents of the terminal input buffer.
  Also end any kbd macro being defined.</p>
</td><td class="codes"><pre class="brush: clojure">(defun discard-input ())</pre></td></tr><tr><td class="docs"><p>Make the unread events replace the last command and echo.
  Used in `universal-argument-other-key'.</p>

<p>  `universal-argument-other-key' rereads the event just typed.
  It then gets translated through `function-key-map'.
  The translated event has to replace the real events,
  both in the value of (this-command-keys) and in echoing.
  To achieve this, `universal-argument-other-key' calls
  `reset-this-command-lengths', which discards the record of reading
  these events the first time.</p>
</td><td class="codes"><pre class="brush: clojure">(defun reset-this-command-lengths ())</pre></td></tr><tr><td class="docs"><p>Enable or disable 8-bit input on TERMINAL.
  If META is t, Emacs will accept 8-bit input, and interpret the 8th
  bit as the Meta modifier.</p>

<p>  If META is nil, Emacs will ignore the top bit, on the assumption it is
  parity.</p>

<p>  Otherwise, Emacs will accept and pass through 8-bit input without
  specially interpreting the top bit.</p>

<p>  This setting only has an effect on tty terminal devices.</p>

<p>  Optional parameter TERMINAL specifies the tty terminal device to use.
  It may be a terminal object, a frame, or nil for the terminal used by
  the currently selected frame.</p>

<p>  See also `current-input-mode'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-input-meta-mode (meta &amp;optional terminal))</pre></td></tr><tr><td class="docs"><p>Return the key sequence that invoked this command.
  More generally, it returns the last key sequence read, either by
  the command loop or by `read-key-sequence'.
  Unlike `this-command-keys', this function's value
  does not include prefix arguments.
  The value is always a vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defun this-single-command-keys ())</pre></td></tr><tr><td class="docs"><p>Exit from the innermost recursive edit or minibuffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun exit-recursive-edit ()
  (interactive))</pre></td></tr><tr><td class="docs"><p>Specify character used for quitting.
  QUIT must be an ASCII character.</p>

<p>  This function only has an effect on the controlling tty of the Emacs
  process.</p>

<p>  See also `current-input-mode'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-quit-char (quit))</pre></td></tr><tr><td class="docs"><p>Abort the command that requested this recursive edit or minibuffer input.</p>
</td><td class="codes"><pre class="brush: clojure">(defun abort-recursive-edit ()
  (interactive))</pre></td></tr><tr><td class="docs"><p>Set interrupt mode of reading keyboard input.
  If INTERRUPT is non-nil, Emacs will use input interrupts;
  otherwise Emacs uses CBREAK mode.</p>

<p>  See also `current-input-mode'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-input-interrupt-mode (interrupt))</pre></td></tr><tr><td class="docs"><p>Parse the event symbol.  For internal use.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-event-symbol-parse-modifiers (symbol))</pre></td></tr><tr><td class="docs"><p>Enable or disable ^S/^Q flow control for output to TERMINAL.
  If FLOW is non-nil, flow control is enabled and you cannot use C-s or
  C-q in key sequences.</p>

<p>  This setting only has an effect on tty terminals and only when
  Emacs reads input in CBREAK mode; see `set-input-interrupt-mode'.</p>

<p>  See also `current-input-mode'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-output-flow-control (flow &amp;optional terminal))</pre></td></tr><tr><td class="docs"><p>Return the key sequence that invoked this command.
  However, if the command has called `read-key-sequence', it returns
  the last key sequence that has been read.
  The value is a string or a vector.</p>

<p>  See also `this-command-keys-vector'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun this-command-keys ())</pre></td></tr><tr><td class="docs"><p>Return the current length of Emacs idleness, or nil.
  The value when Emacs is idle is a list of three integers.  The first has
  the most significant 16 bits of the seconds, while the second has the least
  significant 16 bits.  The third integer gives the microsecond count.</p>

<p>  The value when Emacs is not idle is nil.</p>

<p>  The microsecond count is zero on systems that do not provide
  resolution finer than a second.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-idle-time ())</pre></td></tr><tr><td class="docs"><p>Clear out the vector that `this-command-keys' returns.
  Also clear the record of the last 100 events, unless optional arg
  KEEP-RECORD is non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun clear-this-command-keys (&amp;optional keep-record))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.casefiddle" name="deuce.emacs.casefiddle"><h1 class="project-name">deuce.emacs.casefiddle</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.casefiddle
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [clojure.string :as s])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Convert following word (or ARG words) to upper case, moving over.
  With negative argument, convert previous words but do not move.
  See also `capitalize-word'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun upcase-word (arg)
  (interactive &quot;p&quot;))</pre></td></tr><tr><td class="docs"><p>Convert argument to upper case and return that.
  The argument may be a character or string.  The result has the same type.
  The argument object is not altered--the value is a copy.
  See also <code>capitalize',</code>downcase' and `upcase-initials'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun upcase (obj)
  (if ((some-fn char? integer?) obj)
    (int (Character/toUpperCase (int obj)))
    (s/upper-case obj)))</pre></td></tr><tr><td class="docs"><p>Capitalize the following word (or ARG words), moving over.
  This gives the word(s) a first character in upper case
  and the rest lower case.
  With negative argument, capitalize previous words but do not move.</p>
</td><td class="codes"><pre class="brush: clojure">(defun capitalize-word (arg)
  (interactive &quot;p&quot;))</pre></td></tr><tr><td class="docs"><p>Convert the region to lower case.  In programs, wants two arguments.
  These arguments specify the starting and ending character numbers of
  the region to operate on.  When used as a command, the text between
  point and the mark is operated on.</p>
</td><td class="codes"><pre class="brush: clojure">(defun downcase-region (beg end)
  (interactive &quot;r&quot;))</pre></td></tr><tr><td class="docs"><p>Convert the region to capitalized form.
  Capitalized form means each word's first character is upper case
  and the rest of it is lower case.
  In programs, give two arguments, the starting and ending
  character positions to operate on.</p>
</td><td class="codes"><pre class="brush: clojure">(defun capitalize-region (beg end)
  (interactive &quot;r&quot;))</pre></td></tr><tr><td class="docs"><p>Convert the initial of each word in the argument to upper case.
  Do not change the other letters of each word.
  The argument may be a character or string.  The result has the same type.
  The argument object is not altered--the value is a copy.</p>
</td><td class="codes"><pre class="brush: clojure">(defun upcase-initials (obj)
  (s/replace obj #&quot;\w+&quot; #(apply str (s/upper-case (first %)) (rest %))))</pre></td></tr><tr><td class="docs"><p>Convert following word (or ARG words) to lower case, moving over.
  With negative argument, convert previous words but do not move.</p>
</td><td class="codes"><pre class="brush: clojure">(defun downcase-word (arg)
  (interactive &quot;p&quot;))</pre></td></tr><tr><td class="docs"><p>Convert the region to upper case.  In programs, wants two arguments.
  These arguments specify the starting and ending character numbers of
  the region to operate on.  When used as a command, the text between
  point and the mark is operated on.
  See also `capitalize-region'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun upcase-region (beg end)
  (interactive &quot;r&quot;))</pre></td></tr><tr><td class="docs"><p>Convert argument to capitalized form and return that.
  This means that each word's first character is upper case
  and the rest is lower case.
  The argument may be a character or string.  The result has the same type.
  The argument object is not altered--the value is a copy.</p>
</td><td class="codes"><pre class="brush: clojure">(defun capitalize (obj)
  (s/capitalize obj))</pre></td></tr><tr><td class="docs"><p>Upcase the initial of each word in the region.
  Subsequent letters of each word are not changed.
  In programs, give two arguments, the starting and ending
  character positions to operate on.</p>
</td><td class="codes"><pre class="brush: clojure">(defun upcase-initials-region (beg end)
  (interactive &quot;r&quot;))</pre></td></tr><tr><td class="docs"><p>Convert argument to lower case and return that.
  The argument may be a character or string.  The result has the same type.
  The argument object is not altered--the value is a copy.</p>
</td><td class="codes"><pre class="brush: clojure">(defun downcase (obj)
  (if ((some-fn char? integer?) obj)
    (int (Character/toLowerCase (int obj)))
    (s/lower-case obj)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.composite" name="deuce.emacs.composite"><h1 class="project-name">deuce.emacs.composite</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.composite
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Function to adjust composition of buffer text.</p>

<p>  This function is called with three arguments: FROM, TO, and OBJECT.
  FROM and TO specify the range of text whose composition should be
  adjusted.  OBJECT, if non-nil, is a string that contains the text.</p>

<p>  This function is called after a text with `composition' property is
  inserted or deleted to keep `composition' property of buffer text
  valid.</p>

<p>  The default value is the function `compose-chars-after'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar compose-chars-after-function nil)</pre></td></tr><tr><td class="docs"><p>Non-nil if Auto-Composition mode is enabled.
  Use the command `auto-composition-mode' to change this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-composition-mode nil)</pre></td></tr><tr><td class="docs"><p>Function to call to compose characters automatically.
  This function is called from the display routine with four arguments:
  FROM, TO, WINDOW, and STRING.</p>

<p>  If STRING is nil, the function must compose characters in the region
  between FROM and TO in the current buffer.</p>

<p>  Otherwise, STRING is a string, and FROM and TO are indices into the
  string.  In this case, the function must compose characters in the
  string.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-composition-function nil)</pre></td></tr><tr><td class="docs"><p>Char-table of functions for automatic character composition.
  For each character that has to be composed automatically with
  preceding and/or following characters, this char-table contains
  a function to call to compose that character.</p>

<p>  The element at index C in the table, if non-nil, is a list of
  composition rules of this form: ([PATTERN PREV-CHARS FUNC] ...)</p>

<p>  PATTERN is a regular expression which C and the surrounding
  characters must match.</p>

<p>  PREV-CHARS is a non-negative integer (less than 4) specifying how many
  characters before C to check the matching with PATTERN.  If it is 0,
  PATTERN must match C and the following characters.  If it is 1,
  PATTERN must match a character before C and the following characters.</p>

<p>  If PREV-CHARS is 0, PATTERN can be nil, which means that the
  single character C should be composed.</p>

<p>  FUNC is a function to return a glyph-string representing a
  composition of the characters that match PATTERN.  It is
  called with one argument GSTRING.</p>

<p>  GSTRING is a template of a glyph-string to return.  It is already
  filled with a proper header for the characters to compose, and
  glyphs corresponding to those characters one by one.  The
  function must return a new glyph-string with the same header as
  GSTRING, or modify GSTRING itself and return it.</p>

<p>  See also the documentation of `auto-composition-mode'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar composition-function-table nil)</pre></td></tr><tr><td class="docs"><p>Internal use only.</p>

<p>  Return information about composition at or nearest to position POS.
  See `find-composition' for more details.</p>
</td><td class="codes"><pre class="brush: clojure">(defun find-composition-internal (pos limit string detail-p))</pre></td></tr><tr><td class="docs"><p>Internal use only.</p>

<p>  Compose text between indices START and END of STRING.
  Optional 4th and 5th arguments are COMPONENTS and MODIFICATION-FUNC
  for the composition.  See `compose-string' for more details.</p>
</td><td class="codes"><pre class="brush: clojure">(defun compose-string-internal (string start end &amp;optional components modification-func))</pre></td></tr><tr><td class="docs"><p>Internal use only.</p>

<p>  Compose text in the region between START and END.
  Optional 3rd and 4th arguments are COMPONENTS and MODIFICATION-FUNC
  for the composition.  See `compose-region' for more details.</p>
</td><td class="codes"><pre class="brush: clojure">(defun compose-region-internal (start end &amp;optional components modification-func))</pre></td></tr><tr><td class="docs"><p>Return a glyph-string for characters between FROM and TO.
  If the glyph string is for graphic display, FONT-OBJECT must be
  a font-object to use for those characters.
  Otherwise (for terminal display), FONT-OBJECT must be a terminal ID, a
  frame, or nil for the selected frame's terminal device.</p>

<p>  If the optional 4th argument STRING is not nil, it is a string
  containing the target characters between indices FROM and TO.</p>

<p>  A glyph-string is a vector containing information about how to display
  a specific character sequence.  The format is:
     [HEADER ID GLYPH ...]</p>

<p>  HEADER is a vector of this form:
      [FONT-OBJECT CHAR ...]
  where
      FONT-OBJECT is a font-object for all glyphs in the glyph-string,
      or the terminal coding system of the specified terminal.
      CHARs are characters to be composed by GLYPHs.</p>

<p>  ID is an identification number of the glyph-string.  It may be nil if
  not yet shaped.</p>

<p>  GLYPH is a vector whose elements have this form:
      [ FROM-IDX TO-IDX C CODE WIDTH LBEARING RBEARING ASCENT DESCENT
        [ [X-OFF Y-OFF WADJUST] | nil] ]
  where
      FROM-IDX and TO-IDX are used internally and should not be touched.
      C is the character of the glyph.
      CODE is the glyph-code of C in FONT-OBJECT.
      WIDTH thru DESCENT are the metrics (in pixels) of the glyph.
      X-OFF and Y-OFF are offsets to the base position for the glyph.
      WADJUST is the adjustment to the normal width of the glyph.</p>

<p>  If GLYPH is nil, the remaining elements of the glyph-string vector
  should be ignored.</p>
</td><td class="codes"><pre class="brush: clojure">(defun composition-get-gstring (from to font-object string))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.lread" name="deuce.emacs.lread"><h1 class="project-name">deuce.emacs.lread</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.lread
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [clojure.java.io :as io]
            [clojure.string :as s]
            [clojure.walk :as w]
            [lanterna.constants]
            [deuce.emacs-lisp :as el]
            [deuce.emacs-lisp.cons :refer [car cdr] :as cons]
            [deuce.emacs-lisp.globals :as globals]
            [deuce.emacs-lisp.printer :as printer]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns]
            [deuce.emacs.fileio :as fileio]
            [deuce.emacs.window :as window]
            [deuce.emacs-lisp.parser :as parser])
  (:refer-clojure :exclude [read intern load])
  (:import [java.io FileNotFoundException]
           [java.net URL]
           [com.googlecode.lanterna.input Key]
           [clojure.lang Compiler]))</pre></td></tr><tr><td class="docs"><p>Set to non-nil when `read' encounters an old-style backquote.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar old-style-backquotes nil)</pre></td></tr><tr><td class="docs"><p>List of values of all expressions which were read, evaluated and printed.
  Order is reverse chronological.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar values nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means force printing messages when loading Lisp files.
  This overrides the value of the NOMESSAGE argument to `load'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar force-load-messages nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, add position of read symbols to `read-symbol-positions-list'.</p>

<p>  If this variable is a buffer, then only forms read from that buffer
  will be added to `read-symbol-positions-list'.
  If this variable is t, then all read forms will be added.
  The effect of all other values other than nil are not currently
  defined, although they may be in the future.</p>

<p>  The positions are relative to the last call to `read' or
  `read-from-string'.  It is probably a bad idea to set this variable at
  the toplevel; bind it instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar read-with-symbol-positions nil)</pre></td></tr><tr><td class="docs"><p>A list mapping read symbols to their positions.
  This variable is modified during calls to `read' or
  <code>read-from-string', but only when</code>read-with-symbol-positions' is
  non-nil.</p>

<p>  Each element of the list looks like (SYMBOL . CHAR-POSITION), where
  CHAR-POSITION is an integer giving the offset of that occurrence of the
  symbol from the position where <code>read' or</code>read-from-string' started.</p>

<p>  Note that a symbol will appear multiple times in this list, if it was
  read multiple times.  The list is in the same order as the symbols
  were read in.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar read-symbol-positions-list nil)</pre></td></tr><tr><td class="docs"><p>*List of directories to search for files to load.
  Each element is a string (directory name) or nil (try default directory).
  Initialized based on EMACSLOADPATH environment variable, if any,
  otherwise to default specified by file `epaths.h' when Emacs was built.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-path (alloc/list &quot;&quot;))</pre></td></tr><tr><td class="docs"><p>Alist mapping loaded file names to symbols and features.
  Each alist element should be a list (FILE-NAME ENTRIES...), where
  FILE-NAME is the name of a file that has been loaded into Emacs.
  The file name is absolute and true (i.e. it doesn't contain symlinks).
  As an exception, one of the alist elements may have FILE-NAME nil,
  for symbols and features not associated with any file.</p>

<p>  The remaining ENTRIES in the alist element describe the functions and
  variables defined in that file, the features provided, and the
  features required.  Each entry has the form `(provide . FEATURE)',
  <code>(require . FEATURE)',</code>(defun . FUNCTION)', `(autoload . SYMBOL)',
  <code>(defface . SYMBOL)', or</code>(t . SYMBOL)'.  Entries like `(t . SYMBOL)'
  may precede a `(defun . FUNCTION)' entry, and means that SYMBOL was an
  autoload before this file redefined it as a function.  In addition,
  entries may also be single symbols, which means that SYMBOL was
  defined by <code>defvar' or</code>defconst'.</p>

<p>  During preloading, the file name recorded is relative to the main Lisp
  directory.  These file names are converted to absolute at startup.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-history nil)</pre></td></tr><tr><td class="docs"><p>File name, including directory, of user's initialization file.
  If the file loaded had extension `.elc', and the corresponding source file
  exists, this variable contains the name of source file, suitable for use
  by functions like `custom-save-all' which edit the init file.
  While Emacs loads and evaluates the init file, value is the real name
  of the file, regardless of whether or not it has the `.elc' extension.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar user-init-file nil)</pre></td></tr><tr><td class="docs"><p>List of files that were preloaded (when dumping Emacs).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar preloaded-file-list nil)</pre></td></tr><tr><td class="docs"><p>Regular expression matching safe to load compiled Lisp files.
  When Emacs loads a compiled Lisp file, it reads the first 512 bytes
  from the file, and matches them against this regular expression.
  When the regular expression matches, the file is considered to be safe
  to load.  See also `load-dangerous-libraries'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar bytecomp-version-regexp nil)</pre></td></tr><tr><td class="docs"><p>Full name of file being loaded by `load'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-file-name nil)</pre></td></tr><tr><td class="docs"><p>List of suffixes for (compiled or source) Emacs Lisp files.
  This list should not include the empty string.
  `load' and related functions try to append these suffixes, in order,
  to the specified file name if a Lisp suffix is allowed or required.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-suffixes (alloc/list &quot;.class&quot; &quot;.el&quot;))</pre></td></tr><tr><td class="docs"><p>Non-nil means `read' converts strings to unibyte whenever possible.
  This is normally bound by <code>load' and</code>eval-buffer' to control `read',
  and is not meant for users to change.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-convert-to-unibyte nil)</pre></td></tr><tr><td class="docs"><p>List of suffixes that indicate representations of the same file.
  This list should normally start with the empty string.</p>

<p>  Enabling Auto Compression mode appends the suffixes in
  `jka-compr-load-suffixes' to this list and disabling Auto Compression
  mode removes them again.  `load' and related functions use this list to
  determine whether they should look for compressed versions of a file
  and, if so, which suffixes they should try to append to the file name
  in order to do so.  However, if you want to customize which suffixes
  the loading functions recognize as compression suffixes, you should
  customize `jka-compr-load-suffixes' rather than the present variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-file-rep-suffixes (alloc/list &quot;&quot;))</pre></td></tr><tr><td class="docs"><p>Function called in `load' for loading an Emacs Lisp source file.
  This function is for doing code conversion before reading the source file.
  If nil, loading is done without any code conversion.
  Arguments are FULLNAME, FILE, NOERROR, NOMESSAGE, where
   FULLNAME is the full name of FILE.
  See `load' for the meaning of the remaining arguments.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-source-file-function nil)</pre></td></tr><tr><td class="docs"><p>Function used by <code>load' and</code>eval-region' for reading expressions.
  The default is nil, which means use the function `read'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-read-function nil)</pre></td></tr><tr><td class="docs"><p>Symbol table for use by <code>intern' and</code>read'.
  It is a vector whose length ought to be prime for best results.
  The vector's contents don't make sense if examined from Lisp programs;
  to find all the symbols in an obarray, use `mapatoms'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar obarray nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means read recursive structures using #N= and #N# syntax.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar read-circle nil)</pre></td></tr><tr><td class="docs"><p>List of buffers being read from by calls to <code>eval-buffer' and</code>eval-region'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar eval-buffer-list nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means `load' should force-load all dynamic doc strings.
  This is useful when the file being loaded is a temporary copy.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-force-doc-strings nil)</pre></td></tr><tr><td class="docs"><p>List of all DEFVAR_BOOL variables, used by the byte code optimizer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar byte-boolean-vars nil)</pre></td></tr><tr><td class="docs"><p>An alist of expressions to be evalled when particular files are loaded.
  Each element looks like (REGEXP-OR-FEATURE FORMS...).</p>

<p>  REGEXP-OR-FEATURE is either a regular expression to match file names, or
  a symbol (a feature name).</p>

<p>  When `load' is run and the file-name argument matches an element's
  REGEXP-OR-FEATURE, or when `provide' is run and provides the symbol
  REGEXP-OR-FEATURE, the FORMS in the element are executed.</p>

<p>  An error in FORMS does not undo the load, but does prevent execution of
  the rest of the FORMS.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar after-load-alist nil)</pre></td></tr><tr><td class="docs"><p>Non-nil if inside of `load'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-in-progress nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means load dangerous compiled Lisp files.
  Some versions of XEmacs use different byte codes than Emacs.  These
  incompatible byte codes can make Emacs crash when it tries to execute
  them.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar load-dangerous-libraries nil)</pre></td></tr><tr><td class="docs"><p>Used for internal purposes by `load'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar current-load-list nil)</pre></td></tr><tr><td class="docs"><p>Directory in which Emacs sources were found when Emacs was built.
  You cannot count on them to still be there!</p>
</td><td class="codes"><pre class="brush: clojure">(defvar source-directory nil)</pre></td></tr><tr><td class="docs"><p>Whether to use lexical binding when evaluating code.
  Non-nil means that the code in the current buffer should be evaluated
  with lexical binding.
  This variable is automatically set from the file variables of an
  interpreted Lisp file read using `load'.  Unlike other file local
  variables, this must be set in the first line of a file.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar lexical-binding nil)</pre></td></tr><tr><td class="docs"><p>Stream for read to get input from.
  See documentation of `read' for possible values.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar standard-input nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private echo [message]
  ;; Emacs uses 2 echo areas and switches between them.
  (let [echo-area (buffer/get-buffer-create &quot; *Echo Area 0*&quot;)]
    (if (seq message)
      (binding [buffer/*current-buffer* echo-area]
        (buffer/erase-buffer)
        (editfns/insert message))
      (binding [buffer/*current-buffer* echo-area]
        (buffer/erase-buffer)))
    (window/set-window-buffer (window/minibuffer-window) echo-area)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private read-event-internal [prompt inherit-input-method seconds]
  (when prompt (echo prompt))
  ((ns-resolve 'deuce.emacs.keyboard 'read-char) nil nil nil nil
   (+ (System/currentTimeMillis)
      (* 1000 seconds))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private key-to-integer [^Key k]
  (parser/event-convert-list-internal
   (remove nil? [(when (.isAltPressed k) 'meta)
                 (when (.isCtrlPressed k) 'control)])
   (.getCharacter k)))</pre></td></tr><tr><td class="docs"><p>This should maybe use the input-decode-map?</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:private lanterna-to-emacs-event {:enter &quot;return&quot;
                                        :page-down &quot;next&quot;
                                        :page-up &quot;prior&quot;
                                        :reverse-tab &quot;S-iso-lefttab&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private lanterna-valid-chars {:escape (Key. \)
                                     :backspace (Key. \)
                                     :enter (Key. \return)})</pre></td></tr><tr><td class="docs"><p>Read an event object from the input stream.
  If the optional argument PROMPT is non-nil, display that as a prompt.
  If the optional argument INHERIT-INPUT-METHOD is non-nil and some
  input method is turned on in the current buffer, that input method
  is used for reading a character.
  If the optional argument SECONDS is non-nil, it should be a number
  specifying the maximum number of seconds to wait for input.  If no
  input arrives in that time, return nil.  SECONDS may be a
  floating-point value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-event (&amp;optional prompt inherit-input-method seconds)
  (let [^Key k (read-event-internal prompt inherit-input-method seconds)
        kind (lanterna.constants/key-codes (.getKind k))]
    (if (= kind :normal)
      (key-to-integer k)
      (symbol (str (when (.isCtrlPressed k) &quot;C-&quot;)
                   (when (.isAltPressed k) &quot;M-&quot;)
                   (lanterna-to-emacs-event kind (name kind)))))))</pre></td></tr><tr><td class="docs"><p>Read a character from the command input (keyboard or macro).
  It is returned as a number.  Non-character events are ignored.
  If the character has modifiers, they are resolved and reflected to the
  character code if possible (e.g. C-SPC -> 0).</p>

<p>  If the optional argument PROMPT is non-nil, display that as a prompt.
  If the optional argument INHERIT-INPUT-METHOD is non-nil and some
  input method is turned on in the current buffer, that input method
  is used for reading a character.
  If the optional argument SECONDS is non-nil, it should be a number
  specifying the maximum number of seconds to wait for input.  If no
  input arrives in that time, return nil.  SECONDS may be a
  floating-point value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-char-exclusive (&amp;optional prompt inherit-input-method seconds)
  ;; Non-normal keys with modifiers, like Shift-Arrow-Up etc.
  ;; comes as a string of escape codes probably not dealt with by Lanterna.
  ;; See com.googlecode.lanterna.input.CommonProfile
  ;; We might want to write a specific EmacsProfile.
  (let [^Key k (read-event-internal prompt inherit-input-method seconds)
        kind (lanterna.constants/key-codes (.getKind k))
        ^Key k (lanterna-valid-chars kind k)
        kind (lanterna.constants/key-codes (.getKind k))]
    (if (or (= :normal kind) (Character/isISOControl (.getCharacter k)))
      (key-to-integer k)
      (el/throw* 'error &quot;Non-character input-event&quot;))))</pre></td></tr><tr><td class="docs"><p>Read one Lisp expression as text from STREAM, return as Lisp object.
  If STREAM is nil, use the value of `standard-input' (which see).
  STREAM or the value of `standard-input' may be:
   a buffer (read from point and advance it)
   a marker (read from where it points and advance it)
   a function (call it with no arguments for each character,
       call it with a char as argument to push a char back)
   a string (takes text from string, starting at the beginning)
   t (read text line using minibuffer and use it, or read from
      standard input in batch mode).</p>
</td><td class="codes"><pre class="brush: clojure">(defun read (&amp;optional stream)
  (let [stream (or stream (data/symbol-value 'standard-input))
        stream (if (data/bufferp stream)
                 (editfns/buffer-substring (editfns/point) (inc (editfns/buffer-size)))
                 stream)]
    (first (parser/parse stream))))</pre></td></tr><tr><td class="docs"><p>Read a character from the command input (keyboard or macro).
  It is returned as a number.
  If the character has modifiers, they are resolved and reflected to the
  character code if possible (e.g. C-SPC -> 0).</p>

<p>  If the user generates an event which is not a character (i.e. a mouse
  click or function key event), `read-char' signals an error.  As an
  exception, switch-frame events are put off until non-character events
  can be read.
  If you want to read non-character events, or ignore them, call
  <code>read-event' or</code>read-char-exclusive' instead.</p>

<p>  If the optional argument PROMPT is non-nil, display that as a prompt.
  If the optional argument INHERIT-INPUT-METHOD is non-nil and some
  input method is turned on in the current buffer, that input method
  is used for reading a character.
  If the optional argument SECONDS is non-nil, it should be a number
  specifying the maximum number of seconds to wait for input.  If no
  input arrives in that time, return nil.  SECONDS may be a
  floating-point value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-char (&amp;optional prompt inherit-input-method seconds)
  (read-char-exclusive prompt inherit-input-method seconds))</pre></td></tr><tr><td class="docs"><p>Execute the current buffer as Lisp code.
  When called from a Lisp program (i.e., not interactively), this
  function accepts up to five optional arguments:
  BUFFER is the buffer to evaluate (nil means use current buffer).
  PRINTFLAG controls printing of output:
   A value of nil means discard it; anything else is stream for print.
  FILENAME specifies the file name to use for `load-history'.
  UNIBYTE, if non-nil, specifies `load-convert-to-unibyte' for this
   invocation.
  DO-ALLOW-PRINT, if non-nil, specifies that `print' and related
   functions should work normally even if PRINTFLAG is nil.</p>

<p>  This function preserves the position of point.</p>
</td><td class="codes"><pre class="brush: clojure">(defun eval-buffer (&amp;optional buffer printflag filename unibyte do-allow-print)
  (interactive))</pre></td></tr><tr><td class="docs"><p>Read one Lisp expression which is represented as text by STRING.
  Returns a cons: (OBJECT-READ . FINAL-STRING-INDEX).
  FINAL-STRING-INDEX is an integer giving the position of the next
   remaining character in STRING.
  START and END optionally delimit a substring of STRING from which to read;
   they default to 0 and (length STRING) respectively.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-from-string (string &amp;optional start end)
  (let [string (subs string (or start 0) (or end (count string)))]
    (try
      (if (= \{ (first string))
        (alloc/cons (read-string string) (count string))
        (parser/parse-internal string))
      (catch Exception e
        (parser/parse-internal string)))))</pre></td></tr><tr><td class="docs"><p>Execute the region as Lisp code.
  When called from programs, expects two arguments,
  giving starting and ending indices in the current buffer
  of the text to be executed.
  Programs can pass third argument PRINTFLAG which controls output:
  A value of nil means discard it; anything else is stream for printing it.
  Also the fourth argument READ-FUNCTION, if non-nil, is used
  instead of `read' to read each expression.  It gets one argument
  which is the input stream for reading characters.</p>

<p>  This function does not move point.</p>
</td><td class="codes"><pre class="brush: clojure">(defun eval-region (start end &amp;optional printflag read-function)
  (interactive &quot;r&quot;))</pre></td></tr><tr><td class="docs"><p>Return the canonical symbol whose name is STRING.
  If there is none, one is created by this function and returned.
  A second optional argument specifies the obarray to use;
  it defaults to the value of `obarray'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun intern (string &amp;optional obarray)
  (symbol nil string))</pre></td></tr><tr><td class="docs"><p>Return the suffixes that `load' should try if a suffix is required.
  This uses the variables <code>load-suffixes' and</code>load-file-rep-suffixes'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-load-suffixes ()
  (apply alloc/list (remove empty? (concat globals/load-file-rep-suffixes globals/load-suffixes))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private access {0 fileio/file-exists-p
                       1 fileio/file-readable-p
                       2 fileio/file-writable-p
                       3 fileio/file-executable-p})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private locate-file [filename path suffixes predicate]
  (let [predicate (or predicate (el/fun 'file-readable-p))
        predicate (access predicate predicate)]
    (-&gt;&gt; (for [l path
               :let [file (str l &quot;/&quot; filename)
                     find-resource #(let [url (str (s/replace file  #&quot;^/*&quot; ) %)]
                                      (or (io/resource (s/replace url &quot;-&quot; &quot;_&quot;))
                                          (io/resource url)))
                     find-file #(let [f (io/file (str file %))]
                                  (and (.exists f) (predicate (.getAbsolutePath f))
                                       (.toURL f)))]]
           [l (some identity (map (some-fn find-resource find-file) (or suffixes [])))])
         (filter (comp identity second))
         (remove #(when (= &quot;file&quot; (.getProtocol ^URL (second %)))
                    (.isDirectory (io/file (second %)))))
         first)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ^:dynamic loads-in-progress #{})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private internal-path [path file]
  (s/replace (str (when (seq path) (str path &quot;/&quot;)) file) #&quot;^/*&quot; ))</pre></td></tr><tr><td class="docs"><p>Execute a file of Lisp code named FILE.
  First try FILE with <code>.elc' appended, then try with</code>.el',
  then try FILE unmodified (the exact suffixes in the exact order are
  determined by `load-suffixes').  Environment variable references in
  FILE are replaced with their values by calling `substitute-in-file-name'.
  This function searches the directories in `load-path'.</p>

<p>  If optional second arg NOERROR is non-nil,
  report no error if FILE doesn't exist.
  Print messages at start and end of loading unless
  optional third arg NOMESSAGE is non-nil (but `force-load-messages'
  overrides that).
  If optional fourth arg NOSUFFIX is non-nil, don't try adding
  suffixes <code>.elc' or</code>.el' to the specified name FILE.
  If optional fifth arg MUST-SUFFIX is non-nil, insist on
  the suffix <code>.elc' or</code>.el'; don't accept just FILE unless
  it ends in one of those suffixes or includes a directory name.</p>

<p>  If this function fails to find a file, it may look for different
  representations of that file before trying another file.
  It does so by adding the non-empty suffixes in `load-file-rep-suffixes'
  to the file name.  Emacs uses this feature mainly to find compressed
  versions of files when Auto Compression mode is enabled.</p>

<p>  The exact suffixes that this function tries out, in the exact order,
  are given by the value of the variable `load-file-rep-suffixes' if
  NOSUFFIX is non-nil and by the return value of the function
  `get-load-suffixes' if MUST-SUFFIX is non-nil.  If both NOSUFFIX and
  MUST-SUFFIX are nil, this function first tries out the latter suffixes
  and then the former.</p>

<p>  Loading a file records its definitions, and its `provide' and
  <code>require' calls, in an element of</code>load-history' whose
  car is the file name loaded.  See `load-history'.</p>

<p>  While the file is in the process of being loaded, the variable
  <code>load-in-progress' is non-nil and the variable</code>load-file-name'
  is bound to the file's name.</p>

<p>  Return t if the file exists and loads successfully.</p>
</td><td class="codes"><pre class="brush: clojure">(defun load (file &amp;optional noerror nomessage nosuffix must-suffix)
  ;; Need to deal with -*- lexical-binding: t -*-
  (if (loads-in-progress file)
    true ;; not really correct
    (binding [loads-in-progress (conj loads-in-progress file)]
      (try
        (let [[path url] (locate-file file (data/symbol-value 'load-path)
                                      (when-not nosuffix '(&quot;&quot; &quot;.el&quot;)) nil)
              el-extension? (re-find #&quot;.el$&quot; file)]
          (if-not url
            (el/throw* 'file-error (list &quot;Cannot open load file&quot; file)))
          (when (or (not nomessage) (data/symbol-value 'force-load-messages))
            (editfns/message &quot;Loading %s%s...&quot; file (if el-extension? &quot; (source)&quot; &quot;&quot;)))
          (binding [globals/load-file-name (.getFile ^URL url)
                    globals/load-in-progress true]
            (let [file (internal-path path (s/replace file  #&quot;.el$&quot; &quot;&quot;))
                  clj-file (str (s/replace file &quot;-&quot; &quot;_&quot;) &quot;.clj&quot;)
                  clj-name (symbol (s/replace file &quot;/&quot; &quot;.&quot;))
                  last-modified #(if % (.getLastModified (.openConnection ^URL %)) -1)
                  load-raw-clj #(if-let [r (io/resource clj-file)]
                                  (with-open [r (io/reader r)]
                                    (Compiler/load r clj-file (.getName (io/file clj-file))))
                                  (throw (FileNotFoundException. &quot;no clj file&quot;)))]
              (try
                (when (&gt; (last-modified url) (last-modified (io/resource clj-file)))
                  (throw (FileNotFoundException. &quot;out of date&quot;)))
                (if el-extension?
                  (load-raw-clj)
                  (c/require clj-name))
                (catch FileNotFoundException _
                  (binding [*compile-path* (or (some-&gt; 'deuce.main/*emacs-compile-path* resolve deref)
                                               *compile-path*)]
                    (with-open [in (io/input-stream url)]
                      (let [el (parser/parse in)
                            clj-file (io/file *compile-path* clj-file)]
                        (printer/write-clojure el clj-file)
                        (if el-extension?
                          (load-raw-clj)
                          (binding [*compile-files* true]
                            (require clj-name))))))))
              true)))
        (catch Exception e
          (when-not noerror
            (throw e)))))))</pre></td></tr><tr><td class="docs"><p>Call FUNCTION on every symbol in OBARRAY.
  OBARRAY defaults to the value of `obarray'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun mapatoms (function &amp;optional obarray))</pre></td></tr><tr><td class="docs"><p>Search for FILENAME through PATH.
  Returns the file's name in absolute form, or nil if not found.
  If SUFFIXES is non-nil, it should be a list of suffixes to append to
  file name when searching.
  If non-nil, PREDICATE is used instead of `file-readable-p'.
  PREDICATE can also be an integer to pass to the access(2) function,
  in which case file-name-handlers are ignored.
  This function will normally skip directories, so if you want it to find
  directories, make sure the PREDICATE function returns `dir-ok' for them.</p>
</td><td class="codes"><pre class="brush: clojure">(defun locate-file-internal (filename path &amp;optional suffixes predicate)
  (let [[dir file] (locate-file filename path suffixes predicate)]
    (when file
      (internal-path dir (str (io/file (.getParent (io/file filename))
                                       (.getName (io/file (.getFile ^URL file)))))))))</pre></td></tr><tr><td class="docs"><p>Delete the symbol named NAME, if any, from OBARRAY.
  The value is t if a symbol was found and deleted, nil otherwise.
  NAME may be a string or a symbol.  If it is a symbol, that symbol
  is deleted, if it belongs to OBARRAY--no other symbol is deleted.
  OBARRAY defaults to the value of the variable `obarray'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun unintern (name obarray))</pre></td></tr><tr><td class="docs"><p>Don't use this yourself.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-file-char ())</pre></td></tr><tr><td class="docs"><p>Return the canonical symbol named NAME, or nil if none exists.
  NAME may be a string or a symbol.  If it is a symbol, that exact
  symbol is searched for.
  A second optional argument specifies the obarray to use;
  it defaults to the value of `obarray'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun intern-soft (name &amp;optional obarray)
  (intern name))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.indent" name="deuce.emacs.indent"><h1 class="project-name">deuce.emacs.indent</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.indent
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>*Indentation can insert tabs if this is non-nil.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar indent-tabs-mode nil)</pre></td></tr><tr><td class="docs"><p>Return the indentation of the current line.
  This is the horizontal position of the character
  following any initial whitespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-indentation ())</pre></td></tr><tr><td class="docs"><p>Return the horizontal position of point.  Beginning of line is column 0.
  This is calculated by adding together the widths of all the displayed
  representations of the character between the start of the previous line
  and point (eg. control characters will have a width of 2 or 4, tabs
  will have a variable width).
  Ignores finite width of frame, which means that this function may return
  values greater than (frame-width).
  Whether the line is visible (if `selective-display' is t) has no effect;
  however, ^M is treated as end of line when `selective-display' is t.
  Text that has an invisible property is considered as having width 0, unless
  `buffer-invisibility-spec' specifies that it is replaced by an ellipsis.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-column ()
  (let [point (editfns/point)
        line (.lastIndexOf (subs (editfns/buffer-string) 0 (dec point)) &quot;\n&quot;)]
    (dec (if (= -1 line) point (dec (- point line))))))</pre></td></tr><tr><td class="docs"><p>Scan through the current buffer, calculating screen position.
  Scan the current buffer forward from offset FROM,
  assuming it is at position FROMPOS--a cons of the form (HPOS . VPOS)--
  to position TO or position TOPOS--another cons of the form (HPOS . VPOS)--
  and return the ending buffer position and screen location.</p>

<p>  If TOPOS is nil, the actual width and height of the window's
  text area are used.</p>

<p>  There are three additional arguments:</p>

<p>  WIDTH is the number of columns available to display text;
  this affects handling of continuation lines.  A value of nil
  corresponds to the actual number of available text columns.</p>

<p>  OFFSETS is either nil or a cons cell (HSCROLL . TAB-OFFSET).
  HSCROLL is the number of columns not being displayed at the left
  margin; this is usually taken from a window's hscroll member.
  TAB-OFFSET is the number of columns of the first tab that aren't
  being displayed, perhaps because the line was continued within it.
  If OFFSETS is nil, HSCROLL and TAB-OFFSET are assumed to be zero.</p>

<p>  WINDOW is the window to operate on.  It is used to choose the display table;
  if it is showing the current buffer, it is used also for
  deciding which overlay properties apply.
  Note that `compute-motion' always operates on the current buffer.</p>

<p>  The value is a list of five elements:
    (POS HPOS VPOS PREVHPOS CONTIN)
  POS is the buffer position where the scan stopped.
  VPOS is the vertical position where the scan stopped.
  HPOS is the horizontal position where the scan stopped.</p>

<p>  PREVHPOS is the horizontal position one character back from POS.
  CONTIN is t if a line was continued after (or within) the previous character.</p>

<p>  For example, to find the buffer position of column COL of line LINE
  of a certain window, pass the window's starting location as FROM
  and the window's upper-left coordinates as FROMPOS.
  Pass the buffer's (point-max) as TO, to limit the scan to the end of the
  visible section of the buffer, and pass LINE and COL as TOPOS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun compute-motion (from frompos to topos width offsets window))</pre></td></tr><tr><td class="docs"><p>Indent from point with tabs and spaces until COLUMN is reached.
  Optional second argument MINIMUM says always do at least MINIMUM spaces
  even if that goes past COLUMN; by default, MINIMUM is zero.</p>

<p>  The return value is COLUMN.</p>
</td><td class="codes"><pre class="brush: clojure">(defun indent-to (column &amp;optional minimum)
  (interactive &quot;NIndent to column: &quot;))</pre></td></tr><tr><td class="docs"><p>Move point to column COLUMN in the current line.
  Interactively, COLUMN is the value of prefix numeric argument.
  The column of a character is calculated by adding together the widths
  as displayed of the previous characters in the line.
  This function ignores line-continuation;
  there is no upper limit on the column number a character can have
  and horizontal scrolling has no effect.</p>

<p>  If specified column is within a character, point goes after that character.
  If it's past end of line, point goes to end of line.</p>

<p>  Optional second argument FORCE non-nil means if COLUMN is in the
  middle of a tab character, change it to spaces.
  In addition, if FORCE is t, and the line is too short to reach
  COLUMN, add spaces/tabs to get there.</p>

<p>  The return value is the current column.</p>
</td><td class="codes"><pre class="brush: clojure">(defun move-to-column (column &amp;optional force))</pre></td></tr><tr><td class="docs"><p>Move point to start of the screen line LINES lines down.
  If LINES is negative, this means moving up.</p>

<p>  This function is an ordinary cursor motion function
  which calculates the new position based on how text would be displayed.
  The new position may be the start of a line,
  or just the start of a continuation line.
  The function returns number of screen lines moved over;
  that usually equals LINES, but may be closer to zero
  if beginning or end of buffer was reached.</p>

<p>  The optional second argument WINDOW specifies the window to use for
  parameters such as width, horizontal scrolling, and so on.
  The default is to use the selected window's parameters.</p>

<p>  LINES can optionally take the form (COLS . LINES), in which case
  the motion will not stop at the start of a screen line but on
  its column COLS (if such exists on that line, that is).</p>

<p>  `vertical-motion' always uses the current buffer,
  regardless of which buffer is displayed in WINDOW.
  This is consistent with other cursor motion functions
  and makes it possible to use `vertical-motion' in any buffer,
  whether or not it is currently displayed in some window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun vertical-motion (lines &amp;optional window)
  (interactive &quot;p&quot;)
  ((ns-resolve 'deuce.emacs.cmds 'forward-line) (if (data/consp lines) (data/cdr lines) lines)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.floatfns" name="deuce.emacs.floatfns"><h1 class="project-name">deuce.emacs.floatfns</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.floatfns
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs.alloc :as alloc])
  (:refer-clojure :exclude [float]))</pre></td></tr><tr><td class="docs"><p>Truncate a floating point number to an integral float value.
  Rounds the value toward zero.</p>
</td><td class="codes"><pre class="brush: clojure">(defun ftruncate (arg)
  (double (long arg)))</pre></td></tr><tr><td class="docs"><p>Return the tangent of ARG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun tan (arg)
  (Math/tan arg))</pre></td></tr><tr><td class="docs"><p>Return the inverse tangent of the arguments.
  If only one argument Y is given, return the inverse tangent of Y.
  If two arguments Y and X are given, return the inverse tangent of Y
  divided by X, i.e. the angle in radians between the vector (X, Y)
  and the x-axis.</p>
</td><td class="codes"><pre class="brush: clojure">(defun atan (y &amp;optional x)
  (if x
    (Math/atan2 y x)
    (Math/atan y)))</pre></td></tr><tr><td class="docs"><p>Return the exponential ARG1 ** ARG2.</p>
</td><td class="codes"><pre class="brush: clojure">(defun expt (arg1 arg2)
  (Math/pow arg1 arg2))</pre></td></tr><tr><td class="docs"><p>Return the square root of ARG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun sqrt (arg)
  (Math/sqrt arg))</pre></td></tr><tr><td class="docs"><p>Return the absolute value of ARG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun abs (arg)
  (if (float? arg)
    (Math/abs (double arg))
    (Math/abs (long arg))))</pre></td></tr><tr><td class="docs"><p>Construct number X from significand SGNFCAND and exponent EXP.
  Returns the floating point value resulting from multiplying SGNFCAND
  (the significand) by 2 raised to the power of EXP (the exponent).</p>
</td><td class="codes"><pre class="brush: clojure">(defun ldexp (sgnfcand &amp;optional exponent)
  (* (Math/pow 2 (or exponent 1)) sgnfcand))</pre></td></tr><tr><td class="docs"><p>Return the smallest integer no less than ARG, as a float.
  (Round toward +inf.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun fceiling (arg)
  (Math/ceil arg))</pre></td></tr><tr><td class="docs"><p>Return the floating point number equal to ARG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun float (arg)
  (double arg))</pre></td></tr><tr><td class="docs"><p>Return the natural logarithm of ARG.
  If the optional argument BASE is given, return log ARG using that base.</p>
</td><td class="codes"><pre class="brush: clojure">(defun log (arg &amp;optional base)
  (/ (Math/log arg) (if base (Math/log base) 1)))</pre></td></tr><tr><td class="docs"><p>Return the largest integer no greater than ARG.
  This rounds the value towards -inf.
  With optional DIVISOR, return the largest integer no greater than ARG/DIVISOR.</p>
</td><td class="codes"><pre class="brush: clojure">(defun floor (arg &amp;optional divisor)
  (long (Math/floor (/ arg (or divisor 1)))))</pre></td></tr><tr><td class="docs"><p>Return the nearest integer to ARG.
  With optional DIVISOR, return the nearest integer to ARG/DIVISOR.</p>

<p>  Rounding a value equidistant between two integers may choose the
  integer closer to zero, or it may prefer an even integer, depending on
  your machine.  For example, (round 2.5) can return 3 on some
  systems, but 2 on others.</p>
</td><td class="codes"><pre class="brush: clojure">(defun round (arg &amp;optional divisor)
  (Math/round (/ arg (double (or divisor 1)))))</pre></td></tr><tr><td class="docs"><p>Return the logarithm base 10 of ARG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun log10 (arg)
  (Math/log10 arg))</pre></td></tr><tr><td class="docs"><p>Return non nil iff argument X is a NaN.</p>
</td><td class="codes"><pre class="brush: clojure">(defun isnan (x)
  (Double/isNaN x))</pre></td></tr><tr><td class="docs"><p>Return the largest integer no greater than ARG, as a float.
  (Round towards -inf.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun ffloor (arg)
  (double (long arg)))</pre></td></tr><tr><td class="docs"><p>Truncate a floating point number to an int.
  Rounds ARG toward zero.
  With optional DIVISOR, truncate ARG/DIVISOR.</p>
</td><td class="codes"><pre class="brush: clojure">(defun truncate (arg &amp;optional divisor)
  (long (/ arg (or divisor 1))))</pre></td></tr><tr><td class="docs"><p>Return the smallest integer no less than ARG.
  This rounds the value towards +inf.
  With optional DIVISOR, return the smallest integer no less than ARG/DIVISOR.</p>
</td><td class="codes"><pre class="brush: clojure">(defun ceiling (arg &amp;optional divisor)
  (long (Math/ceil (/ arg (or divisor 1)))))</pre></td></tr><tr><td class="docs"><p>Return the sine of ARG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun sin (arg)
  (Math/sin arg))</pre></td></tr><tr><td class="docs"><p>Copy sign of X2 to value of X1, and return the result.
  Cause an error if X1 or X2 is not a float.</p>
</td><td class="codes"><pre class="brush: clojure">(defun copysign (x1 x2)
  (Math/copySign (double x1) (double x2)))</pre></td></tr><tr><td class="docs"><p>Return the inverse sine of ARG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun asin (arg)
  (Math/asin arg))</pre></td></tr><tr><td class="docs"><p>Return the nearest integer to ARG, as a float.</p>
</td><td class="codes"><pre class="brush: clojure">(defun fround (arg)
  (double (long arg)))</pre></td></tr><tr><td class="docs"><p>Return the inverse cosine of ARG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun acos (arg)
  (Math/acos arg))</pre></td></tr><tr><td class="docs"><p>Get significand and exponent of a floating point number.
  Breaks the floating point number X into its binary significand SGNFCAND
  (a floating point value between 0.5 (included) and 1.0 (excluded))
  and an integral exponent EXP for 2, such that:</p>

<pre><code>X = SGNFCAND * 2^EXP
</code></pre>

<p>  The function returns the cons cell (SGNFCAND . EXP).
  If X is zero, both parts (SGNFCAND and EXP) are zero.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frexp (x)
  (if (zero? x)
    (alloc/cons 0.0 0)
    (let [exp (inc (Math/getExponent (double x)))]
      (alloc/cons (/ x (Math/pow 2 exp)) exp))))</pre></td></tr><tr><td class="docs"><p>Return the exponential base e of ARG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun exp (arg)
  (Math/exp arg))</pre></td></tr><tr><td class="docs"><p>Return the cosine of ARG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun cos (arg)
  (Math/cos arg))</pre></td></tr><tr><td class="docs"><p>Returns largest integer &lt;= the base 2 log of the magnitude of ARG.
  This is the same as the exponent of a float.</p>
</td><td class="codes"><pre class="brush: clojure">(defun logb (arg)
  (Math/getExponent (double arg)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.insdel" name="deuce.emacs.insdel"><h1 class="project-name">deuce.emacs.insdel</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.insdel
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Used internally by the `combine-after-change-calls' macro.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar combine-after-change-calls nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means enable debugging checks for invalid marker positions.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar check-markers-debug-flag nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means don't run any of the hooks that respond to buffer changes.
  This affects <code>before-change-functions' and</code>after-change-functions',
  as well as hooks attached to text properties and overlays.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-modification-hooks nil)</pre></td></tr><tr><td class="docs"><p>This function is for use internally in `combine-after-change-calls'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun combine-after-change-execute ())</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.font" name="deuce.emacs.font"><h1 class="project-name">deuce.emacs.font</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.font
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Vector of valid font weight values.
  Each element has the form:
      [NUMERIC-VALUE SYMBOLIC-NAME ALIAS-NAME ...]
  NUMERIC-VALUE is an integer, and SYMBOLIC-NAME and ALIAS-NAME are symbols.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar font-weight-table nil)</pre></td></tr><tr><td class="docs"><p>Alist of fontname patterns vs the corresponding encoding and repertory info.
  Each element looks like (REGEXP . (ENCODING . REPERTORY)),
  where ENCODING is a charset or a char-table,
  and REPERTORY is a charset, a char-table, or nil.</p>

<p>  If ENCODING and REPERTORY are the same, the element can have the form
  (REGEXP . ENCODING).</p>

<p>  ENCODING is for converting a character to a glyph code of the font.
  If ENCODING is a charset, encoding a character by the charset gives
  the corresponding glyph code.  If ENCODING is a char-table, looking up
  the table by a character gives the corresponding glyph code.</p>

<p>  REPERTORY specifies a repertory of characters supported by the font.
  If REPERTORY is a charset, all characters belonging to the charset are
  supported.  If REPERTORY is a char-table, all characters who have a
  non-nil value in the table are supported.  If REPERTORY is nil, Emacs
  gets the repertory information by an opened font and ENCODING.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar font-encoding-alist nil)</pre></td></tr><tr><td class="docs"><p>*Logging list of font related actions and results.
  The value t means to suppress the logging.
  The initial value is set to nil if the environment variable
  EMACS<em>FONT</em>LOG is set.  Otherwise, it is set to t.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar font-log nil)</pre></td></tr><tr><td class="docs"><p>Alist of font width symbols vs the corresponding numeric values.
  See `font-weight-table' for the format of the vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar font-width-table nil)</pre></td></tr><tr><td class="docs"><p>Vector of font slant symbols vs the corresponding numeric values.
  See `font-weight-table' for the format of the vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar font-slant-table nil)</pre></td></tr><tr><td class="docs"><p>Return XLFD name of FONT.
  FONT is a font-spec, font-entity, or font-object.
  If the name is too long for XLFD (maximum 255 chars), return nil.
  If the 2nd optional arg FOLD-WILDCARDS is non-nil,
  the consecutive wildcards are folded into one.</p>
</td><td class="codes"><pre class="brush: clojure">(defun font-xlfd-name (font &amp;optional fold-wildcards))</pre></td></tr><tr><td class="docs"><p>Return a font-object for displaying a character at POSITION.
  Optional second arg WINDOW, if non-nil, is a window displaying
  the current buffer.  It defaults to the currently selected window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun font-at (position &amp;optional window string))</pre></td></tr><tr><td class="docs"><p>Return a list of variation glyphs for CHAR in FONT-OBJECT.
  Each element of the value is a cons (VARIATION-SELECTOR . GLYPH-ID),
  where
    VARIATION-SELECTOR is a character code of variation selection
      (#xFE00..#xFE0F or #xE0100..#xE01EF)
    GLYPH-ID is a glyph code of the corresponding variation glyph.</p>
</td><td class="codes"><pre class="brush: clojure">(defun font-variation-glyphs (font-object character))</pre></td></tr><tr><td class="docs"><p>Open FONT-ENTITY.</p>
</td><td class="codes"><pre class="brush: clojure">(defun open-font (font-entity &amp;optional size frame))</pre></td></tr><tr><td class="docs"><p>List available fonts matching FONT-SPEC on the current frame.
  Optional 2nd argument FRAME specifies the target frame.
  Optional 3rd argument NUM, if non-nil, limits the number of returned fonts.
  Optional 4th argument PREFER, if non-nil, is a font-spec to
  control the order of the returned list.  Fonts are sorted by
  how close they are to PREFER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun list-fonts (font-spec &amp;optional frame num prefer))</pre></td></tr><tr><td class="docs"><p>Return a vector of FONT-OBJECT's glyphs for the specified characters.
  FROM and TO are positions (integers or markers) specifying a region
  of the current buffer.
  If the optional fourth arg OBJECT is not nil, it is a string or a
  vector containing the target characters.</p>

<p>  Each element is a vector containing information of a glyph in this format:
    [FROM-IDX TO-IDX C CODE WIDTH LBEARING RBEARING ASCENT DESCENT ADJUSTMENT]
  where
    FROM is an index numbers of a character the glyph corresponds to.
    TO is the same as FROM.
    C is the character of the glyph.
    CODE is the glyph-code of C in FONT-OBJECT.
    WIDTH thru DESCENT are the metrics (in pixels) of the glyph.
    ADJUSTMENT is always nil.
  If FONT-OBJECT doesn't have a glyph for a character,
  the corresponding element is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun font-get-glyphs (font-object from to &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Set one property of FONT: give property KEY value VAL.
  FONT is a font-spec, a font-entity, or a font-object.</p>

<p>  If FONT is a font-spec, KEY can be any symbol.  But if KEY is the one
  accepted by the function `font-spec' (which see), VAL must be what
  allowed in `font-spec'.</p>

<p>  If FONT is a font-entity or a font-object, KEY must not be the one
  accepted by `font-spec'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun font-put (font prop val))</pre></td></tr><tr><td class="docs"><p>Return a newly created font-spec with arguments as properties.</p>

<p>  ARGS must come in pairs KEY VALUE of font properties.  KEY must be a
  valid font property name listed below:</p>

<p>  <code>:family',</code>:weight', <code>:slant',</code>:width'</p>

<p>  They are the same as face attributes of the same name.  See
  `set-face-attribute'.</p>

<p>  `:foundry'</p>

<p>  VALUE must be a string or a symbol specifying the font foundry, e.g. ``misc''.</p>

<p>  `:adstyle'</p>

<p>  VALUE must be a string or a symbol specifying the additional
  typographic style information of a font, e.g. ``sans''.</p>

<p>  `:registry'</p>

<p>  VALUE must be a string or a symbol specifying the charset registry and
  encoding of a font, e.g. ``iso8859-1''.</p>

<p>  `:size'</p>

<p>  VALUE must be a non-negative integer or a floating point number
  specifying the font size.  It specifies the font size in pixels (if
  VALUE is an integer), or in points (if VALUE is a float).</p>

<p>  `:name'</p>

<p>  VALUE must be a string of XLFD-style or fontconfig-style font name.</p>

<p>  `:script'</p>

<p>  VALUE must be a symbol representing a script that the font must
  support.  It may be a symbol representing a subgroup of a script
  listed in the variable `script-representative-chars'.</p>

<p>  `:lang'</p>

<p>  VALUE must be a symbol of two-letter ISO-639 language names,
  e.g. `ja'.</p>

<p>  `:otf'</p>

<p>  VALUE must be a list (SCRIPT-TAG LANGSYS-TAG GSUB [ GPOS ]) to specify
  required OpenType features.</p>

<pre><code>SCRIPT-TAG: OpenType script tag symbol (e.g. `deva').
LANGSYS-TAG: OpenType language system tag symbol,
   or nil for the default language system.
GSUB: List of OpenType GSUB feature tag symbols, or nil if none required.
GPOS: List of OpenType GPOS feature tag symbols, or nil if none required.
</code></pre>

<p>  GSUB and GPOS may contain `nil' element.  In such a case, the font
  must not have any of the remaining elements.</p>

<p>  For instance, if the VALUE is `(thai nil nil (mark))', the font must
  be an OpenType font whose GPOS table of `thai' script's default
  language system must contain `mark' feature.</p>
</td><td class="codes"><pre class="brush: clojure">(defun font-spec (&amp;rest args))</pre></td></tr><tr><td class="docs"><p>Return a font-entity matching with FONT-SPEC on the current frame.
  Optional 2nd argument FRAME, if non-nil, specifies the target frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun find-font (font-spec &amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Shape the glyph-string GSTRING.
  Shaping means substituting glyphs and/or adjusting positions of glyphs
  to get the correct visual image of character sequences set in the
  header of the glyph-string.</p>

<p>  If the shaping was successful, the value is GSTRING itself or a newly
  created glyph-string.  Otherwise, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun font-shape-gstring (gstring))</pre></td></tr><tr><td class="docs"><p>Return information about FONT-OBJECT.
  The value is a vector:
    [ NAME FILENAME PIXEL-SIZE SIZE ASCENT DESCENT SPACE-WIDTH AVERAGE-WIDTH
      CAPABILITY ]</p>

<p>  NAME is the font name, a string (or nil if the font backend doesn't
  provide a name).</p>

<p>  FILENAME is the font file name, a string (or nil if the font backend
  doesn't provide a file name).</p>

<p>  PIXEL-SIZE is a pixel size by which the font is opened.</p>

<p>  SIZE is a maximum advance width of the font in pixels.</p>

<p>  ASCENT, DESCENT, SPACE-WIDTH, AVERAGE-WIDTH are metrics of the font in
  pixels.</p>

<p>  CAPABILITY is a list whose first element is a symbol representing the
  font format (x, opentype, truetype, type1, pcf, or bdf) and the
  remaining elements describe the details of the font capability.</p>

<p>  If the font is OpenType font, the form of the list is
    (opentype GSUB GPOS)
  where GSUB shows which "GSUB" features the font supports, and GPOS
  shows which "GPOS" features the font supports.  Both GSUB and GPOS are
  lists of the format:
    ((SCRIPT (LANGSYS FEATURE ...) ...) ...)</p>

<p>  If the font is not OpenType font, currently the length of the form is
  one.</p>

<p>  SCRIPT is a symbol representing OpenType script tag.</p>

<p>  LANGSYS is a symbol representing OpenType langsys tag, or nil
  representing the default langsys.</p>

<p>  FEATURE is a symbol representing OpenType feature tag.</p>

<p>  If the font is not OpenType font, CAPABILITY is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun query-font (font-object))</pre></td></tr><tr><td class="docs"><p>Return the value of FONT's property KEY.
  FONT is a font-spec, a font-entity, or a font-object.
  KEY is any symbol, but these are reserved for specific meanings:
    :family, :weight, :slant, :width, :foundry, :adstyle, :registry,
    :size, :name, :script, :otf
  See the documentation of `font-spec' for their meanings.
  In addition, if FONT is a font-entity or a font-object, values of
  :script and :otf are different from those of a font-spec as below:</p>

<p>  The value of :script may be a list of scripts that are supported by the font.</p>

<p>  The value of :otf is a cons (GSUB . GPOS) where GSUB and GPOS are lists
  representing the OpenType features supported by the font by this form:
    ((SCRIPT (LANGSYS FEATURE ...) ...) ...)
  SCRIPT, LANGSYS, and FEATURE are all symbols representing OpenType
  Layout tags.</p>
</td><td class="codes"><pre class="brush: clojure">(defun font-get (font key))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a font-spec, font-entity, or font-object.
  Return nil otherwise.
  Optional 2nd argument EXTRA-TYPE, if non-nil, specifies to check
  which kind of font it is.  It must be one of <code>font-spec',</code>font-entity',
  `font-object'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun fontp (object &amp;optional extra-type))</pre></td></tr><tr><td class="docs"><p>Return t if and only if font-spec SPEC matches with FONT.
  FONT is a font-spec, font-entity, or font-object.</p>
</td><td class="codes"><pre class="brush: clojure">(defun font-match-p (spec font))</pre></td></tr><tr><td class="docs"><p>List available font families on the current frame.
  Optional argument FRAME, if non-nil, specifies the target frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun font-family-list (&amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Clear font cache.</p>
</td><td class="codes"><pre class="brush: clojure">(defun clear-font-cache ())</pre></td></tr><tr><td class="docs"><p>Close FONT-OBJECT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun close-font (font-object &amp;optional frame))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.textprop" name="deuce.emacs.textprop"><h1 class="project-name">deuce.emacs.textprop</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.textprop
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Property-list used as default values.
  The value of a property in this list is seen as the value for every
  character that does not have its own value for that property.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-text-properties nil)</pre></td></tr><tr><td class="docs"><p>Alist of properties vs the corresponding non-stickiness.
  Each element has the form (PROPERTY . NONSTICKINESS).</p>

<p>  If a character in a buffer has PROPERTY, new text inserted adjacent to
  the character doesn't inherit PROPERTY if NONSTICKINESS is non-nil,
  inherits it if NONSTICKINESS is nil.  The `front-sticky' and
  `rear-nonsticky' properties of the character override NONSTICKINESS.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar text-property-default-nonsticky nil)</pre></td></tr><tr><td class="docs"><p>Alist of alternative properties for properties without a value.
  Each element should look like (PROPERTY ALTERNATIVE1 ALTERNATIVE2...).
  If a piece of text has no direct value for a particular property, then
  this alist is consulted.  If that property appears in the alist, then
  the first non-nil value from the associated alternative properties is
  returned.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar char-property-alias-alist nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, don't run <code>point-left' and</code>point-entered' text properties.
  This also inhibits the use of the `intangible' text property.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-point-motion-hooks nil)</pre></td></tr><tr><td class="docs"><p>Return the position of next text property or overlay change.
  This scans characters forward in the current buffer from POSITION till
  it finds a change in some text property, or the beginning or end of an
  overlay, and returns the position of that.
  If none is found up to (point-max), the function returns (point-max).</p>

<p>  If the optional second argument LIMIT is non-nil, don't search
  past position LIMIT; return LIMIT if nothing is found before LIMIT.
  LIMIT is a no-op if it is greater than (point-max).</p>
</td><td class="codes"><pre class="brush: clojure">(defun next-char-property-change (position &amp;optional limit))</pre></td></tr><tr><td class="docs"><p>Remove some properties from text from START to END.
  The third argument LIST-OF-PROPERTIES is a list of property names to remove.
  If the optional fourth argument OBJECT is a buffer (or nil, which means
  the current buffer), START and END are buffer positions (integers or
  markers).  If OBJECT is a string, START and END are 0-based indices into it.
  Return t if any property was actually removed, nil otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defun remove-list-of-text-properties (start end list-of-properties &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Return the position of next property change.
  Scans characters forward from POSITION in OBJECT till it finds
  a change in some text property, then returns the position of the change.
  If the optional second argument OBJECT is a buffer (or nil, which means
  the current buffer), POSITION is a buffer position (integer or marker).
  If OBJECT is a string, POSITION is a 0-based index into it.
  Return nil if the property is constant all the way to the end of OBJECT.
  If the value is non-nil, it is a position greater than POSITION, never equal.</p>

<p>  If the optional third argument LIMIT is non-nil, don't search
  past position LIMIT; return LIMIT if nothing is found before LIMIT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun next-property-change (position &amp;optional object limit))</pre></td></tr><tr><td class="docs"><p>Check text from START to END for property PROPERTY not equaling VALUE.
  If so, return the position of the first character whose property PROPERTY
  is not `eq' to VALUE.  Otherwise, return nil.
  If the optional fifth argument OBJECT is a buffer (or nil, which means
  the current buffer), START and END are buffer positions (integers or
  markers).  If OBJECT is a string, START and END are 0-based indices into it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun text-property-not-all (start end property value &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Add properties to the text from START to END.
  The third argument PROPERTIES is a property list
  specifying the property values to add.  If the optional fourth argument
  OBJECT is a buffer (or nil, which means the current buffer),
  START and END are buffer positions (integers or markers).
  If OBJECT is a string, START and END are 0-based indices into it.
  Return t if any property value actually changed, nil otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defun add-text-properties (start end properties &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Return the position of previous text property or overlay change for a specific property.
  Scans characters backward from POSITION till it finds
  a change in the PROP property, then returns the position of the change.
  If the optional third argument OBJECT is a buffer (or nil, which means
  the current buffer), POSITION is a buffer position (integer or marker).
  If OBJECT is a string, POSITION is a 0-based index into it.</p>

<p>  In a string, scan runs to the start of the string.
  In a buffer, it runs to (point-min), and the value cannot be less than that.</p>

<p>  The property values are compared with `eq'.
  If the property is constant all the way to the start of OBJECT, return the
  first valid position in OBJECT.
  If the optional fourth argument LIMIT is non-nil, don't search back past
  position LIMIT; return LIMIT if nothing is found before reaching LIMIT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun previous-single-char-property-change (position prop &amp;optional object limit))</pre></td></tr><tr><td class="docs"><p>Check text from START to END for property PROPERTY equaling VALUE.
  If so, return the position of the first character whose property PROPERTY
  is `eq' to VALUE.  Otherwise return nil.
  If the optional fifth argument OBJECT is a buffer (or nil, which means
  the current buffer), START and END are buffer positions (integers or
  markers).  If OBJECT is a string, START and END are 0-based indices into it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun text-property-any (start end property value &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Like `get-char-property', but with extra overlay information.
  The value is a cons cell.  Its car is the return value of `get-char-property'
  with the same arguments--that is, the value of POSITION's property
  PROP in OBJECT.  Its cdr is the overlay in which the property was
  found, or nil, if it was found as a text property or not found at all.</p>

<p>  OBJECT is optional and defaults to the current buffer.  OBJECT may be
  a string, a buffer or a window.  For strings, the cdr of the return
  value is always nil, since strings do not have overlays.  If OBJECT is
  a window, then that window's buffer is used, but window-specific
  overlays are considered only if they are associated with OBJECT.  If
  POSITION is at the end of OBJECT, both car and cdr are nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-char-property-and-overlay (position prop &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Return the position of previous text property or overlay change.
  Scans characters backward in the current buffer from POSITION till it
  finds a change in some text property, or the beginning or end of an
  overlay, and returns the position of that.
  If none is found since (point-min), the function returns (point-min).</p>

<p>  If the optional second argument LIMIT is non-nil, don't search
  past position LIMIT; return LIMIT if nothing is found before LIMIT.
  LIMIT is a no-op if it is less than (point-min).</p>
</td><td class="codes"><pre class="brush: clojure">(defun previous-char-property-change (position &amp;optional limit))</pre></td></tr><tr><td class="docs"><p>Set one property of the text from START to END.
  The third and fourth arguments PROPERTY and VALUE
  specify the property to add.
  If the optional fifth argument OBJECT is a buffer (or nil, which means
  the current buffer), START and END are buffer positions (integers or
  markers).  If OBJECT is a string, START and END are 0-based indices into it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun put-text-property (start end property value &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Remove some properties from text from START to END.
  The third argument PROPERTIES is a property list
  whose property names specify the properties to remove.
  (The values stored in PROPERTIES are ignored.)
  If the optional fourth argument OBJECT is a buffer (or nil, which means
  the current buffer), START and END are buffer positions (integers or
  markers).  If OBJECT is a string, START and END are 0-based indices into it.
  Return t if any property was actually removed, nil otherwise.</p>

<p>  Use `set-text-properties' if you want to remove all text properties.</p>
</td><td class="codes"><pre class="brush: clojure">(defun remove-text-properties (start end properties &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Return the value of POSITION's property PROP, in OBJECT.
  Both overlay properties and text properties are checked.
  OBJECT is optional and defaults to the current buffer.
  If POSITION is at the end of OBJECT, the value is nil.
  If OBJECT is a buffer, then overlay properties are considered as well as
  text properties.
  If OBJECT is a window, then that window's buffer is used, but window-specific
  overlays are considered only if they are associated with OBJECT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-char-property (position prop &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Return the position of next text property or overlay change for a specific property.
  Scans characters forward from POSITION till it finds
  a change in the PROP property, then returns the position of the change.
  If the optional third argument OBJECT is a buffer (or nil, which means
  the current buffer), POSITION is a buffer position (integer or marker).
  If OBJECT is a string, POSITION is a 0-based index into it.</p>

<p>  In a string, scan runs to the end of the string.
  In a buffer, it runs to (point-max), and the value cannot exceed that.</p>

<p>  The property values are compared with `eq'.
  If the property is constant all the way to the end of OBJECT, return the
  last valid position in OBJECT.
  If the optional fourth argument LIMIT is non-nil, don't search
  past position LIMIT; return LIMIT if nothing is found before LIMIT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun next-single-char-property-change (position prop &amp;optional object limit))</pre></td></tr><tr><td class="docs"><p>Return the position of next property change for a specific property.
  Scans characters forward from POSITION till it finds
  a change in the PROP property, then returns the position of the change.
  If the optional third argument OBJECT is a buffer (or nil, which means
  the current buffer), POSITION is a buffer position (integer or marker).
  If OBJECT is a string, POSITION is a 0-based index into it.
  The property values are compared with `eq'.
  Return nil if the property is constant all the way to the end of OBJECT.
  If the value is non-nil, it is a position greater than POSITION, never equal.</p>

<p>  If the optional fourth argument LIMIT is non-nil, don't search
  past position LIMIT; return LIMIT if nothing is found before LIMIT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun next-single-property-change (position prop &amp;optional object limit)
  limit)</pre></td></tr><tr><td class="docs"><p>Return the value of POSITION's property PROP, in OBJECT.
  OBJECT is optional and defaults to the current buffer.
  If POSITION is at the end of OBJECT, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-text-property (position prop &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Return the list of properties of the character at POSITION in OBJECT.
  If the optional second argument OBJECT is a buffer (or nil, which means
  the current buffer), POSITION is a buffer position (integer or marker).
  If OBJECT is a string, POSITION is a 0-based index into it.
  If POSITION is at the end of OBJECT, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun text-properties-at (position &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Completely replace properties of text from START to END.
  The third argument PROPERTIES is the new property list.
  If the optional fourth argument OBJECT is a buffer (or nil, which means
  the current buffer), START and END are buffer positions (integers or
  markers).  If OBJECT is a string, START and END are 0-based indices into it.
  If PROPERTIES is nil, the effect is to remove all properties from
  the designated part of OBJECT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-text-properties (start end properties &amp;optional object))</pre></td></tr><tr><td class="docs"><p>Return the position of previous property change for a specific property.
  Scans characters backward from POSITION till it finds
  a change in the PROP property, then returns the position of the change.
  If the optional third argument OBJECT is a buffer (or nil, which means
  the current buffer), POSITION is a buffer position (integer or marker).
  If OBJECT is a string, POSITION is a 0-based index into it.
  The property values are compared with `eq'.
  Return nil if the property is constant all the way to the start of OBJECT.
  If the value is non-nil, it is a position less than POSITION, never equal.</p>

<p>  If the optional fourth argument LIMIT is non-nil, don't search
  back past position LIMIT; return LIMIT if nothing is found until LIMIT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun previous-single-property-change (position prop &amp;optional object limit))</pre></td></tr><tr><td class="docs"><p>Return the position of previous property change.
  Scans characters backwards from POSITION in OBJECT till it finds
  a change in some text property, then returns the position of the change.
  If the optional second argument OBJECT is a buffer (or nil, which means
  the current buffer), POSITION is a buffer position (integer or marker).
  If OBJECT is a string, POSITION is a 0-based index into it.
  Return nil if the property is constant all the way to the start of OBJECT.
  If the value is non-nil, it is a position less than POSITION, never equal.</p>

<p>  If the optional third argument LIMIT is non-nil, don't search
  back past position LIMIT; return LIMIT if nothing is found until LIMIT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun previous-property-change (position &amp;optional object limit))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.doc" name="deuce.emacs.doc"><h1 class="project-name">deuce.emacs.doc</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.doc
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [deuce.emacs-lisp :as el])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>A list of files used to build this Emacs binary.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar build-files nil)</pre></td></tr><tr><td class="docs"><p>Name of file containing documentation strings of built-in symbols.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar internal-doc-file-name nil)</pre></td></tr><tr><td class="docs"><p>Used during Emacs initialization to scan the `etc/DOC...' file.
  This searches the `etc/DOC...' file for doc strings and
  records them in function and variable definitions.
  The function takes one argument, FILENAME, a string;
  it specifies the file name (without a directory) of the DOC file.
  That file is found in `../etc' now; later, when the dumped Emacs is run,
  the same file name is found in the `doc-directory'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun Snarf-documentation (filename))</pre></td></tr><tr><td class="docs"><p>Substitute key descriptions for command names in STRING.
  Each substring of the form [COMMAND] is replaced by either a
  keystroke sequence that invokes COMMAND, or "M-x COMMAND" if COMMAND
  is not on any keys.</p>

<p>  Each substring of the form {MAPVAR} is replaced by a summary of
  the value of MAPVAR as a keymap.  This summary is similar to the one
  produced by `describe-bindings'.  The summary ends in two newlines
  (used by the helper function `help-make-xrefs' to find the end of the
  summary).</p>

<p>  Each substring of the form \&lt;MAPVAR> specifies the use of MAPVAR
  as the keymap for future [COMMAND] substrings.
  \= quotes the following character and is discarded;
  thus, \=\= puts \= into the output, and \=[ puts [ into the output.</p>

<p>  Return the original STRING if no substitutions are made.
  Otherwise, return a new string, without any text properties.</p>
</td><td class="codes"><pre class="brush: clojure">(defun substitute-command-keys (string)
  &quot;Substitute key descriptions for command names in STRING.
  Each substring of the form \\[COMMAND] is replaced by either a
  keystroke sequence that invokes COMMAND, or \&quot;M-x COMMAND\&quot; if COMMAND
  is not on any keys.
  Each substring of the form \\{MAPVAR} is replaced by a summary of
  the value of MAPVAR as a keymap.  This summary is similar to the one
  produced by `describe-bindings'.  The summary ends in two newlines
  (used by the helper function `help-make-xrefs' to find the end of the
  summary).
  Each substring of the form \\&lt;MAPVAR&gt; specifies the use of MAPVAR
  as the keymap for future \\[COMMAND] substrings.
  \\= quotes the following character and is discarded;
  thus, \\=\\= puts \\= into the output, and \\=\\[ puts \\[ into the output.
  Return the original STRING if no substitutions are made.
  Otherwise, return a new string, without any text properties.&quot;
  string)</pre></td></tr><tr><td class="docs"><p>Return the documentation string that is SYMBOL's PROP property.
  Third argument RAW omitted or nil means pass the result through
  `substitute-command-keys' if it is a string.</p>

<p>  This differs from `get' in that it can refer to strings stored in the
  `etc/DOC' file; and that it evaluates documentation properties that
  aren't strings.</p>
</td><td class="codes"><pre class="brush: clojure">(defun documentation-property (symbol prop &amp;optional raw))</pre></td></tr><tr><td class="docs"><p>Return the documentation string of FUNCTION.
  Unless a non-nil second argument RAW is given, the
  string is passed through `substitute-command-keys'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun documentation (function &amp;optional raw)
  (let [m (meta (el/fun function))]
    (str ((if raw identity substitute-command-keys) (:doc m))
         &quot;\n\n&quot;
         (cons 'fn (or (map #(% '#{&amp;optional &amp;rest}
                                (symbol (s/upper-case %)))
                            (:el-arglist m))
                       (first (:arglists m)))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.editfns" name="deuce.emacs.editfns"><h1 class="project-name">deuce.emacs.editfns</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.editfns
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [clojure.java.io :as io]
            [clojure.java.shell :as sh]
            [clojure.string :as s]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.casefiddle :as casefiddle]
            [deuce.emacs.data :as data]
            [deuce.emacs.terminal :as terminal]
            [deuce.emacs.window :as window]
            [deuce.emacs-lisp :as el]
            [deuce.emacs-lisp.globals :as globals]
            [taoensso.timbre :as timbre])
  (:import [java.net InetAddress]
           [java.text SimpleDateFormat]
           [java.util Date Calendar TimeZone List]
           [java.lang.management ManagementFactory]
           [deuce.emacs.data Buffer BufferText Marker])
  (:refer-clojure :exclude [format]))</pre></td></tr><tr><td class="docs"><p>Property which (if non-nil) indicates text has been fontified.
  <code>buffer-substring' need not call the</code>buffer-access-fontify-functions'
  functions if all the text being accessed has this property.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-access-fontified-property nil)</pre></td></tr><tr><td class="docs"><p>The release of the operating system Emacs is running on.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar operating-system-release (System/getProperty &quot;os.version&quot;))</pre></td></tr><tr><td class="docs"><p>The user's name, based upon the real uid only.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar user-real-login-name (System/getProperty &quot;user.name&quot;))</pre></td></tr><tr><td class="docs"><p>List of functions called by `buffer-substring' to fontify if necessary.
  Each function is called with two arguments which specify the range
  of the buffer being accessed.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-access-fontify-functions nil)</pre></td></tr><tr><td class="docs"><p>The user's name, taken from environment variables if possible.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar user-login-name (System/getProperty &quot;user.name&quot;))</pre></td></tr><tr><td class="docs"><p>The host name of the machine Emacs is running on.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar system-name (-&gt; (sh/sh &quot;hostname&quot;) :out s/trim))</pre></td></tr><tr><td class="docs"><p>Non-nil means text motion commands don't notice fields.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-field-text-motion nil)</pre></td></tr><tr><td class="docs"><p>The full name of the user logged in.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar user-full-name nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private move-marker [marker pt offset]
  (let [marker ^Marker marker]
    (when-let [pos @(.charpos marker)]
      (cond
        (and @(.insertion-type marker) (&gt;= pos pt))
        (swap! (.charpos marker) + offset)
        (&gt; pos pt)
        (swap! (.charpos marker) + offset)))
    marker))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private casefold [s]
  ((if (data/symbol-value 'case-fold-search) casefiddle/downcase identity) s))</pre></td></tr><tr><td class="docs"><p>Return the character position for byte position BYTEPOS.
  If BYTEPOS is out of range, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun byte-to-position (bytepos))</pre></td></tr><tr><td class="docs"><p>Return the contents of the field around POS, without text properties.
  A field is a region of text with the same `field' property.
  If POS is nil, the value of point is used for POS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun field-string-no-properties (&amp;optional pos))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private emacs-time-to-date [[high low usec]]
  (Date. (long (+ (* (+ (bit-shift-left high 16) low) 1000) (/ usec 1000)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private date-to-emacs-time [^Date date]
  (let [now (.getTime date)
        seconds (int (/ now 1000))]
    (list (bit-shift-right seconds 16) (bit-and 0xffff seconds) (* 1000 (mod now 1000)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare buffer-string buffer-substring buffer-size point mark-marker goto-char
         point-max point-min insert eobp bobp char-before message delete-region)</pre></td></tr><tr><td class="docs"><p>Decode a time value as (SEC MINUTE HOUR DAY MONTH YEAR DOW DST ZONE).
  The optional SPECIFIED-TIME should be a list of (HIGH LOW . IGNORED),
  as from <code>current-time' and</code>file-attributes', or nil to use the
  current time.  The obsolete form (HIGH . LOW) is also still accepted.
  The list has the following nine members: SEC is an integer between 0
  and 60; SEC is 60 for a leap second, which only some operating systems
  support.  MINUTE is an integer between 0 and 59.  HOUR is an integer
  between 0 and 23.  DAY is an integer between 1 and 31.  MONTH is an
  integer between 1 and 12.  YEAR is an integer indicating the
  four-digit year.  DOW is the day of week, an integer between 0 and 6,
  where 0 is Sunday.  DST is t if daylight saving time is in effect,
  otherwise nil.  ZONE is an integer indicating the number of seconds
  east of Greenwich.  (Note that Common Lisp has different meanings for
  DOW and ZONE.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun decode-time (&amp;optional specified-time))</pre></td></tr><tr><td class="docs"><p>Return the current time, as the number of seconds since 1970-01-01 00:00:00.
  The time is returned as a list of three integers.  The first has the
  most significant 16 bits of the seconds, while the second has the
  least significant 16 bits.  The third integer gives the microsecond
  count.</p>

<p>  The microsecond count is zero on systems that do not provide
  resolution finer than a second.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-time ()
  (date-to-emacs-time (Date.)))</pre></td></tr><tr><td class="docs"><p>Return a marker to the maximum permissible value of point in this buffer.
  This is (1+ (buffer-size)), unless narrowing (a buffer restriction)
  is in effect, in which case it is less.</p>
</td><td class="codes"><pre class="brush: clojure">(defun point-max-marker ()
  ((ns-resolve 'deuce.emacs.buffer 'allocate-marker) nil (buffer/current-buffer) (point-max)))</pre></td></tr><tr><td class="docs"><p>Return the character preceding point, as a number.
  At the beginning of the buffer or accessible region, return 0.</p>
</td><td class="codes"><pre class="brush: clojure">(defun preceding-char ()
  (or (char-before) 0))</pre></td></tr><tr><td class="docs"><p>Internal use only.
  From START to END, translate characters according to TABLE.
  TABLE is a string or a char-table; the Nth character in it is the
  mapping for the character with code N.
  It returns the number of characters changed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun translate-region-internal (start end table))</pre></td></tr><tr><td class="docs"><p>Insert text at point, relocating markers and inheriting properties.
  Point and markers move forward to end up after the inserted text.</p>

<p>  If the current buffer is multibyte, unibyte strings are converted
  to multibyte for insertion (see `unibyte-char-to-multibyte').
  If the current buffer is unibyte, multibyte strings are converted
  to unibyte for insertion.</p>
</td><td class="codes"><pre class="brush: clojure">(defun insert-before-markers-and-inherit (&amp;rest args)
  (insert args))</pre></td></tr><tr><td class="docs"><p>Return the beginning of the field surrounding POS.
  A field is a region of text with the same `field' property.
  If POS is nil, the value of point is used for POS.
  If ESCAPE-FROM-EDGE is non-nil and POS is at the beginning of its
  field, then the beginning of the <em>previous</em> field is returned.
  If LIMIT is non-nil, it is a buffer position; if the beginning of the field
  is before LIMIT, then LIMIT will be returned instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun field-beginning (&amp;optional pos escape-from-edge limit))</pre></td></tr><tr><td class="docs"><p>Format a string out of a format-string and arguments.
  The first argument is a format control string.
  The other arguments are substituted into it to make the result, a string.</p>

<p>  The format control string may contain %-sequences meaning to substitute
  the next available argument:</p>

<p>  %s means print a string argument.  Actually, prints any object, with `princ'.
  %d means print as number in decimal (%o octal, %x hex).
  %X is like %x, but uses upper case.
  %e means print a number in exponential notation.
  %f means print a number in decimal-point notation.
  %g means print a number in exponential notation
    or decimal-point notation, whichever uses fewer characters.
  %c means print a number as a single character.
  %S means print any object as an s-expression (using `prin1').</p>

<p>  The argument used for %d, %o, %x, %e, %f, %g or %c must be a number.
  Use %% to put a single % into the output.</p>

<p>  A %-sequence may contain optional flag, width, and precision
  specifiers, as follows:</p>

<pre><code>%&lt;flags&gt;&lt;width&gt;&lt;precision&gt;character
</code></pre>

<p>  where flags is [+ #-0]+, width is [0-9]+, and precision is .[0-9]+</p>

<p>  The + flag character inserts a + before any positive number, while a
  space inserts a space before any positive number; these flags only
  affect %d, %e, %f, and %g sequences, and the + flag takes precedence.
  The # flag means to use an alternate display form for %o, %x, %X, %e,
  %f, and %g sequences.  The - and 0 flags affect the width specifier,
  as described below.</p>

<p>  The width specifier supplies a lower limit for the length of the
  printed representation.  The padding, if any, normally goes on the
  left, but it goes on the right if the - flag is present.  The padding
  character is normally a space, but it is 0 if the 0 flag is present.
  The 0 flag is ignored if the - flag is present, or the format sequence
  is something other than %d, %e, %f, and %g.</p>

<p>  For %e, %f, and %g sequences, the number after the "." in the
  precision specifier says how many decimal places to show; if zero, the
  decimal point itself is omitted.  For %s and %S, the precision
  specifier truncates the string to the given width.</p>
</td><td class="codes"><pre class="brush: clojure">(defun format (string &amp;rest objects)
  (apply c/format (s/replace string &quot;%S&quot; &quot;%s&quot;)
         (map #(cond
                (and (instance? Long %)
                     (&lt;= Integer/MIN_VALUE % Integer/MAX_VALUE)) (int %)
                     (instance? List %) (seq %)
                     :else %) objects)))</pre></td></tr><tr><td class="docs"><p>Return the effective uid of Emacs.
  Value is an integer or a float, depending on the value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun user-uid ()
  (try
    (Integer/parseInt (s/trim (:out (sh/sh &quot;id&quot; &quot;-u&quot;))))
    (catch Exception _
      -1)))</pre></td></tr><tr><td class="docs"><p>Set the local time zone using TZ, a string specifying a time zone rule.
  If TZ is nil, use implementation-defined default time zone information.
  If TZ is t, use Universal Time.</p>

<p>  Instead of calling this function, you typically want (setenv "TZ" TZ).
  That changes both the environment of the Emacs process and the
  variable <code>process-environment', whereas</code>set-time-zone-rule' affects
  only the former.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-time-zone-rule (tz))</pre></td></tr><tr><td class="docs"><p>Insert the arguments at point, inheriting properties from adjoining text.
  Point and before-insertion markers move forward to end up
   after the inserted text.
  Any other markers at the point of insertion remain before the text.</p>

<p>  If the current buffer is multibyte, unibyte strings are converted
  to multibyte for insertion (see `unibyte-char-to-multibyte').
  If the current buffer is unibyte, multibyte strings are converted
  to unibyte for insertion.</p>
</td><td class="codes"><pre class="brush: clojure">(defun insert-and-inherit (&amp;rest args)
  (insert args))</pre></td></tr><tr><td class="docs"><p>Return the name of the user's real uid, as a string.
  This ignores the environment variables LOGNAME and USER, so it differs from
  <code>user-login-name' when running under</code>su'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun user-real-login-name ()
  (data/symbol-value 'user-real-login-name))</pre></td></tr><tr><td class="docs"><p>Return the process ID of Emacs, as an integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun emacs-pid ()
  (let [runtime-name (.getName (ManagementFactory/getRuntimeMXBean))]
    (if-let [[[_ pid]] (re-seq #&quot;^(\d+)@\w+&quot; runtime-name)]
      (Integer/parseInt pid)
      -1)))</pre></td></tr><tr><td class="docs"><p>Return the maximum permissible value of point in the current buffer.
  This is (1+ (buffer-size)), unless narrowing (a buffer restriction)
  is in effect, in which case it is less.</p>
</td><td class="codes"><pre class="brush: clojure">(defun point-max ()
  (if-let [zv @(.zv ^Buffer (buffer/current-buffer))]
    zv
    (inc (buffer-size))))</pre></td></tr><tr><td class="docs"><p>Return t if two characters match, optionally ignoring case.
  Both arguments must be characters (i.e. integers).
  Case is ignored if `case-fold-search' is non-nil in the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-equal (c1 c2)
  (= (casefold c1) (casefold c2)))</pre></td></tr><tr><td class="docs"><p>Convert SECOND, MINUTE, HOUR, DAY, MONTH, YEAR and ZONE to internal time.
  This is the reverse operation of `decode-time', which see.
  ZONE defaults to the current time zone rule.  This can
  be a string or t (as from `set-time-zone-rule'), or it can be a list
  (as from <code>current-time-zone') or an integer (as from</code>decode-time')
  applied without consideration for daylight saving time.</p>

<p>  You can pass more than 7 arguments; then the first six arguments
  are used as SECOND through YEAR, and the <em>last</em> argument is used as ZONE.
  The intervening arguments are ignored.
  This feature lets (apply 'encode-time (decode-time ...)) work.</p>

<p>  Out-of-range values for SECOND, MINUTE, HOUR, DAY, or MONTH are allowed;
  for example, a DAY of 0 means the day preceding the given month.
  Year numbers less than 100 are treated just like other year numbers.
  If you want them to stand for years in this century, you must do that yourself.</p>

<p>  Years before 1970 are not guaranteed to work.  On some systems,
  year values as low as 1901 do work.</p>
</td><td class="codes"><pre class="brush: clojure">(defun encode-time (second minute hour day month year &amp;optional zone))</pre></td></tr><tr><td class="docs"><p>Return character in current buffer at position POS.
  POS is an integer or a marker and defaults to point.
  If POS is out of range, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-after (&amp;optional pos)
  (let [pos (dec (or pos (point)))]
    (when  (&lt; -1 pos (buffer-size))
      (.charAt (str (buffer-string)) pos))))</pre></td></tr><tr><td class="docs"><p>Return the size of the current buffer's gap.
  See also `gap-position'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun gap-size ())</pre></td></tr><tr><td class="docs"><p>Insert before point a substring of the contents of BUFFER.
  BUFFER may be a buffer or a buffer name.
  Arguments START and END are character positions specifying the substring.
  They default to the values of (point-min) and (point-max) in BUFFER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun insert-buffer-substring (buffer &amp;optional start end)
  (insert (binding [buffer/*current-buffer* buffer]
            (buffer-substring start end))))</pre></td></tr><tr><td class="docs"><p>Return a marker to the minimum permissible value of point in this buffer.
  This is the beginning, unless narrowing (a buffer restriction) is in effect.</p>
</td><td class="codes"><pre class="brush: clojure">(defun point-min-marker ()
  ((ns-resolve 'deuce.emacs.buffer 'allocate-marker) nil (buffer/current-buffer) (point-min)))</pre></td></tr><tr><td class="docs"><p>Return the first character in STRING.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-to-char (string)
  (first string))</pre></td></tr><tr><td class="docs"><p>Return value of point, as a marker object.</p>
</td><td class="codes"><pre class="brush: clojure">(defun point-marker ()
  ((ns-resolve 'deuce.emacs.buffer 'allocate-marker) nil (buffer/current-buffer) (point)))</pre></td></tr><tr><td class="docs"><p>Return the position of the gap, in the current buffer.
  See also `gap-size'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun gap-position ())</pre></td></tr><tr><td class="docs"><p>Return t if point is at the end of a line.
  `End of a line' includes point being at the end of the buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun eolp ()
  (or (eobp) (= \newline (char-after))))</pre></td></tr><tr><td class="docs"><p>Return the character position of the last character on the current line.
  With argument N not nil or 1, move forward N - 1 lines first.
  If scan reaches end of buffer, return that position.</p>

<p>  The returned position is of the last character in the logical order,
  i.e. the character whose buffer position is the largest one.</p>

<p>  This function constrains the returned position to the current field
  unless that would be on a different line than the original,
  unconstrained result.  If N is nil or 1, and a rear-sticky field ends
  at point, the scan stops as soon as it starts.  To ignore field
  boundaries bind `inhibit-field-text-motion' to t.</p>

<p>  This function does not move point.</p>
</td><td class="codes"><pre class="brush: clojure">(defun line-end-position (&amp;optional n)
  ;; This should be defined the other way around.
  (let [pt (point)]
    (try
      ((el/fun 'end-of-line) n)
      (finally (goto-char pt)))))</pre></td></tr><tr><td class="docs"><p>Restrict editing in this buffer to the current region.
  The rest of the text becomes temporarily invisible and untouchable
  but is not deleted; if you save the buffer in a file, the invisible
  text is included in the file.  C-x n w makes all visible again.
  See also `save-restriction'.</p>

<p>  When calling from a program, pass two arguments; positions (integers
  or markers) bounding the text that should remain visible.</p>
</td><td class="codes"><pre class="brush: clojure">(defun narrow-to-region (start end)
  (interactive &quot;r&quot;)
  (let [buffer ^Buffer (buffer/current-buffer)]
    (reset! (.begv buffer) start)
    (reset! (.zv buffer) end)))</pre></td></tr><tr><td class="docs"><p>Return the current run time used by Emacs.
  The time is returned as a list of three integers.  The first has the
  most significant 16 bits of the seconds, while the second has the
  least significant 16 bits.  The third integer gives the microsecond
  count.</p>

<p>  On systems that can't determine the run time, `get-internal-run-time'
  does the same thing as `current-time'.  The microsecond count is zero
  on systems that do not provide resolution finer than a second.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-internal-run-time ()
  (current-time))</pre></td></tr><tr><td class="docs"><p>Return the minimum permissible value of point in the current buffer.
  This is 1, unless narrowing (a buffer restriction) is in effect.</p>
</td><td class="codes"><pre class="brush: clojure">(defun point-min ()
  (if-let [begv @(.begv ^Buffer (buffer/current-buffer))]
    begv
    1))</pre></td></tr><tr><td class="docs"><p>Remove restrictions (narrowing) from current buffer.
  This allows the buffer's full text to be seen and edited.</p>
</td><td class="codes"><pre class="brush: clojure">(defun widen ()
  (interactive)
  (let [buffer ^Buffer (buffer/current-buffer)]
    (reset! (.begv buffer) nil)
    (reset! (.zv buffer) nil)))</pre></td></tr><tr><td class="docs"><p>From START to END, replace FROMCHAR with TOCHAR each time it occurs.
  If optional arg NOUNDO is non-nil, don't record this change for undo
  and don't mark the buffer as really changed.
  Both characters must have the same length of multi-byte form.</p>
</td><td class="codes"><pre class="brush: clojure">(defun subst-char-in-region (start end fromchar tochar &amp;optional noundo)
  (let [text ^BufferText (.text ^Buffer (buffer/current-buffer))]
    (.replace ^StringBuilder (.beg text)
              (int start) (int end)
              (s/replace (buffer-substring start end) fromchar tochar))
    (reset! (.modiff text) (System/currentTimeMillis))
    nil))</pre></td></tr><tr><td class="docs"><p>Return t if point is at the beginning of a line.</p>
</td><td class="codes"><pre class="brush: clojure">(defun bolp ()
  (or (bobp) (= \newline (char-before))))</pre></td></tr><tr><td class="docs"><p>Return the byte position for character position POSITION.
  If POSITION is out of range, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun position-bytes (position)
  (point))</pre></td></tr><tr><td class="docs"><p>Return value of point, as an integer.
  Beginning of buffer is position (point-min).</p>
</td><td class="codes"><pre class="brush: clojure">(defun point ()
  @(.pt ^Buffer (buffer/current-buffer)))</pre></td></tr><tr><td class="docs"><p>Return the contents of the field surrounding POS as a string.
  A field is a region of text with the same `field' property.
  If POS is nil, the value of point is used for POS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun field-string (&amp;optional pos))</pre></td></tr><tr><td class="docs"><p>Return the integer value of point or mark, whichever is smaller.</p>
</td><td class="codes"><pre class="brush: clojure">(defun region-beginning ()
  (min @(.charpos ^Marker (mark-marker)) (point)))</pre></td></tr><tr><td class="docs"><p>Return the character position of the first character on the current line.
  With argument N not nil or 1, move forward N - 1 lines first.
  If scan reaches end of buffer, return that position.</p>

<p>  The returned position is of the first character in the logical order,
  i.e. the one that has the smallest character position.</p>

<p>  This function constrains the returned position to the current field
  unless that would be on a different line than the original,
  unconstrained result.  If N is nil or 1, and a front-sticky field
  starts at point, the scan stops as soon as it starts.  To ignore field
  boundaries bind `inhibit-field-text-motion' to t.</p>

<p>  This function does not move point.</p>
</td><td class="codes"><pre class="brush: clojure">(defun line-beginning-position (&amp;optional n)
  ;; This should be defined the other way around.
  (let [pt (point)]
    (try
      ((el/fun 'beginning-of-line) n)
      (finally (goto-char pt)))))</pre></td></tr><tr><td class="docs"><p>Return the character following point, as a number.
  At the end of the buffer or accessible region, return 0.</p>
</td><td class="codes"><pre class="brush: clojure">(defun following-char ()
  (or (char-after) 0))</pre></td></tr><tr><td class="docs"><p>Return t if point is at the end of the buffer.
  If the buffer is narrowed, this means the end of the narrowed part.</p>
</td><td class="codes"><pre class="brush: clojure">(defun eobp ()
  (= (point) (point-max)))</pre></td></tr><tr><td class="docs"><p>Return the characters of part of the buffer, without the text properties.
  The two arguments START and END are character positions;
  they can be in either order.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-substring-no-properties (start end)
  (buffer-substring start end))</pre></td></tr><tr><td class="docs"><p>Return the real uid of Emacs.
  Value is an integer or a float, depending on the value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun user-real-uid ()
  (user-uid))</pre></td></tr><tr><td class="docs"><p>Return the end of the field surrounding POS.
  A field is a region of text with the same `field' property.
  If POS is nil, the value of point is used for POS.
  If ESCAPE-FROM-EDGE is non-nil and POS is at the end of its field,
  then the end of the <em>following</em> field is returned.
  If LIMIT is non-nil, it is a buffer position; if the end of the field
  is after LIMIT, then LIMIT will be returned instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun field-end (&amp;optional pos escape-from-edge limit))</pre></td></tr><tr><td class="docs"><p>Return the name under which the user logged in, as a string.
  This is based on the effective uid, not the real uid.
  Also, if the environment variables LOGNAME or USER are set,
  that determines the value of this function.</p>

<p>  If optional argument UID is an integer or a float, return the login name
  of the user with that uid, or nil if there is no such user.</p>
</td><td class="codes"><pre class="brush: clojure">(defun user-login-name (&amp;optional uid)
  (data/symbol-value 'user-login-name))</pre></td></tr><tr><td class="docs"><p>Return t if point is at the beginning of the buffer.
  If the buffer is narrowed, this means the beginning of the narrowed part.</p>
</td><td class="codes"><pre class="brush: clojure">(defun bobp ()
  (= (point-min) (point)))</pre></td></tr><tr><td class="docs"><p>Display a message in a dialog box or in the echo area.
  If this command was invoked with the mouse, use a dialog box if
  `use-dialog-box' is non-nil.
  Otherwise, use the echo area.
  The first argument is a format control string, and the rest are data
  to be formatted under control of the string.  See `format' for details.</p>

<p>  If the first argument is nil or the empty string, clear any existing
  message; let the minibuffer contents show.</p>
</td><td class="codes"><pre class="brush: clojure">(defun message-or-box (format-string &amp;rest args)
  (message format-string args))</pre></td></tr><tr><td class="docs"><p>Return a copy of STRING with text properties added.
  First argument is the string to copy.
  Remaining arguments form a sequence of PROPERTY VALUE pairs for text
  properties to add to the result.</p>
</td><td class="codes"><pre class="brush: clojure">(defun propertize (string &amp;rest properties)
  string)</pre></td></tr><tr><td class="docs"><p>Return the current local time, as a human-readable string.
  Programs can use this function to decode a time,
  since the number of columns in each field is fixed
  if the year is in the range 1000-9999.
  The format is `Sun Sep 16 01:03:52 1973'.
  However, see also the functions <code>decode-time' and</code>format-time-string'
  which provide a much more powerful and general facility.</p>

<p>  If SPECIFIED-TIME is given, it is a time to format instead of the
  current time.  The argument should have the form (HIGH LOW . IGNORED).
  Thus, you can use times obtained from `current-time' and from
  `file-attributes'.  SPECIFIED-TIME can also have the form (HIGH . LOW),
  but this is considered obsolete.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-time-string (&amp;optional specified-time)
  (.format (SimpleDateFormat. &quot;EEE MMM dd HH:mm:ss yyyy&quot;)
           (emacs-time-to-date (or specified-time (current-time)))))</pre></td></tr><tr><td class="docs"><p>Return the position closest to NEW-POS that is in the same field as OLD-POS.
  A field is a region of text with the same `field' property.</p>

<p>  If NEW-POS is nil, then use the current point instead, and move point
  to the resulting constrained position, in addition to returning that
  position.</p>

<p>  If OLD-POS is at the boundary of two fields, then the allowable
  positions for NEW-POS depends on the value of the optional argument
  ESCAPE-FROM-EDGE: If ESCAPE-FROM-EDGE is nil, then NEW-POS is
  constrained to the field that has the same `field' char-property
  as any new characters inserted at OLD-POS, whereas if ESCAPE-FROM-EDGE
  is non-nil, NEW-POS is constrained to the union of the two adjacent
  fields.  Additionally, if two fields are separated by another field with
  the special value `boundary', then any point within this special field is
  also considered to be `on the boundary'.</p>

<p>  If the optional argument ONLY-IN-LINE is non-nil and constraining
  NEW-POS would move it to a different line, NEW-POS is returned
  unconstrained.  This useful for commands that move by line, like
  C-n or M-x beginning-of-line, which should generally respect field boundaries
  only in the case where they can still move to the right line.</p>

<p>  If the optional argument INHIBIT-CAPTURE-PROPERTY is non-nil, and OLD-POS has
  a non-nil property of that name, then any field boundaries are ignored.</p>

<p>  Field boundaries are not noticed if `inhibit-field-text-motion' is non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun constrain-to-field (new-pos old-pos &amp;optional escape-from-edge only-in-line inhibit-capture-property)
  ;; This a vast simplification
  (if new-pos
    new-pos
    (goto-char (point))))</pre></td></tr><tr><td class="docs"><p>Return the contents of the current buffer as a string.
  If narrowing is in effect, this function returns only the visible part
  of the buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-string ()
  (buffer-substring (point-min) (point-max)))</pre></td></tr><tr><td class="docs"><p>Return the string currently displayed in the echo area, or nil if none.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-message ()
  ;; Not sure when and why it uses &quot; *Echo Area 1*&quot;
  (binding [buffer/*current-buffer* (buffer/get-buffer-create &quot; *Echo Area 0*&quot;)]
    (buffer-string)))</pre></td></tr><tr><td class="docs"><p>Delete the field surrounding POS.
  A field is a region of text with the same `field' property.
  If POS is nil, the value of point is used for POS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-field (&amp;optional pos))</pre></td></tr><tr><td class="docs"><p>Delete the text between START and END and return it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-and-extract-region (start end)
  (let [deleted (buffer-substring start end)]
    (delete-region start end)
    deleted))</pre></td></tr><tr><td class="docs"><p>Return the offset and name for the local time zone.
  This returns a list of the form (OFFSET NAME).
  OFFSET is an integer number of seconds ahead of UTC (east of Greenwich).
      A negative value means west of Greenwich.
  NAME is a string giving the name of the time zone.
  If SPECIFIED-TIME is given, the time zone offset is determined from it
  instead of using the current time.  The argument should have the form
  (HIGH LOW . IGNORED).  Thus, you can use times obtained from
  <code>current-time' and from</code>file-attributes'.  SPECIFIED-TIME can also
  have the form (HIGH . LOW), but this is considered obsolete.</p>

<p>  Some operating systems cannot provide all this information to Emacs;
  in this case, `current-time-zone' returns a list containing nil for
  the data it can't find.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-time-zone (&amp;optional specified-time)
  (let [^Date specified-time (if specified-time
                               (emacs-time-to-date specified-time)
                               (Date.))
        timezone (.getTimeZone (doto (Calendar/getInstance)
                                 (.setTime specified-time)))]
    (list (/ (.getOffset timezone (.getTime specified-time)) 1000)
          (.getDisplayName timezone (.inDaylightTime timezone specified-time) TimeZone/SHORT))))</pre></td></tr><tr><td class="docs"><p>Insert strings or characters at point, relocating markers after the text.
  Point and markers move forward to end up after the inserted text.</p>

<p>  If the current buffer is multibyte, unibyte strings are converted
  to multibyte for insertion (see `unibyte-char-to-multibyte').
  If the current buffer is unibyte, multibyte strings are converted
  to unibyte for insertion.</p>
</td><td class="codes"><pre class="brush: clojure">(defun insert-before-markers (&amp;rest args)
  (insert args))</pre></td></tr><tr><td class="docs"><p>Return character in current buffer preceding position POS.
  POS is an integer or a marker and defaults to point.
  If POS is out of range, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-before (&amp;optional pos)
  (let [pos (- (or pos (point)) 2)]
    (when (&lt; -1 pos (buffer-size))
      (.charAt (str (buffer-string)) pos))))</pre></td></tr><tr><td class="docs"><p>Convert arg CHAR to a string containing that character.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-to-string (char)
  (str (c/char char)))</pre></td></tr><tr><td class="docs"><p>Delete the text between START and END.
  If called interactively, delete the region between point and mark.
  This command deletes buffer text without modifying the kill ring.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-region (start end)
  (interactive &quot;r&quot;)
  (let [buffer ^Buffer (buffer/current-buffer)
        text ^BufferText (.text buffer)]
    (.delete ^StringBuilder (.beg text) (int (dec start)) (int (dec end)))
    (reset! (.modiff text) (System/currentTimeMillis))
    (when-not (some #{@(.mark buffer)} @(.markers text))
      (swap! (.mark buffer) #(move-marker % start (- start end))))
    (swap! (.markers text) #(doall (map (fn [m] (move-marker m start (- start end))) %)))
    (when (&gt; (point) start)
      (goto-char start)
      nil)))</pre></td></tr><tr><td class="docs"><p>Transpose region STARTR1 to ENDR1 with STARTR2 to ENDR2.
  The regions should not be overlapping, because the size of the buffer is
  never changed in a transposition.</p>

<p>  Optional fifth arg LEAVE-MARKERS, if non-nil, means don't update
  any markers that happen to be located in the regions.</p>

<p>  Transposing beyond buffer boundaries is an error.</p>
</td><td class="codes"><pre class="brush: clojure">(defun transpose-regions (startr1 endr1 startr2 endr2 &amp;optional leave-markers)
  (let [r1 (buffer-substring startr1 endr1)
        r2 (buffer-substring startr2 endr2)
        pt (point)
        buffer ^Buffer (buffer/current-buffer)
        text ^BufferText (.text buffer)
        mark @(.mark buffer)
        markers @(.markers text)]
    (delete-region startr1 endr1)
    (goto-char startr1)
    (insert r2)
    (delete-region startr2 endr2)
    (goto-char startr2)
    (insert r1)
    (when leave-markers
      (reset! (.mark buffer) mark)
      (reset! (.markers text) markers))
    (goto-char pt)))</pre></td></tr><tr><td class="docs"><p>Set point to POSITION, a number or marker.
  Beginning of buffer is position (point-min), end is (point-max).</p>

<p>  The return value is POSITION.</p>
</td><td class="codes"><pre class="brush: clojure">(defun goto-char (position)
  (interactive &quot;NGoto char: &quot;)
  (el/check-type 'integer-or-marker-p position)
  (let [position (if (data/markerp position) @(.charpos ^Marker position) position)
        real-pos (min (max (point-min) position) (point-max))]
    (reset! (.pt ^Buffer (buffer/current-buffer)) real-pos)
    position))</pre></td></tr><tr><td class="docs"><p>Insert COUNT copies of CHARACTER.
  Point, and before-insertion markers, are relocated as in the function `insert'.
  The optional third arg INHERIT, if non-nil, says to inherit text properties
  from adjoining text, if those properties are sticky.</p>
</td><td class="codes"><pre class="brush: clojure">(defun insert-char (character count &amp;optional inherit)
  (insert (apply str (repeat count character))))</pre></td></tr><tr><td class="docs"><p>Return the host name of the machine you are running on, as a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun system-name ()
  (data/symbol-value 'system-name))</pre></td></tr><tr><td class="docs"><p>Return the number of characters in the current buffer.
  If BUFFER, return the number of characters in that buffer instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-size (&amp;optional buffer)
  (count (.beg ^BufferText (.text ^Buffer (el/check-type 'bufferp (or buffer (buffer/current-buffer)))))))</pre></td></tr><tr><td class="docs"><p>Return the integer value of point or mark, whichever is larger.</p>
</td><td class="codes"><pre class="brush: clojure">(defun region-end ()
  (max @(.charpos ^Marker (mark-marker)) (point)))</pre></td></tr><tr><td class="docs"><p>Use FORMAT-STRING to format the time TIME, or now if omitted.
  TIME is specified as (HIGH LOW . IGNORED), as returned by
  <code>current-time' or</code>file-attributes'.  The obsolete form (HIGH . LOW)
  is also still accepted.
  The third, optional, argument UNIVERSAL, if non-nil, means describe TIME
  as Universal Time; nil means describe TIME in the local time zone.
  The value is a copy of FORMAT-STRING, but with certain constructs replaced
  by text that describes the specified date and time in TIME:</p>

<p>  %Y is the year, %y within the century, %C the century.
  %G is the year corresponding to the ISO week, %g within the century.
  %m is the numeric month.
  %b and %h are the locale's abbreviated month name, %B the full name.
  %d is the day of the month, zero-padded, %e is blank-padded.
  %u is the numeric day of week from 1 (Monday) to 7, %w from 0 (Sunday) to 6.
  %a is the locale's abbreviated name of the day of week, %A the full name.
  %U is the week number starting on Sunday, %W starting on Monday,
   %V according to ISO 8601.
  %j is the day of the year.</p>

<p>  %H is the hour on a 24-hour clock, %I is on a 12-hour clock, %k is like %H
   only blank-padded, %l is like %I blank-padded.
  %p is the locale's equivalent of either AM or PM.
  %M is the minute.
  %S is the second.
  %N is the nanosecond, %6N the microsecond, %3N the millisecond, etc.
  %Z is the time zone name, %z is the numeric form.
  %s is the number of seconds since 1970-01-01 00:00:00 +0000.</p>

<p>  %c is the locale's date and time format.
  %x is the locale's "preferred" date format.
  %D is like "%m/%d/%y".</p>

<p>  %R is like "%H:%M", %T is like "%H:%M:%S", %r is like "%I:%M:%S %p".
  %X is the locale's "preferred" time format.</p>

<p>  Finally, %n is a newline, %t is a tab, %% is a literal %.</p>

<p>  Certain flags and modifiers are available with some format controls.
  The flags are <code>_',</code>-', <code>^' and</code>#'.  For certain characters X,
  %_X is like %X, but padded with blanks; %-X is like %X,
  but without padding.  %^X is like %X, but with all textual
  characters up-cased; %#X is like %X, but with letter-case of
  all textual characters reversed.
  %NX (where N stands for an integer) is like %X,
  but takes up at least N (a number) positions.
  The modifiers are <code>E' and</code>O'.  For certain characters X,
  %EX is a locale's alternative version of %X;
  %OX is like %X, but uses the locale's number symbols.</p>

<p>  For example, to produce full ISO 8601 format, use "%Y-%m-%dT%T%z".</p>
</td><td class="codes"><pre class="brush: clojure">(defun format-time-string (format-string &amp;optional time universal)
  (let [[hi low] (or time (current-time))
        time (long (* (+ (bit-shift-left hi 16) low) 1000))]
    (.format (SimpleDateFormat. (reduce #(apply s/replace %1 %2) format-string
                                        {&quot;%Y&quot; &quot;Y&quot;
                                         &quot;%m&quot; &quot;MM&quot;
                                         &quot;%d&quot; &quot;dd&quot;})) (Date. time))))</pre></td></tr><tr><td class="docs"><p>Insert COUNT (second arg) copies of BYTE (first arg).
  Both arguments are required.
  BYTE is a number of the range 0..255.</p>

<p>  If BYTE is 128..255 and the current buffer is multibyte, the
  corresponding eight-bit character is inserted.</p>

<p>  Point, and before-insertion markers, are relocated as in the function `insert'.
  The optional third arg INHERIT, if non-nil, says to inherit text properties
  from adjoining text, if those properties are sticky.</p>
</td><td class="codes"><pre class="brush: clojure">(defun insert-byte (byte count &amp;optional inherit)
  (insert-char (char byte) count inherit))</pre></td></tr><tr><td class="docs"><p>Compare two substrings of two buffers; return result as number.
  the value is -N if first string is less after N-1 chars,
  +N if first string is greater after N-1 chars, or 0 if strings match.
  Each substring is represented as three arguments: BUFFER, START and END.
  That makes six args in all, three for each substring.</p>

<p>  The value of `case-fold-search' in the current buffer
  determines whether case is significant or ignored.</p>
</td><td class="codes"><pre class="brush: clojure">(defun compare-buffer-substrings (buffer1 start1 end1 buffer2 start2 end2)
  (let [s1 (binding [buffer/*current-buffer* buffer1]
             (buffer-substring start1 end1))
        s2 (binding [buffer/*current-buffer* buffer2]
             (buffer-substring start2 end2))]
    (compare (casefold s1) (casefold s2))))</pre></td></tr><tr><td class="docs"><p>Return this buffer's mark, as a marker object.
  Watch out!  Moving this marker changes the mark position.
  If you set the marker not to point anywhere, the buffer will have no mark.</p>
</td><td class="codes"><pre class="brush: clojure">(defun mark-marker ()
  @(.mark ^Buffer (buffer/current-buffer)))</pre></td></tr><tr><td class="docs"><p>Return the full name of the user logged in, as a string.
  If the full name corresponding to Emacs's userid is not known,
  return "unknown".</p>

<p>  If optional argument UID is an integer or float, return the full name
  of the user with that uid, or nil if there is no such user.
  If UID is a string, return the full name of the user with that login
  name, or nil if there is no such user.</p>
</td><td class="codes"><pre class="brush: clojure">(defun user-full-name (&amp;optional uid))</pre></td></tr><tr><td class="docs"><p>Display a message at the bottom of the screen.
  The message also goes into the `<em>Messages</em>' buffer.
  (In keyboard macros, that's all it does.)
  Return the message.</p>

<p>  The first argument is a format control string, and the rest are data
  to be formatted under control of the string.  See `format' for details.</p>

<p>  Note: Use (message "%s" VALUE) to print the value of expressions and
  variables to avoid accidentally interpreting `%' as format specifiers.</p>

<p>  If the first argument is nil or the empty string, the function clears
  any existing message; this lets the minibuffer contents show.  See
  also `current-message'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun message (format-string &amp;rest args)
  ;; The echo area buffers are called &quot; *Echo Area %d*&quot;. They share window with the minibuffer.
  ;; Note the leading space for minibuffer window buffers.
  ;; Need to pick the right ones here instead of just 0.
  ;; Part of this is duplicated in deuce.emacs.lread/echo, consolidate when we know more.
  (let [message (when message (apply format format-string args))
        echo-area (buffer/get-buffer-create &quot; *Echo Area 0*&quot;)
        minibuffer (buffer/get-buffer-create &quot; *Minibuf-0*&quot;)]
    (if (seq message)
      (do
        (timbre/info message)
        (binding [buffer/*current-buffer* (buffer/get-buffer-create &quot;*Messages*&quot;)]
          (insert (str message \newline))) ;; Emacs has logic to figure out if newline is needed.
        (binding [buffer/*current-buffer* echo-area]
          (buffer/erase-buffer)
          (insert message))
        (window/set-window-buffer (window/minibuffer-window) echo-area)
        ;; This will go away
        (when-not (terminal/frame-terminal)
          (println message)))
      (do
        (binding [buffer/*current-buffer* echo-area]
          (buffer/erase-buffer))
        (window/set-window-buffer (window/minibuffer-window) minibuffer)))))</pre></td></tr><tr><td class="docs"><p>Insert the arguments, either strings or characters, at point.
  Point and before-insertion markers move forward to end up
   after the inserted text.
  Any other markers at the point of insertion remain before the text.</p>

<p>  If the current buffer is multibyte, unibyte strings are converted
  to multibyte for insertion (see `string-make-multibyte').
  If the current buffer is unibyte, multibyte strings are converted
  to unibyte for insertion (see `string-make-unibyte').</p>

<p>  When operating on binary data, it may be necessary to preserve the
  original bytes of a unibyte string when inserting it into a multibyte
  buffer; to accomplish this, apply `string-as-multibyte' to the string
  and insert the result.</p>
</td><td class="codes"><pre class="brush: clojure">(defun insert (&amp;rest args)
  (let [string (str (apply str args))
        buffer ^Buffer (buffer/current-buffer)
        pt @(.pt buffer)
        text ^BufferText (.text buffer)]
    (.insert ^StringBuilder (.beg text) (int (dec pt)) string)
    (reset! (.modiff text) (System/currentTimeMillis))
    (when-not (some #{@(.mark buffer)} @(.markers text))
      (swap! (.mark buffer) #(move-marker % pt (count string))))
    (swap! (.markers text) #(doall (map (fn [m] (move-marker m pt (count string))) %)))
    (goto-char (+ pt (count string))))
  nil)</pre></td></tr><tr><td class="docs"><p>Return the contents of part of the current buffer as a string.
  The two arguments START and END are character positions;
  they can be in either order.
  The string returned is multibyte if the buffer is multibyte.</p>

<p>  This function copies the text properties of that part of the buffer
  into the result string; if you don't want the text properties,
  use `buffer-substring-no-properties' instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-substring (start end)
  (subs (str (.beg ^BufferText (.text ^Buffer (buffer/current-buffer)))) (dec start) (dec end)))</pre></td></tr><tr><td class="docs"><p>Convert arg BYTE to a unibyte string containing that byte.</p>
</td><td class="codes"><pre class="brush: clojure">(defun byte-to-string (byte)
  (str (char byte)))</pre></td></tr><tr><td class="docs"><p>Return the current time, as a float number of seconds since the epoch.
  If SPECIFIED-TIME is given, it is the time to convert to float
  instead of the current time.  The argument should have the form
  (HIGH LOW) or (HIGH LOW USEC). Thus, you can use times obtained from
  <code>current-time' and from</code>file-attributes'.  SPECIFIED-TIME can also
  have the form (HIGH . LOW), but this is considered obsolete.</p>

<p>  WARNING: Since the result is floating point, it may not be exact.
  If precise time stamps are required, use either `current-time',
  or (if you need time as a string) `format-time-string'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun float-time (&amp;optional specified-time)
  (let [^Date specified-time (if specified-time
                               (emacs-time-to-date specified-time)
                               (Date.))]
    (/ (.getTime specified-time) 1000.0)))</pre></td></tr><tr><td class="docs"><p>Display a message, in a dialog box if possible.
  If a dialog box is not available, use the echo area.
  The first argument is a format control string, and the rest are data
  to be formatted under control of the string.  See `format' for details.</p>

<p>  If the first argument is nil or the empty string, clear any existing
  message; let the minibuffer contents show.</p>
</td><td class="codes"><pre class="brush: clojure">(defun message-box (format-string &amp;rest args)
  (message format-string args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.minibuf" name="deuce.emacs.minibuf"><h1 class="project-name">deuce.emacs.minibuf</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.minibuf
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs-lisp :as el]
            [deuce.emacs-lisp.cons :refer [car] :as cons]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns]
            [deuce.emacs.fns :as fns]
            [deuce.emacs.window :as window])
  (:refer-clojure :exclude [read-string]))</pre></td></tr><tr><td class="docs"><p>History list symbol to add minibuffer values to.
  Each string of minibuffer input, as it appears on exit from the minibuffer,
  is added with
    (set minibuffer-history-variable
    (cons STRING (symbol-value minibuffer-history-variable)))</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-history-variable nil)</pre></td></tr><tr><td class="docs"><p>A history list for arguments that are Lisp expressions to evaluate.
  For example, `eval-expression' uses this.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar read-expression-history nil)</pre></td></tr><tr><td class="docs"><p>List of regexps that should restrict possible completions.
  The basic completion functions only consider a completion acceptable
  if it matches all regular expressions in this list, with
  <code>case-fold-search' bound to the value of</code>completion-ignore-case'.
  See Info node `(elisp)Basic Completion', for a description of these
  functions.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar completion-regexp-list nil)</pre></td></tr><tr><td class="docs"><p>Normal hook run just after exit from minibuffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-exit-hook nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means completing file names.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-completing-file-name nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means to allow minibuffer commands while in the minibuffer.
  This variable makes a difference whenever the minibuffer window is active.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar enable-recursive-minibuffers nil)</pre></td></tr><tr><td class="docs"><p>Normal hook run just after entry to minibuffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-setup-hook nil)</pre></td></tr><tr><td class="docs"><p>Text properties that are added to minibuffer prompts.
  These are in addition to the basic `field' property, and stickiness
  properties.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-prompt-properties nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means completion ignores case when reading a buffer name.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar read-buffer-completion-ignore-case nil)</pre></td></tr><tr><td class="docs"><p>Current position of redoing in the history list.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-history-position nil)</pre></td></tr><tr><td class="docs"><p>If this is non-nil, `read-buffer' does its work by calling this function.
  The function is called with the arguments passed to `read-buffer'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar read-buffer-function nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means to delete duplicates in history.
  If set to t when adding a new history element, all previous identical
  elements are deleted from the history list.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar history-delete-duplicates nil)</pre></td></tr><tr><td class="docs"><p>Within call to `completing-read', this holds the PREDICATE argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-completion-predicate nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means don't consider case significant in completion.
  For file-name completion, `read-file-name-completion-ignore-case'
  controls the behavior, rather than this variable.
  For buffer name completion, `read-buffer-completion-ignore-case'
  controls the behavior, rather than this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar completion-ignore-case nil)</pre></td></tr><tr><td class="docs"><p>Value that `help-form' takes on inside the minibuffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-help-form nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means `read-from-minibuffer' should not discard text properties.
  This also affects <code>read-string', but it does not affect</code>read-minibuffer',
  `read-no-blanks-input', or any of the functions that do minibuffer input
  with completion; they always discard text properties.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-allow-text-properties nil)</pre></td></tr><tr><td class="docs"><p>Minibuffer keymap used for reading Lisp expressions.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar read-expression-map nil)</pre></td></tr><tr><td class="docs"><p>Maximum length of history lists before truncation takes place.
  A number means truncate to that length; truncation deletes old
  elements, and is done just after inserting a new element.
  A value of t means no truncation.</p>

<p>  This variable only affects history lists that don't specify their own
  maximum lengths.  Setting the `history-length' property of a history
  variable overrides this default.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar history-length nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means entering the minibuffer raises the minibuffer's frame.
  Some uses of the echo area also raise that frame (since they use it too).</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-auto-raise nil)</pre></td></tr><tr><td class="docs"><p>Alist or obarray used for completion in the minibuffer.
  This becomes the ALIST argument to <code>try-completion' and</code>all-completions'.
  The value can also be a list of strings or a hash table.</p>

<p>  The value may alternatively be a function, which is given three arguments:
    STRING, the current buffer contents;
    PREDICATE, the predicate for filtering possible matches;
    CODE, which says what kind of things to do.
  CODE can be nil, t or `lambda':
    nil    -- return the best completion of STRING, or nil if there is none.
    t      -- return a list of all possible completions of STRING.
    lambda -- return t if STRING is a valid completion as it stands.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-completion-table nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means to add new elements in history.
  If set to nil, minibuffer reading functions don't add new elements to the
  history list, so it is possible to do this afterwards by calling
  `add-to-history' explicitly.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar history-add-new-input nil)</pre></td></tr><tr><td class="docs"><p>Whether to demand confirmation of completion before exiting minibuffer.
  If nil, confirmation is not required.
  If the value is `confirm', the user may exit with an input that is not
   a valid completion alternative, but Emacs asks for confirmation.
  If the value is `confirm-after-completion', the user may exit with an
   input that is not a valid completion alternative, but Emacs asks for
   confirmation if the user submitted the input right after any of the
   completion commands listed in `minibuffer-confirm-exit-commands'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-completion-confirm nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare filter-completions active-minibuffer-window)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private minibuf-prompt (atom nil))</pre></td></tr><tr><td class="docs"><p>Return current depth of activations of minibuffer, a nonnegative integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun minibuffer-depth ()
  (if (active-minibuffer-window) 1 0))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private minibuffer [prompt &amp; [default]]
  (let [minibuffer (buffer/get-buffer-create &quot; *Minibuf-1*&quot;)]
    (binding [buffer/*current-buffer* minibuffer]
      (buffer/erase-buffer)
      (when (seq prompt)
        (editfns/insert prompt))
      (when default
        (editfns/insert (if (data/listp default) (data/car default) default))))
    (reset! minibuf-prompt prompt)
    (window/set-window-buffer (window/minibuffer-window) minibuffer)
    (window/select-window (window/minibuffer-window))))</pre></td></tr><tr><td class="docs"><p>Return non-nil if STRING is a valid completion.
  Takes the same arguments as <code>all-completions' and</code>try-completion'.
  If COLLECTION is a function, it is called with three arguments:
  the values STRING, PREDICATE and `lambda'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun test-completion (string collection &amp;optional predicate)
  (when (some #{string} (filter-completions collection predicate))
    true))</pre></td></tr><tr><td class="docs"><p>Read a string in the minibuffer, with completion.
  PROMPT is a string to prompt with; normally it ends in a colon and a space.
  COLLECTION can be a list of strings, an alist, an obarray or a hash table.
  COLLECTION can also be a function to do the completion itself.
  PREDICATE limits completion to a subset of COLLECTION.
  See <code>try-completion' and</code>all-completions' for more details
   on completion, COLLECTION, and PREDICATE.</p>

<p>  REQUIRE-MATCH can take the following values:
  - t means that the user is not allowed to exit unless
    the input is (or completes to) an element of COLLECTION or is null.
  - nil means that the user can exit with any input.
  - `confirm' means that the user can exit with any input, but she needs
    to confirm her choice if the input is not an element of COLLECTION.
  - `confirm-after-completion' means that the user can exit with any
    input, but she needs to confirm her choice if she called
    <code>minibuffer-complete' right before</code>minibuffer-complete-and-exit'
    and the input is not an element of COLLECTION.
  - anything else behaves like t except that typing RET does not exit if it
    does non-null completion.</p>

<p>  If the input is null, `completing-read' returns DEF, or the first element
  of the list of default values, or an empty string if DEF is nil,
  regardless of the value of REQUIRE-MATCH.</p>

<p>  If INITIAL-INPUT is non-nil, insert it in the minibuffer initially,
    with point positioned at the end.
    If it is (STRING . POSITION), the initial input is STRING, but point
    is placed at <em>zero-indexed</em> position POSITION in STRING.  (<em>Note</em>
    that this is different from `read-from-minibuffer' and related
    functions, which use one-indexing for POSITION.)  This feature is
    deprecated--it is best to pass nil for INITIAL-INPUT and supply the
    default value DEF instead.  The user can yank the default value into
    the minibuffer easily using M-x next-history-element.</p>

<p>  HIST, if non-nil, specifies a history list and optionally the initial
    position in the list.  It can be a symbol, which is the history list
    variable to use, or it can be a cons cell (HISTVAR . HISTPOS).  In
    that case, HISTVAR is the history list variable to use, and HISTPOS
    is the initial position (the position in the list used by the
    minibuffer history commands).  For consistency, you should also
    specify that element of the history as the value of
    INITIAL-INPUT.  (This is the only case in which you should use
    INITIAL-INPUT instead of DEF.)  Positions are counted starting from
    1 at the beginning of the list.  The variable `history-length'
    controls the maximum length of a history list.</p>

<p>  DEF, if non-nil, is the default value or the list of default values.</p>

<p>  If INHERIT-INPUT-METHOD is non-nil, the minibuffer inherits
    the current input method and the setting of `enable-multibyte-characters'.</p>

<p>  Completion ignores case if the ambient value of
    `completion-ignore-case' is non-nil.</p>

<p>  See also `completing-read-function'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun completing-read (prompt collection &amp;optional predicate require-match initial-input hist def inherit-input-method)
  (minibuffer prompt))</pre></td></tr><tr><td class="docs"><p>Read a string from the minibuffer, prompting with string PROMPT.
  The optional second arg INITIAL-CONTENTS is an obsolete alternative to
    DEFAULT-VALUE.  It normally should be nil in new code, except when
    HIST is a cons.  It is discussed in more detail below.</p>

<p>  Third arg KEYMAP is a keymap to use whilst reading;
    if omitted or nil, the default is `minibuffer-local-map'.</p>

<p>  If fourth arg READ is non-nil, interpret the result as a Lisp object
    and return that object:
    in other words, do `(car (read-from-string INPUT-STRING))'</p>

<p>  Fifth arg HIST, if non-nil, specifies a history list and optionally
    the initial position in the list.  It can be a symbol, which is the
    history list variable to use, or a cons cell (HISTVAR . HISTPOS).
    In that case, HISTVAR is the history list variable to use, and
    HISTPOS is the initial position for use by the minibuffer history
    commands.  For consistency, you should also specify that element of
    the history as the value of INITIAL-CONTENTS.  Positions are counted
    starting from 1 at the beginning of the list.</p>

<p>  Sixth arg DEFAULT-VALUE, if non-nil, should be a string, which is used
    as the default to `read' if READ is non-nil and the user enters
    empty input.  But if READ is nil, this function does <em>not</em> return
    DEFAULT-VALUE for empty input!  Instead, it returns the empty string.</p>

<pre><code>Whatever the value of READ, DEFAULT-VALUE is made available via the
minibuffer history commands.  DEFAULT-VALUE can also be a list of
strings, in which case all the strings are available in the history,
and the first string is the default to `read' if READ is non-nil.
</code></pre>

<p>  Seventh arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits
   the current input method and the setting of `enable-multibyte-characters'.</p>

<p>  If the variable `minibuffer-allow-text-properties' is non-nil,
   then the string which is returned includes whatever text properties
   were present in the minibuffer.  Otherwise the value has no text properties.</p>

<p>  The remainder of this documentation string describes the
  INITIAL-CONTENTS argument in more detail.  It is only relevant when
  studying existing code, or when HIST is a cons.  If non-nil,
  INITIAL-CONTENTS is a string to be inserted into the minibuffer before
  reading input.  Normally, point is put at the end of that string.
  However, if INITIAL-CONTENTS is (STRING . POSITION), the initial
  input is STRING, but point is placed at <em>one-indexed</em> position
  POSITION in the minibuffer.  Any integer value less than or equal to
  one puts point at the beginning of the string.  <em>Note</em> that this
  behavior differs from the way such arguments are used in `completing-read'
  and some related functions, which use zero-indexing for POSITION.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-from-minibuffer (prompt &amp;optional initial-contents keymap read hist default-value inherit-input-method))</pre></td></tr><tr><td class="docs"><p>Like `assoc' but specifically for strings (and symbols).</p>

<p>  This returns the first element of LIST whose car matches the string or
  symbol KEY, or nil if no match exists.  When performing the
  comparison, symbols are first converted to strings, and unibyte
  strings to multibyte.  If the optional arg CASE-FOLD is non-nil, case
  is ignored.</p>

<p>  Unlike `assoc', KEY can also match an entry in LIST consisting of a
  single string, rather than a cons cell whose car is a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun assoc-string (key list &amp;optional case-fold)
  (some #(and (if (data/consp %)
                (fns/equal key (str (car %)))
                (fns/equal key %)) %) (seq list)))</pre></td></tr><tr><td class="docs"><p>Read a string from the terminal, not allowing blanks.
  Prompt with PROMPT.  Whitespace terminates the input.  If INITIAL is
  non-nil, it should be a string, which is used as initial input, with
  point positioned at the end, so that SPACE will accept the input.
  (Actually, INITIAL can also be a cons of a string and an integer.
  Such values are treated as in `read-from-minibuffer', but are normally
  not useful in this function.)
  Third arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits
  the current input method and the setting of`enable-multibyte-characters'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-no-blanks-input (prompt &amp;optional initial inherit-input-method))</pre></td></tr><tr><td class="docs"><p>Return the prompt string of the currently-active minibuffer.
  If no minibuffer is active, return nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun minibuffer-prompt ()
  @minibuf-prompt)</pre></td></tr><tr><td class="docs"><p>Read the name of a command and return as a symbol.
  Prompt with PROMPT.  By default, return DEFAULT-VALUE or its first element
  if it is a list.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-command (prompt &amp;optional default-value)
  (minibuffer prompt default-value))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private filter-completions [collection predicate]
  (map #(if (data/consp %) (car %) %)
       (filter (if predicate (el/fun predicate) identity) collection)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private try-completion-internal [string collection]
  (when-let [completions (seq (filter #(.startsWith (str %) ^String string) collection))]
    (reduce #(loop [n (count %1)]
               (let [prefix (subs %1 0 n)]
                 (if (.startsWith ^String %2 prefix) prefix (recur (dec n)))))
            (sort completions))))</pre></td></tr><tr><td class="docs"><p>Return common substring of all completions of STRING in COLLECTION.
  Test each possible completion specified by COLLECTION
  to see if it begins with STRING.  The possible completions may be
  strings or symbols.  Symbols are converted to strings before testing,
  see `symbol-name'.
  All that match STRING are compared together; the longest initial sequence
  common to all these matches is the return value.
  If there is no match at all, the return value is nil.
  For a unique match which is exact, the return value is t.</p>

<p>  If COLLECTION is an alist, the keys (cars of elements) are the
  possible completions.  If an element is not a cons cell, then the
  element itself is the possible completion.
  If COLLECTION is a hash-table, all the keys that are strings or symbols
  are the possible completions.
  If COLLECTION is an obarray, the names of all symbols in the obarray
  are the possible completions.</p>

<p>  COLLECTION can also be a function to do the completion itself.
  It receives three arguments: the values STRING, PREDICATE and nil.
  Whatever it returns becomes the value of `try-completion'.</p>

<p>  If optional third argument PREDICATE is non-nil,
  it is used to test each possible match.
  The match is a candidate only if PREDICATE returns non-nil.
  The argument given to PREDICATE is the alist element
  or the symbol from the obarray.  If COLLECTION is a hash-table,
  predicate is called with two arguments: the key and the value.
  Additionally to this predicate, `completion-regexp-list'
  is used to further constrain the set of candidates.</p>
</td><td class="codes"><pre class="brush: clojure">(defun try-completion (string collection &amp;optional predicate)
  (let [collection (filter-completions collection predicate)]
    (when-let [completion (try-completion-internal string collection)]
      (if (= 1 (count (filter #{string} collection)))
        true
        completion))))</pre></td></tr><tr><td class="docs"><p>Return value of Lisp expression read using the minibuffer.
  Prompt with PROMPT.  If non-nil, optional second arg INITIAL-CONTENTS
  is a string to insert in the minibuffer before reading.
  (INITIAL-CONTENTS can also be a cons of a string and an integer.
  Such arguments are used as in `read-from-minibuffer'.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun eval-minibuffer (prompt &amp;optional initial-contents))</pre></td></tr><tr><td class="docs"><p>Read a string from the minibuffer, prompting with string PROMPT.
  If non-nil, second arg INITIAL-INPUT is a string to insert before reading.
    This argument has been superseded by DEFAULT-VALUE and should normally
    be nil in new code.  It behaves as in `read-from-minibuffer'.  See the
    documentation string of that function for details.
  The third arg HISTORY, if non-nil, specifies a history list
    and optionally the initial position in the list.
  See `read-from-minibuffer' for details of HISTORY argument.
  Fourth arg DEFAULT-VALUE is the default value or the list of default values.
   If non-nil, it is used for history commands, and as the value (or the first
   element of the list of default values) to return if the user enters the
   empty string.
  Fifth arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits
   the current input method and the setting of `enable-multibyte-characters'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-string (prompt &amp;optional initial-input history default-value inherit-input-method))</pre></td></tr><tr><td class="docs"><p>Return the buffer position of the end of the minibuffer prompt.
  Return (point-min) if current buffer is not a minibuffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun minibuffer-prompt-end ()
  (if (active-minibuffer-window)
    (inc (count @minibuf-prompt))
    (editfns/point-min)))</pre></td></tr><tr><td class="docs"><p>Specify which minibuffer window to use for the minibuffer.
  This affects where the minibuffer is displayed if you put text in it
  without invoking the usual minibuffer commands.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-minibuffer-window (window))</pre></td></tr><tr><td class="docs"><p>Return t if BUFFER is a minibuffer.
  No argument or nil as argument means use current buffer as BUFFER.
  BUFFER can be a buffer or a buffer name.</p>
</td><td class="codes"><pre class="brush: clojure">(defun minibufferp (&amp;optional buffer)
  (when (re-find #&quot; *Minibuf-\d+&quot; (buffer/buffer-name buffer))
    true))</pre></td></tr><tr><td class="docs"><p>Perform completion on buffer names.
  If the argument FLAG is nil, invoke `try-completion', if it's t, invoke
  <code>all-completions', otherwise invoke</code>test-completion'.</p>

<p>  The arguments STRING and PREDICATE are as in `try-completion',
  <code>all-completions', and</code>test-completion'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-complete-buffer (string predicate flag))</pre></td></tr><tr><td class="docs"><p>Search for partial matches to STRING in COLLECTION.
  Test each of the possible completions specified by COLLECTION
  to see if it begins with STRING.  The possible completions may be
  strings or symbols.  Symbols are converted to strings before testing,
  see `symbol-name'.
  The value is a list of all the possible completions that match STRING.</p>

<p>  If COLLECTION is an alist, the keys (cars of elements) are the
  possible completions.  If an element is not a cons cell, then the
  element itself is the possible completion.
  If COLLECTION is a hash-table, all the keys that are strings or symbols
  are the possible completions.
  If COLLECTION is an obarray, the names of all symbols in the obarray
  are the possible completions.</p>

<p>  COLLECTION can also be a function to do the completion itself.
  It receives three arguments: the values STRING, PREDICATE and t.
  Whatever it returns becomes the value of `all-completions'.</p>

<p>  If optional third argument PREDICATE is non-nil,
  it is used to test each possible match.
  The match is a candidate only if PREDICATE returns non-nil.
  The argument given to PREDICATE is the alist element
  or the symbol from the obarray.  If COLLECTION is a hash-table,
  predicate is called with two arguments: the key and the value.
  Additionally to this predicate, `completion-regexp-list'
  is used to further constrain the set of candidates.</p>

<p>  An obsolete optional fourth argument HIDE-SPACES is still accepted for
  backward compatibility.  If non-nil, strings in COLLECTION that start
  with a space are ignored unless STRING itself starts with a space.</p>
</td><td class="codes"><pre class="brush: clojure">(defun all-completions (string collection &amp;optional predicate)
  (let [collection (filter-completions collection predicate)
        prefix (try-completion-internal string collection)]
    (apply alloc/list (filter #(.startsWith (str %) prefix) collection))))</pre></td></tr><tr><td class="docs"><p>Read the name of a buffer and return as a string.
  Prompt with PROMPT.
  Optional second arg DEF is value to return if user enters an empty line.
   If DEF is a list of default values, return its first element.
  Optional third arg REQUIRE-MATCH determines whether non-existing
   buffer names are allowed.  It has the same meaning as the
   REQUIRE-MATCH argument of `completing-read'.
  The argument PROMPT should be a string ending with a colon and a space.
  If `read-buffer-completion-ignore-case' is non-nil, completion ignores
  case while reading the buffer name.
  If `read-buffer-function' is non-nil, this works by calling it as a
  function, instead of the usual behavior.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-buffer (prompt &amp;optional def require-match))</pre></td></tr><tr><td class="docs"><p>Return a Lisp object read using the minibuffer, unevaluated.
  Prompt with PROMPT.  If non-nil, optional second arg INITIAL-CONTENTS
  is a string to insert in the minibuffer before reading.
  (INITIAL-CONTENTS can also be a cons of a string and an integer.
  Such arguments are used as in `read-from-minibuffer'.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-minibuffer (prompt &amp;optional initial-contents))</pre></td></tr><tr><td class="docs"><p>Return the user input in a minibuffer as a string, without text-properties.
  If the current buffer is not a minibuffer, return its entire contents.</p>
</td><td class="codes"><pre class="brush: clojure">(defun minibuffer-contents-no-properties ()
  (editfns/buffer-string))</pre></td></tr><tr><td class="docs"><p>Return the user input in a minibuffer as a string.
  If the current buffer is not a minibuffer, return its entire contents.</p>
</td><td class="codes"><pre class="brush: clojure">(defun minibuffer-contents ()
  (subs (editfns/buffer-string) (count @minibuf-prompt)))</pre></td></tr><tr><td class="docs"><p>Read the name of a user variable and return it as a symbol.
  Prompt with PROMPT.  By default, return DEFAULT-VALUE or its first element
  if it is a list.
  A user variable is one for which `user-variable-p' returns non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-variable (prompt &amp;optional default-value))</pre></td></tr><tr><td class="docs"><p>Return the currently active minibuffer window, or nil if none.</p>
</td><td class="codes"><pre class="brush: clojure">(defun active-minibuffer-window ()
  (when (= (window/selected-window) (window/minibuffer-window))
    (window/minibuffer-window)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.menu" name="deuce.emacs.menu"><h1 class="project-name">deuce.emacs.menu</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.menu
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Pop up a deck-of-cards menu and return user's selection.
  POSITION is a position specification.  This is either a mouse button event
  or a list ((XOFFSET YOFFSET) WINDOW)
  where XOFFSET and YOFFSET are positions in pixels from the top left
  corner of WINDOW.  (WINDOW may be a window or a frame object.)
  This controls the position of the top left of the menu as a whole.
  If POSITION is t, it means to use the current mouse position.</p>

<p>  MENU is a specifier for a menu.  For the simplest case, MENU is a keymap.
  The menu items come from key bindings that have a menu string as well as
  a definition; actually, the "definition" in such a key binding looks like
  (STRING . REAL-DEFINITION).  To give the menu a title, put a string into
  the keymap as a top-level element.</p>

<p>  If REAL-DEFINITION is nil, that puts a nonselectable string in the menu.
  Otherwise, REAL-DEFINITION should be a valid key binding definition.</p>

<p>  You can also use a list of keymaps as MENU.
    Then each keymap makes a separate pane.</p>

<p>  When MENU is a keymap or a list of keymaps, the return value is the
  list of events corresponding to the user's choice. Note that
  `x-popup-menu' does not actually execute the command bound to that
  sequence of events.</p>

<p>  Alternatively, you can specify a menu of multiple panes
    with a list of the form (TITLE PANE1 PANE2...),
  where each pane is a list of form (TITLE ITEM1 ITEM2...).
  Each ITEM is normally a cons cell (STRING . VALUE);
  but a string can appear as an item--that makes a nonselectable line
  in the menu.
  With this form of menu, the return value is VALUE from the chosen item.</p>

<p>  If POSITION is nil, don't display the menu at all, just precalculate the
  cached information about equivalent key sequences.</p>

<p>  If the user gets rid of the menu without making a valid choice, for
  instance by clicking the mouse away from a valid choice or by typing
  keyboard input, then this normally results in a quit and
  `x-popup-menu' does not return.  But if POSITION is a mouse button
  event (indicating that the user invoked the menu with the mouse) then
  no quit occurs and `x-popup-menu' returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun x-popup-menu (position menu))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.fileio" name="deuce.emacs.fileio"><h1 class="project-name">deuce.emacs.fileio</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.fileio
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [clojure.java.io :as io]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.eval :as eval]
            [deuce.emacs.editfns :as editfns])
  (:import [java.nio.file Files LinkOption
            NoSuchFileException]
           [deuce.emacs.data Buffer BufferText])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>*Coding system for encoding file names.
  If it is nil, `default-file-name-coding-system' (which see) is used.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar file-name-coding-system nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, a function to call to decide a coding system of file.
  Two arguments are passed to this function: the file name
  and the length of a file contents following the point.
  This function should return a coding system to decode the file contents.
  It should check the file name against `auto-coding-alist'.
  If no coding system is decided, it should check a coding system
  specified in the heading lines with the format:
    -<em>- ... coding: CODING-SYSTEM; ... -</em>-
  or local variable spec of the tailing lines with `coding:' tag.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar set-auto-coding-function nil)</pre></td></tr><tr><td class="docs"><p>Specifies whether to use the system's trash can.
  When non-nil, certain file deletion commands use the function
  `move-file-to-trash' instead of deleting files outright.
  This includes interactive calls to `delete-file' and
  `delete-directory' and the Dired deletion commands.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar delete-by-moving-to-trash nil)</pre></td></tr><tr><td class="docs"><p>File name in which we write a list of all auto save file names.
  This variable is initialized automatically from `auto-save-list-file-prefix'
  shortly after Emacs reads your `.emacs' file, if you have not yet given it
  a non-nil value.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-save-list-file-name nil)</pre></td></tr><tr><td class="docs"><p>Default coding system for encoding file names.
  This variable is used only when `file-name-coding-system' is nil.</p>

<p>  This variable is set/changed by the command `set-language-environment'.
  User should not set this variable manually,
  instead use `file-name-coding-system' to get a constant encoding
  of file names regardless of the current language environment.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-file-name-coding-system nil)</pre></td></tr><tr><td class="docs"><p>When an annotation function is called, this holds the previous annotations.
  These are the annotations made by other annotation functions
  that were already called.  See also `write-region-annotate-functions'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar write-region-annotations-so-far nil)</pre></td></tr><tr><td class="docs"><p>The operation for which `inhibit-file-name-handlers' is applicable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-file-name-operation nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means don't call fsync in `write-region'.
  This variable affects calls to `write-region' as well as save commands.
  A non-nil value may result in data loss!</p>
</td><td class="codes"><pre class="brush: clojure">(defvar write-region-inhibit-fsync nil)</pre></td></tr><tr><td class="docs"><p>Non-nil says auto-save a buffer in the file it is visiting, when practical.
  Normally auto-save files are written under other names.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-save-visited-file-name nil)</pre></td></tr><tr><td class="docs"><p>A list of functions to be called at the start of `write-region'.
  Each is passed two arguments, START and END as for `write-region'.
  These are usually two numbers but not always; see the documentation
  for `write-region'.  The function should return a list of pairs
  of the form (POSITION . STRING), consisting of strings to be effectively
  inserted at the specified positions of the file being written (1 means to
  insert before the first byte written).  The POSITIONs must be sorted into
  increasing order.</p>

<p>  If there are several annotation functions, the lists returned by these
  functions are merged destructively.  As each annotation function runs,
  the variable `write-region-annotations-so-far' contains a list of all
  annotations returned by previous annotation functions.</p>

<p>  An annotation function can return with a different buffer current.
  Doing so removes the annotations returned by previous functions, and
  resets START and END to <code>point-min' and</code>point-max' of the new buffer.</p>

<p>  After `write-region' completes, Emacs calls the function stored in
  `write-region-post-annotation-function', once for each buffer that was
  current when building the annotations (i.e., at least once), with that
  buffer current.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar write-region-annotate-functions nil)</pre></td></tr><tr><td class="docs"><p>Alist of elements (REGEXP . HANDLER) for file names handled specially.
  If a file name matches REGEXP, all I/O on that file is done by calling
  HANDLER.  If a file name matches more than one handler, the handler
  whose match starts last in the file name gets precedence.  The
  function `find-file-name-handler' checks this list for a handler for
  its argument.</p>

<p>  HANDLER should be a function.  The first argument given to it is the
  name of the I/O primitive to be handled; the remaining arguments are
  the arguments that were passed to that primitive.  For example, if you
  do (file-exists-p FILENAME) and FILENAME is handled by HANDLER, then
  HANDLER is called like this:</p>

<pre><code>(funcall HANDLER 'file-exists-p FILENAME)
</code></pre>

<p>  Note that HANDLER must be able to handle all I/O primitives; if it has
  nothing special to do for a primitive, it should reinvoke the
  primitive to handle the operation "the usual way".
  See Info node `(elisp)Magic File Names' for more details.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar file-name-handler-alist nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, auto-save even if a large part of the text is deleted.
  If nil, deleting a substantial portion of the text disables auto-save
  in the buffer; this is the default behavior, because the auto-save
  file is usually more useful if it contains the deleted text.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-save-include-big-deletions nil)</pre></td></tr><tr><td class="docs"><p>A list of functions to be called at the end of `insert-file-contents'.
  Each is passed one argument, the number of characters inserted,
  with point at the start of the inserted text.  Each function
  should leave point the same, and return the new character count.
  If `insert-file-contents' is intercepted by a handler from
  `file-name-handler-alist', that handler is responsible for calling the
  functions in `after-insert-file-functions' if appropriate.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar after-insert-file-functions nil)</pre></td></tr><tr><td class="docs"><p>A list of file name handlers that temporarily should not be used.
  This applies only to the operation `inhibit-file-name-operation'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-file-name-handlers nil)</pre></td></tr><tr><td class="docs"><p>Function to call after `write-region' completes.
  The function is called with no arguments.  If one or more of the
  annotation functions in `write-region-annotate-functions' changed the
  current buffer, the function stored in this variable is called for
  each of those additional buffers as well, in addition to the original
  buffer.  The relevant buffer is current during each function call.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar write-region-post-annotation-function nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare expand-file-name file-name-as-directory)</pre></td></tr><tr><td class="docs"><p>Clear any record of a recent auto-save failure in the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun clear-buffer-auto-save-failure ())</pre></td></tr><tr><td class="docs"><p>Return t if file FILENAME specifies an absolute file name.
  On Unix, this is a name starting with a <code>/' or a</code>~'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-name-absolute-p (filename)
  (el/check-type 'stringp filename)
  (when (re-find #&quot;^[/~]&quot; filename)
    true))</pre></td></tr><tr><td class="docs"><p>Update buffer's recorded modification time from the visited file's time.
  Useful if the buffer was not read from the file normally
  or if the file itself has been changed for some known benign reason.
  An argument specifies the modification time value to use
  (instead of that of the visited file), in the form of a list
  (HIGH . LOW) or (HIGH LOW).</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-visited-file-modtime (&amp;optional time-list))</pre></td></tr><tr><td class="docs"><p>Set the file permission bits for newly created files.
  The argument MODE should be an integer; only the low 9 bits are used.
  This setting is inherited by subprocesses.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-default-file-modes (mode))</pre></td></tr><tr><td class="docs"><p>Return t if file FILENAME can be written or created by you.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-writable-p (filename)
  (el/check-type 'stringp filename)
  (Files/isWritable (.toPath (io/file (expand-file-name filename)))))</pre></td></tr><tr><td class="docs"><p>Return t if (car A) is numerically less than (car B).</p>
</td><td class="codes"><pre class="brush: clojure">(defun car-less-than-car (a b))</pre></td></tr><tr><td class="docs"><p>Convert filename NAME to absolute, and canonicalize it.
  Second arg DEFAULT-DIRECTORY is directory to start with if NAME is relative
  (does not start with slash or tilde); if DEFAULT-DIRECTORY is nil or missing,
  the current buffer's value of `default-directory' is used.
  NAME should be a string that is a valid file name for the underlying
  filesystem.
  File name components that are `.' are removed, and
  so are file name components followed by <code>..', along with the</code>..' itself;
  note that these simplifications are done without checking the resulting
  file names in the file system.
  Multiple consecutive slashes are collapsed into a single slash,
  except at the beginning of the file name when they are significant (e.g.,
  UNC file names on MS-Windows.)
  An initial `~/' expands to your home directory.
  An initial `~USER/' expands to USER's home directory.
  See also the function `substitute-in-file-name'.</p>

<p>  For technical reasons, this function can return correct but
  non-intuitive results for the root directory; for instance,
  (expand-file-name ".." "/") returns "/..".  For this reason, use
  (directory-file-name (file-name-directory dirname)) to traverse a
  filesystem tree, not (expand-file-name ".."  dirname).</p>
</td><td class="codes"><pre class="brush: clojure">(defun expand-file-name (name &amp;optional default-directory)
  (el/check-type 'stringp name)
  (let [directory (or default-directory (data/symbol-value 'default-directory))]
    (if-let [resource (io/resource (str (file-name-as-directory directory) name))]
      (.getPath resource)
      (let [home (file-name-as-directory (System/getProperty &quot;user.home&quot;))
            file (io/file (s/replace name #&quot;^~&quot; home))
            file (if (.isAbsolute file)
                   file
                   (io/file directory name))]
        (if-not (.exists file) ;; Assume its classpath relative dir.
          (str (file-name-as-directory directory) name)
          (.getCanonicalPath file))))))</pre></td></tr><tr><td class="docs"><p>Write current region into specified file.
  When called from a program, requires three arguments:
  START, END and FILENAME.  START and END are normally buffer positions
  specifying the part of the buffer to write.
  If START is nil, that means to use the entire buffer contents.
  If START is a string, then output that string to the file
  instead of any buffer contents; END is ignored.</p>

<p>  Optional fourth argument APPEND if non-nil means
    append to existing file contents (if any).  If it is an integer,
    seek to that offset in the file before writing.
  Optional fifth argument VISIT, if t or a string, means
    set the last-save-file-modtime of buffer to this file's modtime
    and mark buffer not modified.
  If VISIT is a string, it is a second file name;
    the output goes to FILENAME, but the buffer is marked as visiting VISIT.
    VISIT is also the file name to lock and unlock for clash detection.
  If VISIT is neither t nor nil nor a string,
    that means do not display the "Wrote file" message.
  The optional sixth arg LOCKNAME, if non-nil, specifies the name to
    use for locking and unlocking, overriding FILENAME and VISIT.
  The optional seventh arg MUSTBENEW, if non-nil, insists on a check
    for an existing file with the same name.  If MUSTBENEW is `excl',
    that means to get an error if the file already exists; never overwrite.
    If MUSTBENEW is neither nil nor `excl', that means ask for
    confirmation before overwriting, but do go ahead and overwrite the file
    if the user confirms.</p>

<p>  This does code conversion according to the value of
  <code>coding-system-for-write',</code>buffer-file-coding-system', or
  `file-coding-system-alist', and sets the variable
  `last-coding-system-used' to the coding system actually used.</p>

<p>  This calls `write-region-annotate-functions' at the start, and
  `write-region-post-annotation-function' at the end.</p>
</td><td class="codes"><pre class="brush: clojure">(defun write-region (start end filename &amp;optional append visit lockname mustbenew)
  (interactive &quot;r\nFWrite region to file: \ni\ni\ni\np&quot;))</pre></td></tr><tr><td class="docs"><p>Return t if file FILENAME exists (whether or not you can read it.)
  See also <code>file-readable-p' and</code>file-attributes'.
  This returns nil for a symlink to a nonexistent file.
  Use `file-symlink-p' to test for such links.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-exists-p (filename)
  (.exists (io/file (expand-file-name filename))))</pre></td></tr><tr><td class="docs"><p>Set SELinux context of file named FILENAME to CONTEXT.
  CONTEXT should be a list (USER ROLE TYPE RANGE), where the list
  elements are strings naming the components of a SELinux context.</p>

<p>  This function does nothing if SELinux is disabled, or if Emacs was not
  compiled with SELinux support.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-file-selinux-context (filename context))</pre></td></tr><tr><td class="docs"><p>Auto-save all buffers that need it.
  This is all buffers that have auto-saving enabled
  and are changed since last auto-saved.
  Auto-saving writes the buffer into a file
  so that your editing is not lost if the system crashes.
  This file is not the file you visited; that changes only when you save.
  Normally we run the normal hook `auto-save-hook' before saving.</p>

<p>  A non-nil NO-MESSAGE argument means do not print any message if successful.
  A non-nil CURRENT-ONLY argument means save only current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun do-auto-save (&amp;optional no-message current-only)
  (interactive))</pre></td></tr><tr><td class="docs"><p>Return SELinux context of file named FILENAME.
  The return value is a list (USER ROLE TYPE RANGE), where the list
  elements are strings naming the user, role, type, and range of the
  file's SELinux security context.</p>

<p>  Return (nil nil nil nil) if the file is nonexistent or inaccessible,
  or if SELinux is disabled, or if Emacs lacks SELinux support.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-selinux-context (filename))</pre></td></tr><tr><td class="docs"><p>Delete the directory named DIRECTORY.  Does not follow symlinks.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-directory-internal (directory))</pre></td></tr><tr><td class="docs"><p>Return FILENAME's handler function for OPERATION, if it has one.
  Otherwise, return nil.
  A file name is handled if one of the regular expressions in
  `file-name-handler-alist' matches it.</p>

<p>  If OPERATION equals `inhibit-file-name-operation', then we ignore
  any handlers that are members of `inhibit-file-name-handlers',
  but we still do run any other handlers.  This lets handlers
  use the standard functions without calling themselves recursively.</p>
</td><td class="codes"><pre class="brush: clojure">(defun find-file-name-handler (filename operation))</pre></td></tr><tr><td class="docs"><p>Rename FILE as NEWNAME.  Both args must be strings.
  If file has names other than FILE, it continues to have those names.
  Signals a `file-already-exists' error if a file NEWNAME already exists
  unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.
  A number as third arg means request confirmation if NEWNAME already exists.
  This is what happens in interactive use with M-x.</p>
</td><td class="codes"><pre class="brush: clojure">(defun rename-file (file newname &amp;optional ok-if-already-exists)
  (interactive &quot;fRename file: \nGRename %s to file: \np&quot;))</pre></td></tr><tr><td class="docs"><p>Make a symbolic link to FILENAME, named LINKNAME.
  Both args must be strings.
  Signals a `file-already-exists' error if a file LINKNAME already exists
  unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.
  A number as third arg means request confirmation if LINKNAME already exists.
  This happens for interactive use with M-x.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-symbolic-link (filename linkname &amp;optional ok-if-already-exists)
  (interactive &quot;FMake symbolic link to file: \nGMake symbolic link to file %s: \np&quot;))</pre></td></tr><tr><td class="docs"><p>Return the default file protection for created files.
  The value is an integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun default-file-modes ())</pre></td></tr><tr><td class="docs"><p>Clear out records of last mod time of visited file.
  Next attempt to save will certainly not complain of a discrepancy.</p>
</td><td class="codes"><pre class="brush: clojure">(defun clear-visited-file-modtime ())</pre></td></tr><tr><td class="docs"><p>Return the current buffer's recorded visited file modification time.
  The value is a list of the form (HIGH LOW), like the time values that
  `file-attributes' returns.  If the current buffer has no recorded file
  modification time, this function returns 0.  If the visited file
  doesn't exist, HIGH will be -1.
  See Info node `(elisp)Modification Time' for more details.</p>
</td><td class="codes"><pre class="brush: clojure">(defun visited-file-modtime ())</pre></td></tr><tr><td class="docs"><p>Tell Unix to finish all pending disk updates.</p>
</td><td class="codes"><pre class="brush: clojure">(defun unix-sync ()
  (interactive))</pre></td></tr><tr><td class="docs"><p>Return t if last mod time of BUF's visited file matches what BUF records.
  This means that the file has not been changed since it was visited or saved.
  If BUF is omitted or nil, it defaults to the current buffer.
  See Info node `(elisp)Modification Time' for more details.</p>
</td><td class="codes"><pre class="brush: clojure">(defun verify-visited-file-modtime (&amp;optional buf))</pre></td></tr><tr><td class="docs"><p>Returns the file name of the directory named DIRECTORY.
  This is the name of the file that holds the data for the directory DIRECTORY.
  This operation exists because a directory is also a file, but its name as
  a directory is different from its name as a file.
  In Unix-syntax, this function just removes the final slash.</p>
</td><td class="codes"><pre class="brush: clojure">(defun directory-file-name (directory)
  (el/check-type 'stringp directory)
  (if (= &quot;/&quot; directory)
    directory
    (if (re-find #&quot;/$&quot; directory)
      (subs directory 0 (dec (count directory)))
      directory)))</pre></td></tr><tr><td class="docs"><p>Create a new directory named DIRECTORY.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-directory-internal (directory))</pre></td></tr><tr><td class="docs"><p>Return t if file FILE1 is newer than file FILE2.
  If FILE1 does not exist, the answer is nil;
  otherwise, if FILE2 does not exist, the answer is t.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-newer-than-file-p (file1 file2))</pre></td></tr><tr><td class="docs"><p>Return t if file FILENAME exists and you can read it.
  See also <code>file-exists-p' and</code>file-attributes'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-readable-p (filename)
  (el/check-type 'stringp filename)
  (Files/isReadable (.toPath (io/file (expand-file-name filename)))))</pre></td></tr><tr><td class="docs"><p>Delete file named FILENAME.  If it is a symlink, remove the symlink.
  If file has multiple names, it continues to exist with the other names.
  TRASH non-nil means to trash the file instead of deleting, provided
  `delete-by-moving-to-trash' is non-nil.</p>

<p>  When called interactively, TRASH is t if no prefix argument is given.
  With a prefix argument, TRASH is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-file (filename &amp;optional trash)
  (interactive &quot;(list (read-file-name (if (and delete-by-moving-to-trash (null current-prefix-arg)) \&quot;Move file to trash: \&quot; \&quot;Delete file: \&quot;) nil default-directory (confirm-nonexistent-file-or-buffer)) (null current-prefix-arg))&quot;))</pre></td></tr><tr><td class="docs"><p>Return t if FILENAME can be executed by you.
  For a directory, this means you can access files in that directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-executable-p (filename)
  (el/check-type 'stringp filename)
  (Files/isExecutable (.toPath (io/file (expand-file-name filename)))))</pre></td></tr><tr><td class="docs"><p>Generate temporary file name (string) starting with PREFIX (a string).
  The Emacs process number forms part of the result,
  so there is no danger of generating a name being used by another process.</p>

<p>  In addition, this function makes an attempt to choose a name
  which has no existing file.  To make this work,
  PREFIX should be an absolute file name.</p>

<p>  There is a race condition between calling `make-temp-name' and creating the
  file which opens all kinds of security holes.  For that reason, you should
  probably use `make-temp-file' instead, except in three circumstances:</p>

<ul>
<li>If you are creating the file in the user's home directory.</li>
<li>If you are creating a directory rather than an ordinary file.</li>
<li>If you are taking special precautions as `make-temp-file' does.</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defun make-temp-name (prefix))</pre></td></tr><tr><td class="docs"><p>Access file FILENAME, and get an error if that does not work.
  The second argument STRING is used in the error message.
  If there is no error, returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun access-file (filename string))</pre></td></tr><tr><td class="docs"><p>Give FILE additional name NEWNAME.  Both args must be strings.
  Signals a `file-already-exists' error if a file NEWNAME already exists
  unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.
  A number as third arg means request confirmation if NEWNAME already exists.
  This is what happens in interactive use with M-x.</p>
</td><td class="codes"><pre class="brush: clojure">(defun add-name-to-file (file newname &amp;optional ok-if-already-exists)
  (interactive &quot;fAdd name to file: \nGName to add to %s: \np&quot;))</pre></td></tr><tr><td class="docs"><p>Return t if current buffer has been auto-saved recently.
  More precisely, if it has been auto-saved since last read from or saved
  in the visited file.  If the buffer has no visited file,
  then any auto-save counts as "recent".</p>
</td><td class="codes"><pre class="brush: clojure">(defun recent-auto-save-p ())</pre></td></tr><tr><td class="docs"><p>Insert contents of file FILENAME after point.
  Returns list of absolute file name and number of characters inserted.
  If second argument VISIT is non-nil, the buffer's visited filename and
  last save file modtime are set, and it is marked unmodified.  If
  visiting and the file does not exist, visiting is completed before the
  error is signaled.</p>

<p>  The optional third and fourth arguments BEG and END specify what portion
  of the file to insert.  These arguments count bytes in the file, not
  characters in the buffer.  If VISIT is non-nil, BEG and END must be nil.</p>

<p>  If optional fifth argument REPLACE is non-nil, replace the current
  buffer contents (in the accessible portion) with the file contents.
  This is better than simply deleting and inserting the whole thing
  because (1) it preserves some marker positions and (2) it puts less data
  in the undo list.  When REPLACE is non-nil, the second return value is
  the number of characters that replace previous buffer contents.</p>

<p>  This function does code conversion according to the value of
  <code>coding-system-for-read' or</code>file-coding-system-alist', and sets the
  variable `last-coding-system-used' to the coding system actually used.</p>
</td><td class="codes"><pre class="brush: clojure">(defun insert-file-contents (filename &amp;optional visit beg end replace)
  (let [file (let [file (io/file (expand-file-name filename))]
               (if (.exists file)
                 (.toURL file)
                 (io/resource filename)))
        contents (slurp file)
        contents (if (and visit beg end)
                   (subs contents beg end)
                   contents)
        path (.getPath file)
        point (editfns/point)]
    (editfns/insert contents)
    (when visit
      (reset! (.save-modiff ^BufferText (.text ^Buffer (buffer/current-buffer))) (System/currentTimeMillis))
      ;; These vars are buffer local.
      (el/setq buffer-file-name path)
      (el/setq buffer-file-truename filename) ; Might be correct, should be result of files/file-truename.
      (el/setq buffer-saved-size (count contents)))
    (doseq [f (data/symbol-value 'after-insert-file-functions)]
      (editfns/goto-char 1)
      (eval/funcall f (count contents)))
    (editfns/goto-char point)
    (list path (count contents))))</pre></td></tr><tr><td class="docs"><p>Return file name FILENAME sans its directory.
  For example, in a Unix-syntax file name,
  this is everything after the last slash,
  or the entire name if it contains no slash.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-name-nondirectory (filename)
  (el/check-type 'stringp filename)
  (if (re-find #&quot;/$&quot; filename)
    &quot;&quot;
    (.getName (io/file filename))))</pre></td></tr><tr><td class="docs"><p>Substitute environment variables referred to in FILENAME.
  `$FOO' where FOO is an environment variable name means to substitute
  the value of that variable.  The variable name should be terminated
  with a character not a letter, digit or underscore; otherwise, enclose
  the entire variable name in braces.</p>

<p>  If <code>/~' appears, all of FILENAME through that</code>/' is discarded.
  If `//' appears, everything up to and including the first of
  those `/' is discarded.</p>
</td><td class="codes"><pre class="brush: clojure">(defun substitute-in-file-name (filename)
  (let [filename (-&gt; filename
                     (s/replace #&quot;.+(~/.+)&quot; &quot;$1&quot;)
                     (s/replace #&quot;.+/(/.+)&quot; &quot;$1&quot;))
        vars (re-seq #&quot;\$(\w+|\{.+\})&quot; filename)]
    (reduce #(s/replace %1 (first %2) (System/getenv (second %2))) filename vars)))</pre></td></tr><tr><td class="docs"><p>Return t if FILENAME names an existing directory.
  Symbolic links to directories count as directories.
  See `file-symlink-p' to distinguish symlinks.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-directory-p (filename)
  (el/check-type 'stringp filename)
  (.isDirectory (io/file (expand-file-name filename))))</pre></td></tr><tr><td class="docs"><p>Mark current buffer as auto-saved with its current text.
  No auto-save file will be written until the buffer changes again.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-buffer-auto-saved ())</pre></td></tr><tr><td class="docs"><p>Set times of file FILENAME to TIMESTAMP.
  Set both access and modification times.
  Return t on success, else nil.
  Use the current time if TIMESTAMP is nil.  TIMESTAMP is in the format of
  `current-time'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-file-times (filename &amp;optional timestamp))</pre></td></tr><tr><td class="docs"><p>Set mode bits of file named FILENAME to MODE (an integer).
  Only the 12 low bits of MODE are used.</p>

<p>  Interactively, mode bits are read by `read-file-modes', which accepts
  symbolic notation, like the `chmod' command from GNU Coreutils.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-file-modes (filename mode)
  (interactive &quot;(let ((file (read-file-name \&quot;File: \&quot;))) (list file (read-file-modes nil file)))&quot;))</pre></td></tr><tr><td class="docs"><p>Return t if file FILENAME names a directory you can open.
  For the value to be t, FILENAME must specify the name of a directory as a file,
  and the directory must allow you to open files in it.  In order to use a
  directory as a buffer's current directory, this predicate must return true.
  A directory name spec may be given instead; then the value is t
  if the directory so specified exists and really is a readable and
  searchable directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-accessible-directory-p (filename)
  (el/check-type 'stringp filename)
  (file-directory-p filename))</pre></td></tr><tr><td class="docs"><p>Return a string representing the file name FILE interpreted as a directory.
  This operation exists because a directory is also a file, but its name as
  a directory is different from its name as a file.
  The result can be used as the value of `default-directory'
  or passed as second argument to `expand-file-name'.
  For a Unix-syntax file name, just appends a slash.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-name-as-directory (file)
  (el/check-type 'stringp file)
  (if (re-find #&quot;/$&quot; file)
    file
    (str file &quot;/&quot;)))</pre></td></tr><tr><td class="docs"><p>Copy FILE to NEWNAME.  Both args must be strings.
  If NEWNAME names a directory, copy FILE there.</p>

<p>  This function always sets the file modes of the output file to match
  the input file.</p>

<p>  The optional third argument OK-IF-ALREADY-EXISTS specifies what to do
  if file NEWNAME already exists.  If OK-IF-ALREADY-EXISTS is nil, we
  signal a `file-already-exists' error without overwriting.  If
  OK-IF-ALREADY-EXISTS is a number, we request confirmation from the user
  about overwriting; this is what happens in interactive use with M-x.
  Any other value for OK-IF-ALREADY-EXISTS means to overwrite the
  existing file.</p>

<p>  Fourth arg KEEP-TIME non-nil means give the output file the same
  last-modified time as the old one.  (This works on only some systems.)</p>

<p>  A prefix arg makes KEEP-TIME non-nil.</p>

<p>  If PRESERVE-UID-GID is non-nil, we try to transfer the
  uid and gid of FILE to NEWNAME.</p>

<p>  If PRESERVE-SELINUX-CONTEXT is non-nil and SELinux is enabled
  on the system, we copy the SELinux context of FILE to NEWNAME.</p>
</td><td class="codes"><pre class="brush: clojure">(defun copy-file (file newname &amp;optional ok-if-already-exists keep-time preserve-uid-gid preserve-selinux-context)
  (interactive &quot;fCopy file: \nGCopy %s to file: \np\nP&quot;))</pre></td></tr><tr><td class="docs"><p>Return t if FILENAME names a regular file.
  This is the sort of file that holds an ordinary stream of data bytes.
  Symbolic links to regular files count as regular files.
  See `file-symlink-p' to distinguish symlinks.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-regular-p (filename)
  (el/check-type 'stringp filename)
  (Files/isRegularFile (.toPath (io/file (expand-file-name filename))) (make-array LinkOption 0)))</pre></td></tr><tr><td class="docs"><p>Return the directory component in file name FILENAME.
  Return nil if FILENAME does not include a directory.
  Otherwise return a directory name.
  Given a Unix syntax file name, returns a string ending in slash.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-name-directory (filename)
  (el/check-type 'stringp filename)
  (if (re-find #&quot;/$&quot; filename)
    filename
    (when-let [parent (and (seq filename)
                           (.getParent (if-let [resource (io/resource filename)]
                                         (io/file (.getFile resource)) ;; Terrible hack, reason is lread/locate-file-internal
                                         (io/file filename))))]
      (file-name-as-directory parent))))</pre></td></tr><tr><td class="docs"><p>Return non-nil if file FILENAME is the name of a symbolic link.
  The value is the link target, as a string.
  Otherwise it returns nil.</p>

<p>  This function returns t when given the name of a symlink that
  points to a nonexistent file.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-symlink-p (filename)
  (el/check-type 'stringp filename)
  (let [path (.toPath (io/file (expand-file-name filename)))]
    (when (Files/isSymbolicLink path)
      (try
        (str (.toRealPath path (make-array LinkOption 0)))
        (catch NoSuchFileException _
          true)))))</pre></td></tr><tr><td class="docs"><p>Return a directly usable directory name somehow associated with FILENAME.
  A `directly usable' directory name is one that may be used without the
  intervention of any file handler.
  If FILENAME is a directly usable file itself, return
  (file-name-directory FILENAME).
  If FILENAME refers to a file which is not accessible from a local process,
  then this should return nil.
  The <code>call-process' and</code>start-process' functions use this function to
  get a current directory to run processes in.</p>
</td><td class="codes"><pre class="brush: clojure">(defun unhandled-file-name-directory (filename))</pre></td></tr><tr><td class="docs"><p>Return mode bits of file named FILENAME, as an integer.
  Return nil, if file does not exist or is not accessible.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-modes (filename))</pre></td></tr><tr><td class="docs"><p>Return t if a call to `read-file-name' will use a dialog.
  The return value is only relevant for a call to `read-file-name' that happens
  before any other event (mouse or keypress) is handled.</p>
</td><td class="codes"><pre class="brush: clojure">(defun next-read-file-uses-dialog-p ())</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.window" name="deuce.emacs.window"><h1 class="project-name">deuce.emacs.window</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.window
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.frame :as frame]
            [deuce.emacs-lisp.cons :as cons])
  (:import [deuce.emacs.data Buffer Frame Window Marker])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>If t, splitting a window makes a new parent window.
  If this variable is nil, splitting a window will create a new parent
  window only if the window has no parent window or the window shall
  become a combination orthogonal to the one it is part of.</p>

<p>  If this variable is t, splitting a window always creates a new parent
  window.  If all splits behave this way, each frame's window tree is a
  binary tree and every window but the frame's root window has exactly one
  sibling.</p>

<p>  Other values are reserved for future use.</p>

<p>  The value of this variable is also assigned to the combination limit of
  the new parent window.  The combination limit of a window can be
  retrieved via the function `window-combination-limit' and altered by the
  function `set-window-combination-limit'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar window-combination-limit nil)</pre></td></tr><tr><td class="docs"><p>Functions to call when window configuration changes.
  The buffer-local part is run once per window, with the relevant window
  selected; while the global part is run only once for the modified frame,
  with the relevant frame selected.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar window-configuration-change-hook nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, this is a buffer and C-M-v should scroll its window.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar other-window-scroll-buffer nil)</pre></td></tr><tr><td class="docs"><p>Alist of persistent window parameters.
  This alist specifies which window parameters shall get saved by
  <code>current-window-configuration' and</code>window-state-get' and subsequently
  restored to their previous values by `set-window-configuration' and
  `window-state-put'.</p>

<p>  The car of each entry of this alist is the symbol specifying the
  parameter.  The cdr is one of the following:</p>

<p>  nil means the parameter is neither saved by `window-state-get' nor by
  `current-window-configuration'.</p>

<p>  t means the parameter is saved by `current-window-configuration' and,
  provided its WRITABLE argument is nil, by `window-state-get'.</p>

<p>  The symbol `writable' means the parameter is saved unconditionally by
  both <code>current-window-configuration' and</code>window-state-get'.  Do not use
  this value for parameters without read syntax (like windows or frames).</p>

<p>  Parameters not saved by `current-window-configuration' or
  <code>window-state-get' are left alone by</code>set-window-configuration'
  respectively are not installed by `window-state-put'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar window-persistent-parameters '((clone-of . true)))</pre></td></tr><tr><td class="docs"><p>Non-nil means it is the window that C-M-v in minibuffer should scroll.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-scroll-window nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means to automatically adjust `window-vscroll' to view tall lines.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-window-vscroll true)</pre></td></tr><tr><td class="docs"><p>Non-nil means to use `mode-line-inactive' face in non-selected windows.
  If the minibuffer is active, the `minibuffer-scroll-window' mode line
  is displayed in the `mode-line' face.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar mode-line-in-non-selected-windows true)</pre></td></tr><tr><td class="docs"><p>Non-nil means call as function to display a help buffer.
  The function is called with one argument, the buffer to be displayed.
  Used by `with-output-to-temp-buffer'.
  If this function is used, then it must do the entire job of showing
  the buffer; `temp-buffer-show-hook' is not run unless this function runs it.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar temp-buffer-show-function nil)</pre></td></tr><tr><td class="docs"><p>Number of lines of continuity when scrolling by screenfuls.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar next-screen-context-lines 2)</pre></td></tr><tr><td class="docs"><p>Type of marker to use for `window-point'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar window-point-insertion-type nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means `recenter' redraws entire frame.
  If this option is non-nil, then the `recenter' command with a nil
  argument will redraw the entire frame; the special value `tty' causes
  the frame to be redrawn only if it is a tty frame.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar recenter-redisplay 'tty)</pre></td></tr><tr><td class="docs"><p>Controls if scroll commands move point to keep its screen position unchanged.
  A value of nil means point does not keep its screen position except
  at the scroll margin or window boundary respectively.
  A value of t means point keeps its screen position if the scroll
  command moved it vertically out of the window, e.g. when scrolling
  by full screens.
  Any other value means point always keeps its screen position.
  Scroll commands should have the `scroll-command' property
  on their symbols to be controlled by this variable.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar scroll-preserve-screen-position nil)</pre></td></tr><tr><td class="docs"><p>If t, resize window combinations proportionally.
  If this variable is nil, splitting a window gets the entire screen space
  for displaying the new window from the window to split.  Deleting and
  resizing a window preferably resizes one adjacent window only.</p>

<p>  If this variable is t, splitting a window tries to get the space
  proportionally from all windows in the same combination.  This also
  allows to split a window that is otherwise too small or of fixed size.
  Resizing and deleting a window proportionally resize all windows in the
  same combination.</p>

<p>  Other values are reserved for future use.</p>

<p>  This variable takes no effect if `window-combination-limit' is non-nil.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar window-combination-resize nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare windowp window-minibuffer-p window-frame selected-window window-buffer)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private sequence-number (atom 0))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private window-prev-buffers-list (atom {}))
(def ^:private window-next-buffers-list (atom {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private allocate-window [minibuffer? parent leftcol top-line total-cols total-lines]
  (let [[next prev hchild vchild
         buffer start pointm] (repeatedly #(atom nil))
         normal-lines (atom 1.0)
         normal-cols (atom 1.0)]
    (Window. minibuffer? next prev hchild vchild (atom parent)
             (atom leftcol) (atom top-line) (atom total-lines) (atom total-cols)
             normal-lines normal-cols buffer start pointm (swap! sequence-number inc))))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a live window and nil otherwise.
  A live window is a window that displays a buffer.
  Internal windows and deleted windows are not live.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-live-p (object)
  (and (windowp object) @(.buffer ^Window object)))</pre></td></tr><tr><td class="docs"><p>Return combination limit of window WINDOW.
  If the return value is nil, child windows of WINDOW can be recombined with
  WINDOW's siblings.  A return value of t means that child windows of
  WINDOW are never (re-)combined with WINDOW's siblings.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-combination-limit (window))</pre></td></tr><tr><td class="docs"><p>Return the total width, in columns, of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.</p>

<p>  The return value includes any vertical dividers or scroll bars
  belonging to WINDOW.  If WINDOW is an internal window, the total width
  is the width of the screen areas spanned by its children.</p>

<p>  On a graphical display, this total width is reported as an
  integer multiple of the default character width.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-total-width (&amp;optional window)
  @(.total-cols ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Return the normal height of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.
  If HORIZONTAL is non-nil, return the normal width of WINDOW.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-normal-size (&amp;optional window horizontal)
  @(.normal-lines ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Scroll next window upward ARG lines; or near full screen if no ARG.
  A near full screen is `next-screen-context-lines' less than a full screen.
  The next window is the one below the current one; or the one at the top
  if the current one is at the bottom.  Negative ARG means scroll downward.
  If ARG is the atom `-', scroll downward by nearly full screen.
  When calling from a program, supply as argument a number, nil, or `-'.</p>

<p>  If `other-window-scroll-buffer' is non-nil, scroll the window
  showing that buffer, popping the buffer up if necessary.
  If in the minibuffer, `minibuffer-scroll-window' if non-nil
  specifies the window to scroll.  This takes precedence over
  `other-window-scroll-buffer'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun scroll-other-window (&amp;optional arg)
  (interactive &quot;P&quot;))</pre></td></tr><tr><td class="docs"><p>Return a list of the edge pixel coordinates of WINDOW's text area.
  The list has the form (LEFT TOP RIGHT BOTTOM), all relative to (0,0)
  at the top left corner of the frame's window area.</p>

<p>  RIGHT is one more than the rightmost x position of WINDOW's text area.
  BOTTOM is one more than the bottommost y position of WINDOW's text area.
  The inside edges do not include the space used by WINDOW's scroll bar,
  display margins, fringes, header line, and/or mode line.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-inside-absolute-pixel-edges (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Set number of columns WINDOW is scrolled from left margin to NCOL.
  If WINDOW is nil, the selected window is used.
  Return NCOL.  NCOL should be zero or positive.</p>

<p>  Note that if `automatic-hscrolling' is non-nil, you cannot scroll the
  window so that the location of point moves off-window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-hscroll (window ncol)
  ncol)</pre></td></tr><tr><td class="docs"><p>Center point in selected window and maybe redisplay frame.
  With prefix argument ARG, recenter putting point on screen line ARG
  relative to the selected window.  If ARG is negative, it counts up from the
  bottom of the window.  (ARG should be less than the height of the window.)</p>

<p>  If ARG is omitted or nil, then recenter with point on the middle line of
  the selected window; if the variable `recenter-redisplay' is non-nil,
  also erase the entire frame and redraw it (when `auto-resize-tool-bars'
  is set to `grow-only', this resets the tool-bar's height to the minimum
  height needed); if <code>recenter-redisplay' has the special value</code>tty',
  then only tty frames are redrawn.</p>

<p>  Just C-u as prefix means put point in the center of the window
  and redisplay normally--don't erase and redraw the frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun recenter (&amp;optional arg)
  (interactive &quot;P&quot;))</pre></td></tr><tr><td class="docs"><p>Scroll text of selected window down ARG lines.
  If ARG is omitted or nil, scroll down by a near full screen.
  A near full screen is `next-screen-context-lines' less than a full screen.
  Negative ARG means scroll upward.
  If ARG is the atom `-', scroll upward by nearly full screen.
  When calling from a program, supply as argument a number, nil, or `-'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun scroll-down (&amp;optional arg)
  (interactive &quot;^P&quot;))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a window-configuration object.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-configuration-p (object))</pre></td></tr><tr><td class="docs"><p>Return the minibuffer window for frame FRAME.
  If FRAME is omitted or nil, it defaults to the selected frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun minibuffer-window (&amp;optional frame)
  (let [^Frame frame (or frame (frame/selected-frame))]
    (.minibuffer-window frame)))</pre></td></tr><tr><td class="docs"><p>Scroll text of selected window upward ARG lines.
  If ARG is omitted or nil, scroll upward by a near full screen.
  A near full screen is `next-screen-context-lines' less than a full screen.
  Negative ARG means scroll downward.
  If ARG is the atom `-', scroll downward by nearly full screen.
  When calling from a program, supply as argument a number, nil, or `-'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun scroll-up (&amp;optional arg)
  (interactive &quot;^P&quot;))</pre></td></tr><tr><td class="docs"><p>Return the other window for "other window scroll" commands.
  If `other-window-scroll-buffer' is non-nil, a window
  showing that buffer is used.
  If in the minibuffer, `minibuffer-scroll-window' if non-nil
  specifies the window.  This takes precedence over
  `other-window-scroll-buffer'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun other-window-for-scrolling ())</pre></td></tr><tr><td class="docs"><p>Set WINDOW's display-table to TABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-display-table (window table))</pre></td></tr><tr><td class="docs"><p>Return the parent window of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.
  Return nil for a window with no parent (e.g. a root window).</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-parent (&amp;optional window)
  @(.parent ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Return non-nil if position POS is currently on the frame in WINDOW.
  Return nil if that position is scrolled vertically out of view.
  If a character is only partially visible, nil is returned, unless the
  optional argument PARTIALLY is non-nil.
  If POS is only out of view because of horizontal scrolling, return non-nil.
  If POS is t, it specifies the position of the last visible glyph in WINDOW.
  POS defaults to point in WINDOW; WINDOW defaults to the selected window.</p>

<p>  If POS is visible, return t if PARTIALLY is nil; if PARTIALLY is non-nil,
  return value is a list of 2 or 6 elements (X Y [RTOP RBOT ROWH VPOS]),
  where X and Y are the pixel coordinates relative to the top left corner
  of the window.  The remaining elements are omitted if the character after
  POS is fully visible; otherwise, RTOP and RBOT are the number of pixels
  off-window at the top and bottom of the row, ROWH is the height of the
  display row, and VPOS is the row number (0-based) containing POS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun pos-visible-in-window-p (&amp;optional pos window partially))</pre></td></tr><tr><td class="docs"><p>Resize minibuffer window WINDOW.</p>
</td><td class="codes"><pre class="brush: clojure">(defun resize-mini-window-internal (window))</pre></td></tr><tr><td class="docs"><p>Return position at which display currently ends in WINDOW.
  WINDOW must be a live window and defaults to the selected one.
  This is updated by redisplay, when it runs to completion.
  Simply changing the buffer text or setting `window-start'
  does not update this value.
  Return nil if there is no recorded value.  (This can happen if the
  last redisplay of WINDOW was preempted, and did not finish.)
  If UPDATE is non-nil, compute the up-to-date position
  if it isn't already recorded.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-end (&amp;optional window update))</pre></td></tr><tr><td class="docs"><p>Set width of marginal areas of window WINDOW.
  If WINDOW is nil, set margins of the currently selected window.
  Second arg LEFT-WIDTH specifies the number of character cells to
  reserve for the left marginal area.  Optional third arg RIGHT-WIDTH
  does the same for the right marginal area.  A nil width parameter
  means no margin.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-margins (window left-width &amp;optional right-width))</pre></td></tr><tr><td class="docs"><p>Make point value in WINDOW be at position POS in WINDOW's buffer.
  Return POS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-point (window pos)
  ;; There's an attempt to track this in set-window-buffer and select-window
  (el/check-type 'integerp pos)
  (let [window ^Window (el/check-type 'windowp (or window (selected-window)))]
    (reset! (.pointm window)  ((ns-resolve 'deuce.emacs.buffer 'allocate-marker) nil (window-buffer window) pos))
    (reset! (.pt ^Buffer (window-buffer window)) pos)))</pre></td></tr><tr><td class="docs"><p>Return current value of point in WINDOW.
  WINDOW must be a live window and defaults to the selected one.</p>

<p>  For a nonselected window, this is the value point would have
  if that window were selected.</p>

<p>  Note that, when WINDOW is the selected window and its buffer
  is also currently selected, the value returned is the same as (point).
  It would be more strictly correct to return the `top-level' value
  of point, outside of any save-excursion forms.
  But that is hard to define.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-point (&amp;optional window)
  ;; There's an attempt to track this in set-window-buffer and select-window
  (let [window (el/check-type 'windowp (or window (selected-window)))]
    (if-let [pointm (and (not= (selected-window) window) @(.pointm ^Window window))]
      (.charpos ^Marker pointm)
      @(.pt ^Buffer (window-buffer window)))))</pre></td></tr><tr><td class="docs"><p>Return a list of the edge pixel coordinates of WINDOW.
  The list has the form (LEFT TOP RIGHT BOTTOM), all relative to 0, 0 at
  the top left corner of the frame.</p>

<p>  RIGHT is one more than the rightmost x position occupied by WINDOW.
  BOTTOM is one more than the bottommost y position occupied by WINDOW.
  The pixel edges include the space used by WINDOW's scroll bar, display
  margins, fringes, header line, and/or mode line.  For the pixel edges
  of just the text area, use `window-inside-pixel-edges'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-pixel-edges (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return left column of window WINDOW.
  This is the distance, in columns, between the left edge of WINDOW and
  the left edge of the frame's window area.  For instance, the return
  value is 0 if there is no window to the left of WINDOW.</p>

<p>  If WINDOW is omitted or nil, it defaults to the selected window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-left-column (&amp;optional window)
  @(.left-col ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Return the next sibling window of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.
  Return nil if WINDOW has no next sibling.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-next-sibling (&amp;optional window)
  @(.next ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Return list of buffers recently re-shown in WINDOW.
  WINDOW must be a live window and defaults to the selected one.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-next-buffers (&amp;optional window)
  (cons/maybe-seq (@window-next-buffers-list (el/check-type 'windowp (or window (selected-window))))))</pre></td></tr><tr><td class="docs"><p>Set combination limit of window WINDOW to LIMIT; return LIMIT.
  If LIMIT is nil, child windows of WINDOW can be recombined with
  WINDOW's siblings.  LIMIT t means that child windows of WINDOW are
  never (re-)combined with WINDOW's siblings.  Other values are reserved
  for future use.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-combination-limit (window limit))</pre></td></tr><tr><td class="docs"><p>Set WINDOW's next buffers to NEXT-BUFFERS.
  WINDOW must be a live window and defaults to the selected one.
  NEXT-BUFFERS should be a list of buffers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-next-buffers (window next-buffers)
  (swap! window-next-buffers-list assoc (el/check-type 'windowp window) next-buffers)
  nil)</pre></td></tr><tr><td class="docs"><p>This function is obsolete since 23.1.</p>

<p>  Set WINDOW's redisplay end trigger value to VALUE.
  VALUE should be a buffer position (typically a marker) or nil.
  If it is a buffer position, then if redisplay in WINDOW reaches a position
  beyond VALUE, the functions in `redisplay-end-trigger-functions' are called
  with two arguments: WINDOW, and the end trigger value.
  Afterwards the end-trigger value is reset to nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-redisplay-end-trigger (window value))</pre></td></tr><tr><td class="docs"><p>Return an object representing the current window configuration of FRAME.
  If FRAME is nil or omitted, use the selected frame.
  This describes the number of windows, their sizes and current buffers,
  and for each displayed buffer, where display starts, and the positions of
  point and mark.  An exception is made for point in the current buffer:
  its value is -not- saved.
  This also records the currently selected frame, and FRAME's focus
  redirection (see `redirect-frame-focus').  The variable
  `window-persistent-parameters' specifies which window parameters are
  saved by this function.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-window-configuration (&amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Set WINDOW's value of PARAMETER to VALUE.
  WINDOW defaults to the selected window.  Return VALUE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-parameter (window parameter value))</pre></td></tr><tr><td class="docs"><p>Return non-nil if COORDINATES are in WINDOW.
  WINDOW must be a live window.
  COORDINATES is a cons of the form (X . Y), X and Y being distances
  measured in characters from the upper-left corner of the frame.
  (0 . 0) denotes the character in the upper left corner of the
  frame.
  If COORDINATES are in the text portion of WINDOW,
     the coordinates relative to the window are returned.
  If they are in the mode line of WINDOW, `mode-line' is returned.
  If they are in the top mode line of WINDOW, `header-line' is returned.
  If they are in the left fringe of WINDOW, `left-fringe' is returned.
  If they are in the right fringe of WINDOW, `right-fringe' is returned.
  If they are on the border between WINDOW and its right sibling,
    `vertical-line' is returned.
  If they are in the windows's left or right marginal areas, `left-margin'
    or `right-margin' is returned.</p>
</td><td class="codes"><pre class="brush: clojure">(defun coordinates-in-window-p (coordinates window))</pre></td></tr><tr><td class="docs"><p>Return top line of window WINDOW.
  This is the distance, in lines, between the top of WINDOW and the top
  of the frame's window area.  For instance, the return value is 0 if
  there is no window above WINDOW.</p>

<p>  If WINDOW is omitted or nil, it defaults to the selected window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-top-line (&amp;optional window)
  @(.top-line ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Return height in pixels of text line LINE in window WINDOW.
  WINDOW defaults to the selected window.</p>

<p>  Return height of current line if LINE is omitted or nil.  Return height of
  header or mode line if LINE is <code>header-line' or</code>mode-line'.
  Otherwise, LINE is a text line number starting from 0.  A negative number
  counts from the end of the window.</p>

<p>  Value is a list (HEIGHT VPOS YPOS OFFBOT), where HEIGHT is the height
  in pixels of the visible part of the line, VPOS and YPOS are the
  vertical position in lines and pixels of the line, relative to the top
  of the first text line, and OFFBOT is the number of off-window pixels at
  the bottom of the text line.  If there are off-window pixels at the top
  of the (first) text line, YPOS is negative.</p>

<p>  Return nil if window display is not up-to-date.  In that case, use
  `pos-visible-in-window-p' to obtain the information.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-line-height (&amp;optional line window))</pre></td></tr><tr><td class="docs"><p>Set width and type of scroll bars of window WINDOW.
  If window is nil, set scroll bars of the currently selected window.
  Second parameter WIDTH specifies the pixel width for the scroll bar;
  this is automatically adjusted to a multiple of the frame column width.
  Third parameter VERTICAL-TYPE specifies the type of the vertical scroll
  bar: left, right, or nil.
  If WIDTH is nil, use the frame's scroll-bar width.
  If VERTICAL-TYPE is t, use the frame's scroll-bar type.
  Fourth parameter HORIZONTAL-TYPE is currently unused.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-scroll-bars (window width &amp;optional vertical-type horizontal-type))</pre></td></tr><tr><td class="docs"><p>Run `window-configuration-change-hook' for FRAME.</p>
</td><td class="codes"><pre class="brush: clojure">(defun run-window-configuration-change-hook (frame))</pre></td></tr><tr><td class="docs"><p>Get width of marginal areas of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.
  Value is a cons of the form (LEFT-WIDTH . RIGHT-WIDTH).
  If a marginal area does not exist, its width will be returned
  as nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-margins (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Make WINDOW fill its frame.
  Only the frame WINDOW is on is affected.  WINDOW may be any window and
  defaults to the selected one.</p>

<p>  Optional argument ROOT, if non-nil, must specify an internal window such
  that WINDOW is in its window subtree.  If this is the case, replace ROOT
  by WINDOW and leave alone any windows not part of ROOT's subtree.</p>

<p>  When WINDOW is live try to reduce display jumps by keeping the text
  previously visible in WINDOW in the same place on the frame.  Doing this
  depends on the value of (window-start WINDOW), so if calling this
  function in a program gives strange scrolling, make sure the
  window-start value is reasonable when this function is called.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-other-windows-internal (&amp;optional window root)
  (interactive))</pre></td></tr><tr><td class="docs"><p>Return a list of the edge pixel coordinates of WINDOW's text area.
  The list has the form (LEFT TOP RIGHT BOTTOM), all relative to (0,0)
  at the top left corner of the frame's window area.</p>

<p>  RIGHT is one more than the rightmost x position of WINDOW's text area.
  BOTTOM is one more than the bottommost y position of WINDOW's text area.
  The inside edges do not include the space used by WINDOW's scroll bar,
  display margins, fringes, header line, and/or mode line.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-inside-pixel-edges (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return the use time of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.
  The window with the highest use time is the most recently selected
  one.  The window with the lowest use time is the least recently
  selected one.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-use-time (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Split window OLD.
  Second argument TOTAL-SIZE specifies the number of lines or columns of the
  new window.  In any case TOTAL-SIZE must be a positive integer.</p>

<p>  Third argument SIDE nil (or `below') specifies that the new window shall
  be located below WINDOW.  SIDE `above' means the new window shall be
  located above WINDOW.  In both cases TOTAL-SIZE specifies the number of
  lines of the new window including space reserved for the mode and/or
  header line.</p>

<p>  SIDE t (or `right') specifies that the new window shall be located on
  the right side of WINDOW.  SIDE `left' means the new window shall be
  located on the left of WINDOW.  In both cases TOTAL-SIZE specifies the
  number of columns of the new window including space reserved for fringes
  and the scrollbar or a divider column.</p>

<p>  Fourth argument NORMAL-SIZE specifies the normal size of the new window
  according to the SIDE argument.</p>

<p>  The new total and normal sizes of all involved windows must have been
  set correctly.  See the code of `split-window' for how this is done.</p>
</td><td class="codes"><pre class="brush: clojure">(defun split-window-internal (old total-size side normal-size))</pre></td></tr><tr><td class="docs"><p>Return the frame that CONFIG, a window-configuration object, is about.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-configuration-frame (config))</pre></td></tr><tr><td class="docs"><p>Set new total size of WINDOW to SIZE.
  Return SIZE.</p>

<p>  Optional argument ADD non-nil means add SIZE to the new total size of
  WINDOW and return the sum.</p>

<p>  Note: This function does not operate on any child windows of WINDOW.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-new-total (window size &amp;optional add))</pre></td></tr><tr><td class="docs"><p>Return position at which display currently starts in WINDOW.
  WINDOW must be a live window and defaults to the selected one.
  This is updated by redisplay or by calling `set-window-start'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-start (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Make WINDOW display BUFFER-OR-NAME as its contents.
  WINDOW has to be a live window and defaults to the selected one.
  BUFFER-OR-NAME must be a buffer or the name of an existing buffer.</p>

<p>  Optional third argument KEEP-MARGINS non-nil means that WINDOW's current
  display margins, fringe widths, and scroll bar settings are preserved;
  the default is to reset these from the local settings for BUFFER-OR-NAME
  or the frame defaults.  Return nil.</p>

<p>  This function throws an error when WINDOW is strongly dedicated to its
  buffer (that is `window-dedicated-p' returns t for WINDOW) and does not
  already display BUFFER-OR-NAME.</p>

<p>  This function runs `window-scroll-functions' before running
  `window-configuration-change-hook'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-buffer (window buffer-or-name &amp;optional keep-margins)
  (reset! (.buffer ^Window (el/check-type 'windowp (or window (selected-window))))
          (el/check-type 'bufferp (buffer/get-buffer buffer-or-name)))
  nil)</pre></td></tr><tr><td class="docs"><p>Return WINDOW's value for PARAMETER.
  WINDOW defaults to the selected window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-parameter (window parameter))</pre></td></tr><tr><td class="docs"><p>This function is obsolete since 23.1.</p>

<p>  Return WINDOW's redisplay end trigger value.
  WINDOW defaults to the selected window.
  See `set-window-redisplay-end-trigger' for more information.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-redisplay-end-trigger (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Select WINDOW.  Most editing will apply to WINDOW's buffer.
  Also make WINDOW's buffer current and make WINDOW the frame's selected
  window.  Return WINDOW.</p>

<p>  Optional second arg NORECORD non-nil means do not put this buffer at the
  front of the buffer list and do not make this window the most recently
  selected one.</p>

<p>  Note that the main editor command loop sets the current buffer to the
  buffer of the selected window before each command.</p>
</td><td class="codes"><pre class="brush: clojure">(defun select-window (window &amp;optional norecord)
  (el/check-type 'windowp window)
  (when (selected-window)
    (set-window-point (selected-window) (window-point (selected-window))))
  (buffer/set-buffer (window-buffer window))
  (when-not @(.pointm ^Window window)
    (set-window-point window @(.pt ^Buffer (window-buffer window))))
  (reset! (.selected-window ^Frame (frame/selected-frame)) window))</pre></td></tr><tr><td class="docs"><p>Return a list of the edge pixel coordinates of WINDOW.
  The list has the form (LEFT TOP RIGHT BOTTOM), all relative to 0, 0 at
  the top left corner of the display.</p>

<p>  RIGHT is one more than the rightmost x position occupied by WINDOW.
  BOTTOM is one more than the bottommost y position occupied by WINDOW.
  The pixel edges include the space used by WINDOW's scroll bar, display
  margins, fringes, header line, and/or mode line.  For the pixel edges
  of just the text area, use `window-inside-absolute-pixel-edges'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-absolute-pixel-edges (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return the total height, in lines, of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.</p>

<p>  The return value includes the mode line and header line, if any.
  If WINDOW is an internal window, the total height is the height
  of the screen areas spanned by its children.</p>

<p>  On a graphical display, this total height is reported as an
  integer multiple of the default character height.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-total-height (&amp;optional window)
  (let [window ^Window (el/check-type 'windowp (or window (selected-window)))
        minibuffer? (window-minibuffer-p window)
        buffer (window-buffer window)
        [header-line mode-line] (when-not minibuffer?
                                  [(buffer/buffer-local-value 'header-line-format buffer)
                                   (buffer/buffer-local-value 'mode-line-format buffer)])]
    (+ (if mode-line 1 0)
       (if header-line 1 0)
       @(.total-lines window))))</pre></td></tr><tr><td class="docs"><p>Return live window after WINDOW in the cyclic ordering of windows.
  WINDOW must be a live window and defaults to the selected one.  The
  optional arguments MINIBUF and ALL-FRAMES specify the set of windows to
  consider.</p>

<p>  MINIBUF nil or omitted means consider the minibuffer window only if the
  minibuffer is active.  MINIBUF t means consider the minibuffer window
  even if the minibuffer is not active.  Any other value means do not
  consider the minibuffer window even if the minibuffer is active.</p>

<p>  ALL-FRAMES nil or omitted means consider all windows on WINDOW's frame,
  plus the minibuffer window if specified by the MINIBUF argument.  If the
  minibuffer counts, consider all windows on all frames that share that
  minibuffer too.  The following non-nil values of ALL-FRAMES have special
  meanings:</p>

<ul>
<li><p>t means consider all windows on all existing frames.</p></li>
<li><p>`visible' means consider all windows on all visible frames.</p></li>
<li><p>0 (the number zero) means consider all windows on all visible and
iconified frames.</p></li>
<li><p>A frame means consider all windows on that frame only.</p>

<p>Anything else means consider all windows on WINDOW's frame and no
others.</p>

<p>If you use consistent values for MINIBUF and ALL-FRAMES, you can use
`next-window' to iterate through the entire cycle of acceptable
windows, eventually ending up back at the window you started with.
`previous-window' traverses the same cycle, in the reverse order.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defun next-window (&amp;optional window minibuf all-frames))</pre></td></tr><tr><td class="docs"><p>Return non-nil if WINDOW is a minibuffer window.
  If WINDOW is omitted or nil, it defaults to the selected window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-minibuffer-p (&amp;optional window)
  (.mini-p ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Return the topmost, leftmost live window on FRAME-OR-WINDOW.
  If omitted, FRAME-OR-WINDOW defaults to the currently selected frame.
  Else if FRAME-OR-WINDOW denotes any window, return the first window of
  that window's frame.  If FRAME-OR-WINDOW denotes a live frame, return
  the first window of that frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-first-window (&amp;optional frame-or-window))</pre></td></tr><tr><td class="docs"><p>Get width and type of scroll bars of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.
  Value is a list of the form (WIDTH COLS VERTICAL-TYPE HORIZONTAL-TYPE).
  If WIDTH is nil or TYPE is t, the window is using the frame's corresponding
  value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-scroll-bars (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return non-nil when WINDOW is dedicated to its buffer.
  More precisely, return the value assigned by the last call of
  `set-window-dedicated-p' for WINDOW.  Return nil if that function was
  never called with WINDOW as its argument, or the value set by that
  function was internally reset since its last call.  WINDOW defaults to
  the selected window.</p>

<p>  When a window is dedicated to its buffer, `display-buffer' will refrain
  from displaying another buffer in it.  `get-lru-window' and
  `get-largest-window' treat dedicated windows specially.
  <code>delete-windows-on',</code>replace-buffer-in-windows', `quit-window' and
  `kill-buffer' can delete a dedicated window and the containing frame.</p>

<p>  Functions like `set-window-buffer' may change the buffer displayed by a
  window, unless that window is "strongly" dedicated to its buffer, that
  is the value returned by `window-dedicated-p' is t.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-dedicated-p (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return the selected window.
  The selected window is the window in which the standard cursor for
  selected windows appears and to which many commands apply.</p>
</td><td class="codes"><pre class="brush: clojure">(defun selected-window ()
  @(.selected-window  ^Frame (frame/selected-frame)))</pre></td></tr><tr><td class="docs"><p>Position point relative to window.
  ARG nil means position point at center of window.
  Else, ARG specifies vertical position within the window;
  zero means top of window, negative means relative to bottom of window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun move-to-window-line (arg)
  (interactive &quot;P&quot;))</pre></td></tr><tr><td class="docs"><p>Set amount by which WINDOW should be scrolled vertically to VSCROLL.
  WINDOW nil means use the selected window.  Normally, VSCROLL is a
  non-negative multiple of the canonical character height of WINDOW;
  optional third arg PIXELS-P non-nil means that VSCROLL is in pixels.
  If PIXELS-P is nil, VSCROLL may have to be rounded so that it
  corresponds to an integral number of pixels.  The return value is the
  result of this rounding.
  If PIXELS-P is non-nil, the return value is VSCROLL.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-vscroll (window vscroll &amp;optional pixels-p)
  vscroll)</pre></td></tr><tr><td class="docs"><p>Return new normal size of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-new-normal (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return the amount by which WINDOW is scrolled vertically.
  If WINDOW is omitted or nil, it defaults to the selected window.
  Normally, value is a multiple of the canonical character height of WINDOW;
  optional second arg PIXELS-P means value is measured in pixels.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-vscroll (&amp;optional window pixels-p)
  0)</pre></td></tr><tr><td class="docs"><p>Return a window currently displaying BUFFER-OR-NAME, or nil if none.
  BUFFER-OR-NAME may be a buffer or a buffer name and defaults to
  the current buffer.</p>

<p>  The optional argument ALL-FRAMES specifies the frames to consider:</p>

<ul>
<li><p>t means consider all windows on all existing frames.</p></li>
<li><p>`visible' means consider all windows on all visible frames.</p></li>
<li><p>0 (the number zero) means consider all windows on all visible
  and iconified frames.</p></li>
<li><p>A frame means consider all windows on that frame only.</p>

<p>Any other value of ALL-FRAMES means consider all windows on the
selected frame and no others.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defun get-buffer-window (&amp;optional buffer-or-name all-frames))</pre></td></tr><tr><td class="docs"><p>Return the display-table that WINDOW is using.
  WINDOW defaults to the selected window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-display-table (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return a list of windows on FRAME, starting with WINDOW.
  FRAME nil or omitted means use the selected frame.
  WINDOW nil or omitted means use the window selected within FRAME.
  MINIBUF t means include the minibuffer window, even if it isn't active.
  MINIBUF nil or omitted means include the minibuffer window only
  if it's active.
  MINIBUF neither nil nor t means never include the minibuffer window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-list (&amp;optional frame minibuf window)
  (let [^Frame frame (or frame (frame/selected-frame))]
    (loop [w ^Window (el/check-type 'windowp (or window (.root-window frame)))
           acc []]
      (if w
        (recur @(.next w)
               (concat
                (when-let [h @(.hchild w)] (window-list frame minibuf h))
                (when-let [v @(.vchild w)] (window-list frame minibuf v))
                (if (and (not minibuf) (.mini-p w))
                  acc
                  (conj acc w))))
        (cons/maybe-seq (reverse acc))))))</pre></td></tr><tr><td class="docs"><p>Return the root window of FRAME-OR-WINDOW.
  If omitted, FRAME-OR-WINDOW defaults to the currently selected frame.
  With a frame argument, return that frame's root window.
  With a window argument, return the root window of that window's frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-root-window (&amp;optional frame-or-window)
  (let [frame (if (frame/framep frame-root-window)
                frame-root-window
                (window-frame frame-or-window))
        ^Frame frame (or frame (frame/selected-frame))]
    (.root-window frame)))</pre></td></tr><tr><td class="docs"><p>Get width of fringes of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.
  Value is a list of the form (LEFT-WIDTH RIGHT-WIDTH OUTSIDE-MARGINS).</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-fringes (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return the parameters of WINDOW and their values.
  WINDOW defaults to the selected window.  The return value is a list of
  elements of the form (PARAMETER . VALUE).</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-parameters (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return window containing coordinates X and Y on FRAME.
  FRAME must be a live frame and defaults to the selected one.
  The top left corner of the frame is considered to be row 0,
  column 0.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-at (x y &amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Return the buffer displayed in window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.
  Return nil for an internal window or a deleted window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-buffer (&amp;optional window)
  @(.buffer ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Set the configuration of windows and buffers as specified by CONFIGURATION.
  CONFIGURATION must be a value previously returned
  by `current-window-configuration' (which see).
  If CONFIGURATION was made from a frame that is now deleted,
  only frame-independent values can be restored.  In this case,
  the return value is nil.  Otherwise the value is t.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-configuration (configuration))</pre></td></tr><tr><td class="docs"><p>Force all windows to be updated on next redisplay.
  If optional arg OBJECT is a window, force redisplay of that window only.
  If OBJECT is a buffer or buffer name, force redisplay of all windows
  displaying that buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun force-window-update (&amp;optional object))</pre></td></tr><tr><td class="docs"><p>Return a list of all live windows.
  WINDOW specifies the first window to list and defaults to the selected
  window.</p>

<p>  Optional argument MINIBUF nil or omitted means consider the minibuffer
  window only if the minibuffer is active.  MINIBUF t means consider the
  minibuffer window even if the minibuffer is not active.  Any other value
  means do not consider the minibuffer window even if the minibuffer is
  active.</p>

<p>  Optional argument ALL-FRAMES nil or omitted means consider all windows
  on WINDOW's frame, plus the minibuffer window if specified by the
  MINIBUF argument.  If the minibuffer counts, consider all windows on all
  frames that share that minibuffer too.  The following non-nil values of
  ALL-FRAMES have special meanings:</p>

<ul>
<li><p>t means consider all windows on all existing frames.</p></li>
<li><p>`visible' means consider all windows on all visible frames.</p></li>
<li><p>0 (the number zero) means consider all windows on all visible and
iconified frames.</p></li>
<li><p>A frame means consider all windows on that frame only.</p>

<p>Anything else means consider all windows on WINDOW's frame and no
others.</p>

<p>If WINDOW is not on the list of windows returned, some other window will
be listed first but no error is signaled.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defun window-list-1 (&amp;optional window minibuf all-frames)
  (cons/maybe-seq (cons (selected-window) (remove #{(selected-window)} (filter window-live-p (window-list nil minibuf))))))</pre></td></tr><tr><td class="docs"><p>Set the fringe widths of window WINDOW.
  If WINDOW is nil, set the fringe widths of the currently selected
  window.
  Second arg LEFT-WIDTH specifies the number of pixels to reserve for
  the left fringe.  Optional third arg RIGHT-WIDTH specifies the right
  fringe width.  If a fringe width arg is nil, that means to use the
  frame's default fringe width.  Default fringe widths can be set with
  the command `set-fringe-style'.
  If optional fourth arg OUTSIDE-MARGINS is non-nil, draw the fringes
  outside of the display margins.  By default, fringes are drawn between
  display marginal areas and the text area.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-fringes (window left-width &amp;optional right-width outside-margins))</pre></td></tr><tr><td class="docs"><p>Remove WINDOW from its frame.
  WINDOW defaults to the selected window.  Return nil.
  Signal an error when WINDOW is the only window on its frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-window-internal (window))</pre></td></tr><tr><td class="docs"><p>Return the number of columns by which WINDOW is scrolled from left margin.
  WINDOW must be a live window and defaults to the selected one.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-hscroll (&amp;optional window)
  0)</pre></td></tr><tr><td class="docs"><p>Return the previous sibling window of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.
  Return nil if WINDOW has no previous sibling.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-prev-sibling (&amp;optional window)
  @(.prev ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Return the width, in columns, of WINDOW's text area.
  If WINDOW is omitted or nil, it defaults to the selected window.
  Signal an error if the window is not live.</p>

<p>  The return value does not include any vertical dividers, fringe or
  marginal areas, or scroll bars.  On a graphical display, the width is
  expressed as an integer multiple of the default character width.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-body-width (&amp;optional window)
  @(.total-cols ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Set WINDOW's previous buffers to PREV-BUFFERS.
  WINDOW must be a live window and defaults to the selected one.</p>

<p>  PREV-BUFFERS should be a list of elements (BUFFER WINDOW-START POS),
  where BUFFER is a buffer, WINDOW-START is the start position of the
  window for that buffer, and POS is a window-specific point value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-prev-buffers (window prev-buffers)
  (swap! window-prev-buffers-list assoc (el/check-type 'windowp window) prev-buffers)
  nil)</pre></td></tr><tr><td class="docs"><p>Return buffers previously shown in WINDOW.
  WINDOW must be a live window and defaults to the selected one.</p>

<p>  The return value is a list of elements (BUFFER WINDOW-START POS),
  where BUFFER is a buffer, WINDOW-START is the start position of the
  window for that buffer, and POS is a window-specific point value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-prev-buffers (&amp;optional window)
  (cons/maybe-seq (@window-prev-buffers-list (el/check-type 'windowp (or window (selected-window))))))</pre></td></tr><tr><td class="docs"><p>Return the window which was selected when entering the minibuffer.
  Returns nil, if selected window is not a minibuffer window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun minibuffer-selected-window ())</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a window and nil otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defun windowp (object)
  (instance? Window object))</pre></td></tr><tr><td class="docs"><p>Mark WINDOW as dedicated according to FLAG.
  WINDOW must be a live window and defaults to the selected one.  FLAG
  non-nil means mark WINDOW as dedicated to its buffer.  FLAG nil means
  mark WINDOW as non-dedicated.  Return FLAG.</p>

<p>  When a window is dedicated to its buffer, `display-buffer' will refrain
  from displaying another buffer in it.  `get-lru-window' and
  `get-largest-window' treat dedicated windows specially.
  <code>delete-windows-on',</code>replace-buffer-in-windows', `quit-window',
  <code>quit-restore-window' and</code>kill-buffer' can delete a dedicated window
  and the containing frame.</p>

<p>  As a special case, if FLAG is t, mark WINDOW as "strongly" dedicated to
  its buffer.  Functions like `set-window-buffer' may change the buffer
  displayed by a window, unless that window is strongly dedicated to its
  buffer.  If and when `set-window-buffer' displays another buffer in a
  window, it also makes sure that the window is no more dedicated.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-dedicated-p (window flag))</pre></td></tr><tr><td class="docs"><p>Return the height in lines of the text display area of WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.</p>

<p>  The returned height does not include the mode line, any header line,
  nor any partial-height lines at the bottom of the text area.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-text-height (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Set selected window of FRAME to WINDOW.
  FRAME must be a live frame and defaults to the selected one.  If FRAME
  is the selected frame, this makes WINDOW the selected window.  Optional
  argument NORECORD non-nil means to neither change the order of recently
  selected windows nor the buffer list.  WINDOW must denote a live window.
  Return WINDOW.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-frame-selected-window (frame window &amp;optional norecord))</pre></td></tr><tr><td class="docs"><p>Return a list of the edge coordinates of WINDOW.
  The list has the form (LEFT TOP RIGHT BOTTOM).
  TOP and BOTTOM count by lines, and LEFT and RIGHT count by columns,
  all relative to 0, 0 at top left corner of frame.</p>

<p>  RIGHT is one more than the rightmost column of WINDOW's text area.
  BOTTOM is one more than the bottommost row of WINDOW's text area.
  The inside edges do not include the space used by the WINDOW's scroll
  bar, display margins, fringes, header line, and/or mode line.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-inside-edges (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return the selected window of FRAME-OR-WINDOW.
  If omitted, FRAME-OR-WINDOW defaults to the currently selected frame.
  Else if FRAME-OR-WINDOW denotes any window, return the selected window
  of that window's frame.  If FRAME-OR-WINDOW denotes a live frame, return
  the selected window of that frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-selected-window (&amp;optional frame-or-window))</pre></td></tr><tr><td class="docs"><p>Return the height, in lines, of WINDOW's text area.
  If WINDOW is omitted or nil, it defaults to the selected window.
  Signal an error if the window is not live.</p>

<p>  The returned height does not include the mode line or header line.
  On a graphical display, the height is expressed as an integer multiple
  of the default character height.  If a line at the bottom of the text
  area is only partially visible, that counts as a whole line; to
  exclude partially-visible lines, use `window-text-height'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-body-height (&amp;optional window)
  @(.total-lines ^Window (el/check-type 'windowp (or window (selected-window)))))</pre></td></tr><tr><td class="docs"><p>Return live window before WINDOW in the cyclic ordering of windows.
  WINDOW must be a live window and defaults to the selected one.  The
  optional arguments MINIBUF and ALL-FRAMES specify the set of windows to
  consider.</p>

<p>  MINIBUF nil or omitted means consider the minibuffer window only if the
  minibuffer is active.  MINIBUF t means consider the minibuffer window
  even if the minibuffer is not active.  Any other value means do not
  consider the minibuffer window even if the minibuffer is active.</p>

<p>  ALL-FRAMES nil or omitted means consider all windows on WINDOW's frame,
  plus the minibuffer window if specified by the MINIBUF argument.  If the
  minibuffer counts, consider all windows on all frames that share that
  minibuffer too.  The following non-nil values of ALL-FRAMES have special
  meanings:</p>

<ul>
<li><p>t means consider all windows on all existing frames.</p></li>
<li><p>`visible' means consider all windows on all visible frames.</p></li>
<li><p>0 (the number zero) means consider all windows on all visible and
iconified frames.</p></li>
<li><p>A frame means consider all windows on that frame only.</p>

<p>Anything else means consider all windows on WINDOW's frame and no
others.</p>

<p>If you use consistent values for MINIBUF and ALL-FRAMES, you can
use `previous-window' to iterate through the entire cycle of
acceptable windows, eventually ending up back at the window you
started with.  `next-window' traverses the same cycle, in the
reverse order.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defun previous-window (&amp;optional window minibuf all-frames))</pre></td></tr><tr><td class="docs"><p>Set new normal size of WINDOW to SIZE.
  Return SIZE.</p>

<p>  Note: This function does not operate on any child windows of WINDOW.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-new-normal (window &amp;optional size))</pre></td></tr><tr><td class="docs"><p>Scroll selected window display ARG columns right.
  Default for ARG is window width minus 2.
  Value is the total amount of leftward horizontal scrolling in
  effect after the change.
  If SET-MINIMUM is non-nil, the new scroll amount becomes the
  lower bound for automatic scrolling, i.e. automatic scrolling
  will not scroll a window to a column less than the value returned
  by this function.  This happens in an interactive call.</p>
</td><td class="codes"><pre class="brush: clojure">(defun scroll-right (&amp;optional arg set-minimum)
  (interactive &quot;^P\np&quot;))</pre></td></tr><tr><td class="docs"><p>Make display in WINDOW start at position POS in WINDOW's buffer.
  If WINDOW is nil, the selected window is used.  Return POS.
  Optional third arg NOFORCE non-nil inhibits next redisplay from
  overriding motion of point in order to display at this exact start.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-window-start (window pos &amp;optional noforce))</pre></td></tr><tr><td class="docs"><p>Return the topmost child window of window WINDOW.
  Return nil if WINDOW is a live window (live windows have no children).
  Return nil if WINDOW is an internal window whose children form a
  horizontal combination.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-top-child (window)
  @(.vchild ^Window (el/check-type 'windowp window)))</pre></td></tr><tr><td class="docs"><p>Return the new total size of window WINDOW.
  If WINDOW is omitted or nil, it defaults to the selected window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-new-total (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Return the frame that window WINDOW is on.
  If WINDOW is omitted or nil, it defaults to the selected window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-frame (window)
  (frame/selected-frame))</pre></td></tr><tr><td class="docs"><p>Scroll selected window display ARG columns left.
  Default for ARG is window width minus 2.
  Value is the total amount of leftward horizontal scrolling in
  effect after the change.
  If SET-MINIMUM is non-nil, the new scroll amount becomes the
  lower bound for automatic scrolling, i.e. automatic scrolling
  will not scroll a window to a column less than the value returned
  by this function.  This happens in an interactive call.</p>
</td><td class="codes"><pre class="brush: clojure">(defun scroll-left (&amp;optional arg set-minimum)
  (interactive &quot;^P\np&quot;))</pre></td></tr><tr><td class="docs"><p>Return the leftmost child window of window WINDOW.
  Return nil if WINDOW is a live window (live windows have no children).
  Return nil if WINDOW is an internal window whose children form a
  vertical combination.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-left-child (window)
  @(.hchild ^Window (el/check-type 'windowp window)))</pre></td></tr><tr><td class="docs"><p>Return a list of the edge coordinates of WINDOW.
  The list has the form (LEFT TOP RIGHT BOTTOM).
  TOP and BOTTOM count by lines, and LEFT and RIGHT count by columns,
  all relative to 0, 0 at top left corner of frame.</p>

<p>  RIGHT is one more than the rightmost column occupied by WINDOW.
  BOTTOM is one more than the bottommost row occupied by WINDOW.
  The edges include the space used by WINDOW's scroll bar, display
  margins, fringes, header line, and/or mode line.  For the edges of
  just the text area, use `window-inside-edges'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-edges (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Apply requested size values for window-tree of FRAME.
  Optional argument HORIZONTAL omitted or nil means apply requested height
  values.  HORIZONTAL non-nil means apply requested width values.</p>

<p>  This function checks whether the requested values sum up to a valid
  window layout, recursively assigns the new sizes of all child windows
  and calculates and assigns the new start positions of these windows.</p>

<p>  Note: This function does not check any of `window-fixed-size-p',
  <code>window-min-height' or</code>window-min-width'.  All these checks have to
  be applied on the Elisp level.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-resize-apply (frame &amp;optional horizontal))</pre></td></tr><tr><td class="docs"><p>Compare two window configurations as regards the structure of windows.
  This function ignores details such as the values of point and mark
  and scrolling positions.</p>
</td><td class="codes"><pre class="brush: clojure">(defun compare-window-configurations (x y))</pre></td></tr><tr><td class="docs"><p>Internal function for `with-output-to-temp-buffer'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-temp-output-buffer-show (buf))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.fns" name="deuce.emacs.fns"><h1 class="project-name">deuce.emacs.fns</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.fns
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.data :refer [car cdr setcar setcdr] :as data]
            [deuce.emacs.lread :as lread]
            [deuce.emacs-lisp.cons :as cons]
            [deuce.emacs-lisp.globals :as globals])
  (import [clojure.lang IPersistentCollection PersistentVector]
          [deuce.emacs.data CharTable]
          [java.lang.management ManagementFactory]
          [java.util List Map HashMap Collections Objects Arrays Random]
          [java.nio CharBuffer]
          [java.nio.charset Charset]
          [javax.xml.bind DatatypeConverter]
          [java.security MessageDigest])
  (:refer-clojure :exclude [concat assoc reverse nth identity require get sort]))</pre></td></tr><tr><td class="docs"><p>*Non-nil means mouse commands use dialog boxes to ask questions.
  This applies to <code>y-or-n-p' and</code>yes-or-no-p' questions asked by commands
  invoked by mouse clicks and mouse menu items.</p>

<p>  On some platforms, file selection dialogs are also enabled if this is
  non-nil.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar use-dialog-box nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means mouse commands use a file dialog to ask for files.
  This applies to commands from menus and tool bar buttons even when
  they are initiated from the keyboard.  If `use-dialog-box' is nil,
  that disables the use of a file dialog, regardless of the value of
  this variable.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar use-file-dialog nil)</pre></td></tr><tr><td class="docs"><p>A list of symbols which are the features of the executing Emacs.
  Used by <code>featurep' and</code>require', and altered by `provide'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar features nil)</pre></td></tr><tr><td class="docs"><p>Announce that FEATURE is a feature of the current Emacs.
  The optional argument SUBFEATURES should be a list of symbols listing
  particular subfeatures supported in this version of FEATURE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun provide (feature &amp;optional subfeatures)
  (when-not (some #{feature} globals/features)
    (el/setq features (alloc/cons feature globals/features)))
  feature)</pre></td></tr><tr><td class="docs"><p>In WIDGET, get the value of PROPERTY.
  The value could either be specified when the widget was created, or
  later with `widget-put'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun widget-get (widget property))</pre></td></tr><tr><td class="docs"><p>Return a multibyte string with the same individual bytes as STRING.
  If STRING is multibyte, the result is STRING itself.
  Otherwise it is a newly created string, with no text properties.</p>

<p>  If STRING is unibyte and contains an individual 8-bit byte (i.e. not
  part of a correct utf-8 sequence), it is converted to the corresponding
  multibyte character of charset `eight-bit'.
  See also `string-to-multibyte'.</p>

<p>  Beware, this often doesn't really do what you think it does.
  It is similar to (decode-coding-string STRING 'utf-8-emacs).
  If you're not sure, whether to use `string-as-multibyte' or
  <code>string-to-multibyte', use</code>string-to-multibyte'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-as-multibyte (string)
  (let [utf-8 (.newEncoder (Charset/forName &quot;UTF-8&quot;))]
    (String. (.array (.encode utf-8 (CharBuffer/wrap (str string)))) (.charset utf-8))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare plist-put)</pre></td></tr><tr><td class="docs"><p>Change value in PLIST of PROP to VAL, comparing with `equal'.
  PLIST is a property list, which is a list of the form
  (PROP1 VALUE1 PROP2 VALUE2 ...).  PROP and VAL are any objects.
  If PROP is already a property on the list, its value is set to VAL,
  otherwise the new PROP VAL pair is added.  The new plist is returned;
  use `(setq x (lax-plist-put x prop val))' to be sure to use the new value.
  The PLIST is modified by side effects.</p>
</td><td class="codes"><pre class="brush: clojure">(defun lax-plist-put (plist prop val)
  (plist-put prop val))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare length)</pre></td></tr><tr><td class="docs"><p>Return the length of a list, but avoid error or infinite loop.
  This function never gets an error.  If LIST is not really a list,
  it returns 0.  If LIST is circular, it returns a finite value
  which is at least the number of distinct elements.</p>
</td><td class="codes"><pre class="brush: clojure">(defun safe-length (list)
  (if (data/sequencep list)
    (length list)
    0))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare equal mem)</pre></td></tr><tr><td class="docs"><p>Return non-nil if ELT is an element of LIST.  Comparison done with `equal'.
  The value is actually the tail of LIST whose car is ELT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun member (elt list)
  (mem equal elt list))</pre></td></tr><tr><td class="docs"><p>Return a copy of hash table TABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun copy-hash-table (table)
  (HashMap. ^Map table))</pre></td></tr><tr><td class="docs"><p>Concatenate all the arguments and make the result a list.
  The result is a list whose elements are the elements of all the arguments.
  Each argument xmay be a list, vector or string.
  The last argument is not copied, just used as the tail of the new list.</p>
</td><td class="codes"><pre class="brush: clojure">(defun append (&amp;rest sequences)
  (if (every? data/null (rest sequences))
    (if (and (next sequences) (data/arrayp (first sequences)))
      (apply alloc/list (first sequences))
      (first sequences))
    (let [last (cons/maybe-seq (last sequences))]
      (if-let [l (apply alloc/list (apply c/concat (butlast sequences)))]
        (do
          (setcdr (cons/last-cons l) last)
          l)
        last))))</pre></td></tr><tr><td class="docs"><p>Apply FUNCTION to each element of SEQUENCE, and concat the results as strings.
  In between each pair of results, stick in SEPARATOR.  Thus, " " as
  SEPARATOR results in spaces between the values returned by FUNCTION.
  SEQUENCE may be a list, a vector, a bool-vector, or a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun mapconcat (function sequence separator)
  (s/join separator (map (el/fun function) (cons/maybe-seq sequence))))</pre></td></tr><tr><td class="docs"><p>Compare the contents of two strings, converting to multibyte if needed.
  In string STR1, skip the first START1 characters and stop at END1.
  In string STR2, skip the first START2 characters and stop at END2.
  END1 and END2 default to the full lengths of the respective strings.</p>

<p>  Case is significant in this comparison if IGNORE-CASE is nil.
  Unibyte strings are converted to multibyte for comparison.</p>

<p>  The value is t if the strings (or specified portions) match.
  If string STR1 is less, the value is a negative number N;
    - 1 - N is the number of characters that match at the beginning.
  If string STR1 is greater, the value is a positive number N;
    N - 1 is the number of characters that match at the beginning.</p>
</td><td class="codes"><pre class="brush: clojure">(defun compare-strings (str1 start1 end1 str2 start2 end2 &amp;optional ignore-case)
  (let [[str1 str2] (if ignore-case
                      [(s/lower-case str1) (s/lower-case str2)]
                      [str1 str2])]
    (compare (subs str1 start1 (or end1 (count str1)))
             (subs str2 start2 (or end2 (count str2))))))</pre></td></tr><tr><td class="docs"><p>Return a copy of ALIST.
  This is an alist which represents the same mapping from objects to objects,
  but does not share the alist structure with ALIST.
  The objects mapped (cars and cdrs of elements of the alist)
  are shared, however.
  Elements of ALIST that are not conses are also shared.</p>
</td><td class="codes"><pre class="brush: clojure">(defun copy-alist (alist)
  alist)</pre></td></tr><tr><td class="docs"><p>Return the secure hash of OBJECT, a buffer or string.
  ALGORITHM is a symbol specifying the hash to use:
  md5, sha1, sha224, sha256, sha384 or sha512.</p>

<p>  The two optional arguments START and END are positions specifying for
  which part of OBJECT to compute the hash.  If nil or omitted, uses the
  whole OBJECT.</p>

<p>  If BINARY is non-nil, returns a string in binary form.</p>
</td><td class="codes"><pre class="brush: clojure">(defun secure-hash (algorithm object &amp;optional start end binary)
  (let [hash (.digest (MessageDigest/getInstance (str algorithm))
                      (.getBytes (subs object (or start 0) (or end (count object))) &quot;UTF-8&quot;))]
    (if binary hash
        (apply str (map #(format &quot;%02x&quot; %) hash)))))</pre></td></tr><tr><td class="docs"><p>Return a copy of a list, vector, string or char-table.
  The elements of a list or vector are not copied; they are shared
  with the original.</p>
</td><td class="codes"><pre class="brush: clojure">(defun copy-sequence (arg)
  (condp some [arg]
    data/char-table-p (let [^CharTable arg arg]
                        (CharTable. (.defalt arg) (atom @(.parent arg)) (.purpose arg)
                                    (apply alloc/vector (.contents arg))
                                    (when (.extras arg)
                                      (apply alloc/vector (.extras arg)))))
    data/listp (apply alloc/list arg)
    data/vectorp (apply alloc/vector arg)
    data/stringp (apply alloc/string arg)))</pre></td></tr><tr><td class="docs"><p>Return a unibyte string with the same individual bytes as STRING.
  If STRING is unibyte, the result is STRING itself.
  Otherwise it is a newly created string, with no text properties.
  If STRING is multibyte and contains a character of charset
  `eight-bit', it is converted to the corresponding single byte.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-as-unibyte (string)
  (let [ascii (.newEncoder (Charset/forName &quot;US-ASCII&quot;))]
    (String. (.array (.encode ascii (CharBuffer/wrap (str string)))) (.charset ascii))))</pre></td></tr><tr><td class="docs"><p>Compute a hash code for OBJ and return it as integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun sxhash (obj)
  (hash obj))</pre></td></tr><tr><td class="docs"><p>Return MD5 message digest of OBJECT, a buffer or string.</p>

<p>  A message digest is a cryptographic checksum of a document, and the
  algorithm to calculate it is defined in RFC 1321.</p>

<p>  The two optional arguments START and END are character positions
  specifying for which part of OBJECT the message digest should be
  computed.  If nil or omitted, the digest is computed for the whole
  OBJECT.</p>

<p>  The MD5 message digest is computed from the result of encoding the
  text in a coding system, not directly from the internal Emacs form of
  the text.  The optional fourth argument CODING-SYSTEM specifies which
  coding system to encode the text with.  It should be the same coding
  system that you used or will use when actually writing the text into a
  file.</p>

<p>  If CODING-SYSTEM is nil or omitted, the default depends on OBJECT.  If
  OBJECT is a buffer, the default for CODING-SYSTEM is whatever coding
  system would be chosen by default for writing this text into a file.</p>

<p>  If OBJECT is a string, the most preferred coding system (see the
  command `prefer-coding-system') is used.</p>

<p>  If NOERROR is non-nil, silently assume the `raw-text' coding if the
  guesswork fails.  Normally, an error is signaled in such case.</p>
</td><td class="codes"><pre class="brush: clojure">(defun md5 (object &amp;optional start end coding-system noerror)
  (secure-hash 'md5 object start end))</pre></td></tr><tr><td class="docs"><p>Apply the value of WIDGET's PROPERTY to the widget itself.
  ARGS are passed as extra arguments to the function.</p>
</td><td class="codes"><pre class="brush: clojure">(defun widget-apply (widget property &amp;rest args))</pre></td></tr><tr><td class="docs"><p>Return t if OBJ is a Lisp hash table object.</p>
</td><td class="codes"><pre class="brush: clojure">(defun hash-table-p (obj)
  (instance? Map obj))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare del)</pre></td></tr><tr><td class="docs"><p>Delete by side effect any occurrences of ELT as a member of SEQ.
  SEQ must be a list, a vector, or a string.
  The modified SEQ is returned.  Comparison is done with `equal'.
  If SEQ is not a list, or the first member of SEQ is ELT, deleting it
  is not a side effect; it is simply using a different sequence.
  Therefore, write `(setq foo (delete element foo))'
  to be sure of changing the value of `foo'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete (elt seq)
  (cond
   (data/consp seq) (del equal elt seq)
   (data/vectorp seq) (apply alloc/vector (del equal elt (apply alloc/list seq)))
   (and (data/stringp seq) (integer? elt)) (s/replace seq (c/str (c/char elt)) &quot;&quot;)
   :else seq))</pre></td></tr><tr><td class="docs"><p>Access locale data ITEM for the current C locale, if available.
  ITEM should be one of the following:</p>

<p>  `codeset', returning the character set as a string (locale item CODESET);</p>

<p>  `days', returning a 7-element vector of day names (locale items DAY_n);</p>

<p>  `months', returning a 12-element vector of month names (locale items MON_n);</p>

<p>  `paper', returning a list (WIDTH HEIGHT) for the default paper size,
    both measured in millimeters (locale items PAPER<em>WIDTH, PAPER</em>HEIGHT).</p>

<p>  If the system can't provide such information through a call to
  `nl_langinfo', or if ITEM isn't from the list above, return nil.</p>

<p>  See also Info node `(libc)Locales'.</p>

<p>  The data read from the system are decoded using `locale-coding-system'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun locale-info (item))</pre></td></tr><tr><td class="docs"><p>Return a multibyte string with the same individual chars as STRING.
  If STRING is multibyte, the result is STRING itself.
  Otherwise it is a newly created string, with no text properties.</p>

<p>  If STRING is unibyte and contains an 8-bit byte, it is converted to
  the corresponding multibyte character of charset `eight-bit'.</p>

<p>  This differs from `string-as-multibyte' by converting each byte of a correct
  utf-8 sequence to an eight-bit character, not just bytes that don't form a
  correct sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-to-multibyte (string)
  (string-as-multibyte string))</pre></td></tr><tr><td class="docs"><p>Return t if the two args are the same Lisp object.
  Floating-point numbers of equal value are <code>eql', but they may not be</code>eq'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun eql (obj1 obj2)
  (cond
    (and (float? obj1) (float obj2)) (== obj1 obj2)
    :else (data/eq obj1 obj2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private plist-map [plist]
  (if (instance? Map plist) plist (into {} (map vec (partition 2 plist)))))</pre></td></tr><tr><td class="docs"><p>Extract a value from a property list.
  PLIST is a property list, which is a list of the form
  (PROP1 VALUE1 PROP2 VALUE2...).  This function returns the value
  corresponding to the given PROP, or nil if PROP is not one of the
  properties on the list.  This function never signals an error.</p>
</td><td class="codes"><pre class="brush: clojure">(defun plist-get (plist prop)
  ((plist-map plist) prop))</pre></td></tr><tr><td class="docs"><p>Return element of SEQUENCE at index N.</p>
</td><td class="codes"><pre class="brush: clojure">(defun elt (sequence n)
  (c/nth (cons/maybe-seq sequence) n))</pre></td></tr><tr><td class="docs"><p>Base64-encode STRING and return the result.
  Optional second argument NO-LINE-BREAK means do not break long lines
  into shorter lines.</p>
</td><td class="codes"><pre class="brush: clojure">(defun base64-encode-string (string &amp;optional no-line-break)
  (DatatypeConverter/printBase64Binary (.getBytes (str string) &quot;UTF-8&quot;)))</pre></td></tr><tr><td class="docs"><p>Return t if two Lisp objects have similar structure and contents.
  This is like `equal' except that it compares the text properties
  of strings.  (`equal' ignores text properties.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun equal-including-properties (o1 o2)
  (equal o1 o2))</pre></td></tr><tr><td class="docs"><p>Return a substring of STRING, without text properties.
  It starts at index FROM and ends before TO.
  TO may be nil or omitted; then the substring runs to the end of STRING.
  If FROM is nil or omitted, the substring starts at the beginning of STRING.
  If FROM or TO is negative, it counts from the end.</p>

<p>  With one argument, just copy STRING without its properties.</p>
</td><td class="codes"><pre class="brush: clojure">(defun substring-no-properties (string &amp;optional from to)
  (subs string (or from 0) (or to (count string))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ^Random rnd (Random.))</pre></td></tr><tr><td class="docs"><p>Return a pseudo-random number.
  All integers representable in Lisp are equally likely.
    On most systems, this is 29 bits' worth.
  With positive integer LIMIT, return random number in interval [0,LIMIT).
  With argument t, set the random number seed from the current time and pid.
  Other values of LIMIT are ignored.</p>
</td><td class="codes"><pre class="brush: clojure">(defun random (&amp;optional limit)
  (if (true? limit)
    (do
      (.setSeed rnd (System/currentTimeMillis))
      (random))
    (if ((every-pred integer? pos?) limit)
      (min (.nextLong rnd) (long limit))
      (.nextLong rnd))))</pre></td></tr><tr><td class="docs"><p>Concatenate all the arguments and make the result a string.
  The result is a string whose elements are the elements of all the arguments.
  Each argument may be a string or a list or vector of characters (integers).</p>
</td><td class="codes"><pre class="brush: clojure">(defun concat (&amp;rest sequences)
  (apply str (map char (apply c/concat sequences))))</pre></td></tr><tr><td class="docs"><p>Return the number of bytes in STRING.
  If STRING is multibyte, this may be greater than the length of STRING.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-bytes (string)
  (count (.getBytes (str string))))</pre></td></tr><tr><td class="docs"><p>Return non-nil if KEY is `equal' to the car of an element of LIST.
  The value is actually the first element of LIST whose car equals KEY.</p>
</td><td class="codes"><pre class="brush: clojure">(defun assoc (key list)
  (some #(c/and (data/consp %) (equal key (car %)) %) (cons/maybe-seq list)))</pre></td></tr><tr><td class="docs"><p>Remove KEY from TABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun remhash (key table)
  (.remove ^Map table key)
  nil)</pre></td></tr><tr><td class="docs"><p>Ask user a yes-or-no question.  Return t if answer is yes.
  PROMPT is the string to display to ask the question.  It should end in
  a space; `yes-or-no-p' adds "(yes or no) " to it.</p>

<p>  The user must confirm the answer with RET, and can edit it until it
  has been confirmed.</p>

<p>  Under a windowing system a dialog box will be used if `last-nonmenu-event'
  is nil, and `use-dialog-box' is non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun yes-or-no-p (prompt)
  ;; This doesn't work as minibuffer's doesn't, but we want to see if it happens.
  ((ns-resolve 'deuce.emacs.minibuf 'minibuffer) prompt)
  true)</pre></td></tr><tr><td class="docs"><p>Return the number of elements in TABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun hash-table-count (table)
  (count table))</pre></td></tr><tr><td class="docs"><p>Clear the contents of STRING.
  This makes STRING unibyte and may change its length.</p>
</td><td class="codes"><pre class="brush: clojure">(defun clear-string (string))</pre></td></tr><tr><td class="docs"><p>Not tail recursive</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private del [f elt list]
  (when list
    (if (f elt (car list))
      (del f elt (cdr list))
      (doto list
        (setcdr (del f elt (cdr list)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private mem [f elt list]
  (loop [list list]
    (if (f elt (car list))
      list
      (when-let [list (cdr list)]
        (recur list)))))</pre></td></tr><tr><td class="docs"><p>Delete by side effect any occurrences of ELT as a member of LIST.
  The modified LIST is returned.  Comparison is done with `eq'.
  If the first member of LIST is ELT, there is no way to remove it by side effect;
  therefore, write `(setq foo (delq element foo))'
  to be sure of changing the value of `foo'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delq (elt list)
  (del data/eq elt list))</pre></td></tr><tr><td class="docs"><p>Return non-nil if KEY is `eq' to the car of an element of LIST.
  The value is actually the first element of LIST whose car is KEY.
  Elements of LIST that are not conses are ignored.</p>
</td><td class="codes"><pre class="brush: clojure">(defun assq (key list)
  (first (filter #(data/eq key (data/car-safe %)) (cons/maybe-seq list))))</pre></td></tr><tr><td class="docs"><p>Return the multibyte equivalent of STRING.
  If STRING is unibyte and contains non-ASCII characters, the function
  `unibyte-char-to-multibyte' is used to convert each unibyte character
  to a multibyte character.  In this case, the returned string is a
  newly created string with no text properties.  If STRING is multibyte
  or entirely ASCII, it is returned unchanged.  In particular, when
  STRING is unibyte and entirely ASCII, the returned string is unibyte.
  (When the characters are all ASCII, Emacs primitives will treat the
  string the same way whether it is unibyte or multibyte.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-make-multibyte (string)
  (string-to-multibyte string))</pre></td></tr><tr><td class="docs"><p>Return t if two strings have identical contents.
  Case is significant, but text properties are ignored.
  Symbols are also allowed; their print names are used instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-equal (s1 s2)
  (= (str s1) (str s2)))</pre></td></tr><tr><td class="docs"><p>Apply FUNCTION to each element of SEQUENCE, and make a list of the results.
  The result is a list just as long as SEQUENCE.
  SEQUENCE may be a list, a vector, a bool-vector, or a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun mapcar (function sequence)
  (el/check-type 'sequencep sequence)
  (apply alloc/list (map (el/fun function) (cons/maybe-seq sequence))))</pre></td></tr><tr><td class="docs"><p>Store each element of ARRAY with ITEM.
  ARRAY is a vector, string, char-table, or bool-vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defun fillarray (array item)
  (if (instance? CharTable array)
    (fillarray (.contents ^CharTable array) item)
    (Arrays/fill ^objects array item))
  array)</pre></td></tr><tr><td class="docs"><p>Return list of 1 minute, 5 minute and 15 minute load averages.</p>

<p>  Each of the three load averages is multiplied by 100, then converted
  to integer.</p>

<p>  When USE-FLOATS is non-nil, floats will be used instead of integers.
  These floats are not multiplied by 100.</p>

<p>  If the 5-minute or 15-minute load averages are not available, return a
  shortened list, containing only those averages which are available.</p>

<p>  An error is thrown if the load average can't be obtained.  In some
  cases making it work would require Emacs being installed setuid or
  setgid so that it can read kernel information, and that usually isn't
  advisable.</p>
</td><td class="codes"><pre class="brush: clojure">(defun load-average (&amp;optional use-floats)
  (let [last-minute (.getSystemLoadAverage (ManagementFactory/getOperatingSystemMXBean))]
    (list (if use-floats last-minute (long (* 100 last-minute))))))</pre></td></tr><tr><td class="docs"><p>Base64-encode the region between BEG and END.
  Return the length of the encoded text.
  Optional third argument NO-LINE-BREAK means do not break long lines
  into shorter lines.</p>
</td><td class="codes"><pre class="brush: clojure">(defun base64-encode-region (beg end &amp;optional no-line-break)
  (interactive &quot;r&quot;))</pre></td></tr><tr><td class="docs"><p>Return the weakness of TABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun hash-table-weakness (table)
  nil)</pre></td></tr><tr><td class="docs"><p>Clear hash table TABLE and return it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun clrhash (table)
  (empty table))</pre></td></tr><tr><td class="docs"><p>Concatenate all the arguments and make the result a vector.
  The result is a vector whose elements are the elements of all the arguments.
  Each argument may be a list, vector or string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun vconcat (&amp;rest sequences)
  (apply alloc/vector (apply c/concat sequences)))</pre></td></tr><tr><td class="docs"><p>Create and return a new hash table.</p>

<p>  Arguments are specified as keyword/argument pairs.  The following
  arguments are defined:</p>

<p>  :test TEST -- TEST must be a symbol that specifies how to compare
  keys.  Default is <code>eql'.  Predefined are the tests</code>eq', `eql', and
  `equal'.  User-supplied test and hash functions can be specified via
  `define-hash-table-test'.</p>

<p>  :size SIZE -- A hint as to how many elements will be put in the table.
  Default is 65.</p>

<p>  :rehash-size REHASH-SIZE - Indicates how to expand the table when it
  fills up.  If REHASH-SIZE is an integer, increase the size by that
  amount.  If it is a float, it must be > 1.0, and the new size is the
  old size multiplied by that factor.  Default is 1.5.</p>

<p>  :rehash-threshold THRESHOLD -- THRESHOLD must a float > 0, and &lt;= 1.0.
  Resize the hash table when the ratio (number of entries / table size)
  is greater than or equal to THRESHOLD.  Default is 0.8.</p>

<p>  :weakness WEAK -- WEAK must be one of nil, t, <code>key',</code>value',
  <code>key-or-value', or</code>key-and-value'.  If WEAK is not nil, the table
  returned is a weak table.  Key/value pairs are removed from a weak
  hash table when there are no non-weak references pointing to their
  key, value, one of key or value, or both key and value, depending on
  WEAK.  WEAK t is equivalent to `key-and-value'.  Default value of WEAK
  is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-hash-table (&amp;rest keyword-args)
  (let [{:keys [size rehash-threshold] :or {size 65 rehash-threshold 0.8}} (apply hash-map keyword-args)]
    (HashMap. size rehash-threshold)))</pre></td></tr><tr><td class="docs"><p>Return non-nil if KEY is `equal' to the cdr of an element of LIST.
  The value is actually the first element of LIST whose cdr equals KEY.</p>
</td><td class="codes"><pre class="brush: clojure">(defun rassoc (key list)
  (some #(c/and (data/consp %) (equal key (cdr %)) %) (cons/maybe-seq list)))</pre></td></tr><tr><td class="docs"><p>Return t if two Lisp objects have similar structure and contents.
  They must have the same data type.
  Conses are compared by comparing the cars and the cdrs.
  Vectors and strings are compared element by element.
  Numbers are compared by value, but integers cannot equal floats.
   (Use `=' if you want integers and floats to be able to be equal.)
  Symbols must match exactly.</p>
</td><td class="codes"><pre class="brush: clojure">(defun equal (o1 o2)
  (or (data/eq o1 o2)
      (if (and (seq? o1) (seq? o2))
        (c/and (equal (car o1) (car o2))
               (equal (cdr o1) (cdr o2)))
        (if (and (data/numberp o1) (data/numberp o2))
          (and (= (data/floatp o1) (data/floatp o2))
               (data/= o1 o2))
          (Objects/deepEquals o1 o2)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare reverse)</pre></td></tr><tr><td class="docs"><p>Reverse LIST by modifying cdr pointers.
  Return the reversed list.</p>
</td><td class="codes"><pre class="brush: clojure">(defun nreverse (list)
  (el/check-type 'listp list)
  (if (empty? list)
    list
    (loop [l list
           n (cdr list)
           r nil]
      (setcdr l r)
      (if (data/consp n)
        (recur n (cdr n) l)
        l))))</pre></td></tr><tr><td class="docs"><p>Reverse LIST, copying.  Return the reversed list.
  See also the function `nreverse', which is used more often.</p>
</td><td class="codes"><pre class="brush: clojure">(defun reverse (list)
  (el/check-type 'listp list)
  (when-not (data/null list)
    (apply alloc/list (c/reverse (apply alloc/list list)))))</pre></td></tr><tr><td class="docs"><p>Take cdr N times on LIST, return the result.</p>
</td><td class="codes"><pre class="brush: clojure">(defun nthcdr (n list)
  (loop [n n list list]
    (if (pos? n)
      (recur (dec n) (cdr list))
      (cons/maybe-seq list))))</pre></td></tr><tr><td class="docs"><p>Return the current rehash size of TABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun hash-table-rehash-size (table))</pre></td></tr><tr><td class="docs"><p>Store SYMBOL's PROPNAME property with value VALUE.
  It can be retrieved with `(get SYMBOL PROPNAME)'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun put (symbol propname value)
  (swap! el/symbol-plists assoc-in [(el/sym symbol) propname] value)
  value)</pre></td></tr><tr><td class="docs"><p>Base64-decode the region between BEG and END.
  Return the length of the decoded text.
  If the region can't be decoded, signal an error and don't modify the buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun base64-decode-region (beg end)
  (interactive &quot;r&quot;))</pre></td></tr><tr><td class="docs"><p>Return the Nth element of LIST.
  N counts from zero.  If LIST is not that long, nil is returned.</p>
</td><td class="codes"><pre class="brush: clojure">(defun nth (n list)
  (cons/maybe-seq
   (if (pos? n)
     (c/nth (cons/maybe-seq list) n nil)
     (car list))))</pre></td></tr><tr><td class="docs"><p>Return a unibyte string with the same individual chars as STRING.
  If STRING is unibyte, the result is STRING itself.
  Otherwise it is a newly created string, with no text properties,
  where each `eight-bit' character is converted to the corresponding byte.
  If STRING contains a non-ASCII, non-`eight-bit' character,
  an error is signaled.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-to-unibyte (string)
  (string-as-unibyte string))</pre></td></tr><tr><td class="docs"><p>Concatenate any number of lists by altering them.
  Only the last argument is not altered, and need not be a list.</p>
</td><td class="codes"><pre class="brush: clojure">(defun nconc (&amp;rest lists)
  (let [lists (map cons/maybe-seq (remove empty? lists))]
    (when (&gt; (count lists) 1)
      (loop [ls (rest lists)
             last (cons/last-cons (first lists))]
        (setcdr last (first ls))
        (when (seq (rest ls))
          (recur (rest ls)
                 (cons/last-cons (first ls))))))
    (first lists)))</pre></td></tr><tr><td class="docs"><p>Return the length of vector, list or string SEQUENCE.
  A byte-code function object is also allowed.
  If the string contains multibyte characters, this is not necessarily
  the number of bytes in the string; it is the number of characters.
  To get the number of bytes, use `string-bytes'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun length (sequence)
  (el/check-type 'sequencep sequence)
  (cond
   (instance? CharTable sequence)
   (count (.contents ^CharTable sequence))
   (data/listp sequence)
   (loop [cons sequence
          length 0]
     (if (and (not (data/null cons)) (data/listp cons))
       (recur (cdr cons) (inc length))
       (do
         (el/check-type 'listp cons)
         length)))
   :else (count sequence)))</pre></td></tr><tr><td class="docs"><p>Return non-nil if ELT is an element of LIST.  Comparison done with `eq'.
  The value is actually the tail of LIST whose car is ELT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun memq (elt list)
  (mem data/eq elt list))</pre></td></tr><tr><td class="docs"><p>Return non-nil if ELT is an element of LIST.  Comparison done with `eql'.
  The value is actually the tail of LIST whose car is ELT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun memql (elt list)
  (mem eql elt list))</pre></td></tr><tr><td class="docs"><p>Look up KEY in TABLE and return its associated value.
  If KEY is not found, return DFLT which defaults to nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun gethash (key table &amp;optional dflt)
  (c/get table key dflt))</pre></td></tr><tr><td class="docs"><p>Return the argument unchanged.</p>
</td><td class="codes"><pre class="brush: clojure">(defun identity (arg)
  arg)</pre></td></tr><tr><td class="docs"><p>Define a new hash table test with name NAME, a symbol.</p>

<p>  In hash tables created with NAME specified as test, use TEST to
  compare keys, and HASH for computing hash codes of keys.</p>

<p>  TEST must be a function taking two arguments and returning non-nil if
  both arguments are the same.  HASH must be a function taking one
  argument and return an integer that is the hash code of the argument.
  Hash code computation should use the whole value range of integers,
  including negative integers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun define-hash-table-test (name test hash))</pre></td></tr><tr><td class="docs"><p>Return the size of TABLE.
  The size can be used as an argument to `make-hash-table' to create
  a hash table than can hold as many elements as TABLE holds
  without need for resizing.</p>
</td><td class="codes"><pre class="brush: clojure">(defun hash-table-size (table)
  (count table))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare featurep)</pre></td></tr><tr><td class="docs"><p>If feature FEATURE is not loaded, load it from FILENAME.
  If FEATURE is not a member of the list `features', then the feature
  is not loaded; so load the file FILENAME.
  If FILENAME is omitted, the printname of FEATURE is used as the file name,
  and <code>load' will try to load this name appended with the suffix</code>.elc' or
  `.el', in that order.  The name without appended suffix will not be used.
  See `get-load-suffixes' for the complete list of suffixes.
  If the optional third argument NOERROR is non-nil,
  then return nil if the file is not found instead of signaling an error.
  Normally the return value is FEATURE.
  The normal messages at start and end of loading FILENAME are suppressed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun require (feature &amp;optional filename noerror)
  (when-not (featurep feature)
    (lread/load (or filename (name feature)) noerror true))
  feature)</pre></td></tr><tr><td class="docs"><p>Return the value of SYMBOL's PROPNAME property.
  This is the last value stored with `(put SYMBOL PROPNAME VALUE)'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get (symbol propname)
  (get-in @el/symbol-plists [(el/sym symbol) propname]))</pre></td></tr><tr><td class="docs"><p>Extract a value from a property list, comparing with `equal'.
  PLIST is a property list, which is a list of the form
  (PROP1 VALUE1 PROP2 VALUE2...).  This function returns the value
  corresponding to the given PROP, or nil if PROP is not
  one of the properties on the list.</p>
</td><td class="codes"><pre class="brush: clojure">(defun lax-plist-get (plist prop)
  (plist-get plist prop))</pre></td></tr><tr><td class="docs"><p>Call FUNCTION for all entries in hash table TABLE.
  FUNCTION is called with two arguments, KEY and VALUE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun maphash (function table)
  (let [f (el/fun function)]
    (dorun (map #(f (key %) (val %)) table))
    nil))</pre></td></tr><tr><td class="docs"><p>Return non-nil if KEY is `eq' to the cdr of an element of LIST.
  The value is actually the first element of LIST whose cdr is KEY.</p>
</td><td class="codes"><pre class="brush: clojure">(defun rassq (key list)
  (first (filter #(data/eq key (data/cdr-safe %))  list)))</pre></td></tr><tr><td class="docs"><p>Return the unibyte equivalent of STRING.
  Multibyte character codes are converted to unibyte according to
  <code>nonascii-translation-table' or, if that is nil,</code>nonascii-insert-offset'.
  If the lookup in the translation table fails, this function takes just
  the low 8 bits of each character.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-make-unibyte (string)
  (string-to-unibyte string))</pre></td></tr><tr><td class="docs"><p>Return t if first arg string is less than second in lexicographic order.
  Case is significant.
  Symbols are also allowed; their print names are used instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-lessp (s1 s2)
  (neg? (compare (str s1) (str s2))))</pre></td></tr><tr><td class="docs"><p>In WIDGET, set PROPERTY to VALUE.
  The value can later be retrieved with `widget-get'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun widget-put (widget property value))</pre></td></tr><tr><td class="docs"><p>Return a new string whose contents are a substring of STRING.
  The returned string consists of the characters between index FROM
  (inclusive) and index TO (exclusive) of STRING.  FROM and TO are
  zero-indexed: 0 means the first character of STRING.  Negative values
  are counted from the end of STRING.  If TO is nil, the substring runs
  to the end of STRING.</p>

<p>  The STRING argument may also be a vector.  In that case, the return
  value is a new vector that contains the elements between index FROM
  (inclusive) and index TO (exclusive) of that vector argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defun substring (string from &amp;optional to)
  (let [idx #(if (neg? %) (+ % (count string)) %)]
    (subs string (idx from) (idx (or to (count string))))))</pre></td></tr><tr><td class="docs"><p>Return t if FEATURE is present in this Emacs.</p>

<p>  Use this to conditionalize execution of lisp code based on the
  presence or absence of Emacs or environment extensions.
  Use `provide' to declare that a feature is available.  This function
  looks at the value of the variable `features'.  The optional argument
  SUBFEATURE can be used to check a specific subfeature of FEATURE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun featurep (feature &amp;optional subfeature)
  (boolean (some #{feature} globals/features)))</pre></td></tr><tr><td class="docs"><p>Return the current rehash threshold of TABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun hash-table-rehash-threshold (table))</pre></td></tr><tr><td class="docs"><p>Change value in PLIST of PROP to VAL.
  PLIST is a property list, which is a list of the form
  (PROP1 VALUE1 PROP2 VALUE2 ...).  PROP is a symbol and VAL is any object.
  If PROP is already a property on the list, its value is set to VAL,
  otherwise the new PROP VAL pair is added.  The new plist is returned;
  use `(setq x (plist-put x prop val))' to be sure to use the new value.
  The PLIST is modified by side effects.</p>
</td><td class="codes"><pre class="brush: clojure">(defun plist-put (plist prop val)
  (if-let [rest (memq prop plist)]
    (do (setcar (cdr rest) val)
        plist)
    (nconc plist (alloc/list prop val))))</pre></td></tr><tr><td class="docs"><p>Associate KEY with VALUE in hash table TABLE.
  If KEY is already present in table, replace its current value with
  VALUE.  In any case, return VALUE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun puthash (key value table)
  (.put ^Map table key value)
  value)</pre></td></tr><tr><td class="docs"><p>Return the test TABLE uses.</p>
</td><td class="codes"><pre class="brush: clojure">(defun hash-table-test (table))</pre></td></tr><tr><td class="docs"><p>Apply FUNCTION to each element of SEQUENCE for side effects only.
  Unlike `mapcar', don't accumulate the results.  Return SEQUENCE.
  SEQUENCE may be a list, a vector, a bool-vector, or a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun mapc (function sequence)
  (dorun (map (el/fun function) sequence))
  sequence)</pre></td></tr><tr><td class="docs"><p>Return non-nil if PLIST has the property PROP.
  PLIST is a property list, which is a list of the form
  (PROP1 VALUE1 PROP2 VALUE2 ...).  PROP is a symbol.
  Unlike `plist-get', this allows you to distinguish between a missing
  property and a property with the value nil.
  The value is actually the tail of PLIST whose car is PROP.</p>
</td><td class="codes"><pre class="brush: clojure">(defun plist-member (plist prop)
  ((plist-map plist) prop))</pre></td></tr><tr><td class="docs"><p>Sort LIST, stably, comparing elements using PREDICATE.
  Returns the sorted list.  LIST is modified by side effects.
  PREDICATE is called with two elements of LIST, and should return non-nil
  if the first element should sort before the second.</p>
</td><td class="codes"><pre class="brush: clojure">(defun sort (list predicate)
  (let [f (el/fun predicate)]
    (apply alloc/list (c/sort (fn [x y] (if (f x y) -1 1)) (cons/maybe-seq list)))))</pre></td></tr><tr><td class="docs"><p>Base64-decode STRING and return the result.</p>
</td><td class="codes"><pre class="brush: clojure">(defun base64-decode-string (string)
  (String. (DatatypeConverter/parseBase64Binary string) &quot;UTF-8&quot;))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.data" name="deuce.emacs.data"><h1 class="project-name">deuce.emacs.data</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.data
  (:use [deuce.emacs-lisp :only (defun defvar setq setq-default) :as el])
  (:require [clojure.core :as c]
            [deuce.emacs-lisp :as el]
            [deuce.emacs-lisp.globals :as globals]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs-lisp.cons :as cons]
            [taoensso.timbre :as timbre])
  (:import [java.nio ByteOrder]
           [java.io Writer]
           [java.lang.reflect Field]
           [clojure.lang Symbol Var])
  (:refer-clojure :exclude [+ * - / aset set &lt; = &gt; max &gt;= &lt;= mod atom min]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare consp car cdr set-default default-boundp markerp)</pre></td></tr><tr><td class="docs"><p>The largest value that is representable in a Lisp integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar most-positive-fixnum Long/MAX_VALUE)</pre></td></tr><tr><td class="docs"><p>The smallest value that is representable in a Lisp integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar most-negative-fixnum Long/MIN_VALUE)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private array-class (Class/forName &quot;[Ljava.lang.Object;&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method array-class [o ^Writer w]
  (print-method (vec (cons/ellipsis o)) w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup array-class [array ^Writer w]
  (.write w &quot;#el/vec [&quot;)
  (dotimes [idx (count array)]
    (print-dup (aget ^objects array idx) w)
    (when-not (c/= idx (dec (count array)))
      (.write w &quot; &quot;)))
  (.write w &quot;]&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup Symbol [s ^Writer w]
  (if (and (re-find  #&quot;([\\,/]|^\d|::|:$)&quot; (name s)) (not= &quot;/&quot; (name s)))
    (.write w (str &quot;#el/sym &quot; (pr-str (name s))))
    (.write w (str s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord CharTable
    [;; /* This holds a default value,
     ;; which is used whenever the value for a specific character is nil.  */
     defalt
     ;; /* This points to another char table, which we inherit from when the
     ;; value for a specific character is nil.  The `defalt' slot takes
     ;; precedence over this.  */
     parent
     ;; /* This is a symbol which says what kind of use this char-table is
     ;; meant for.  */
     purpose
     contents ;[(1 &lt;&lt; CHARTAB_SIZE_BITS_0)]
     ;; /* These hold additional data.  It is a vector.  */
     extras])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method CharTable [^CharTable char-table ^Writer w]
  (.write w (str &quot;#^&quot; (vec (cons/ellipsis (concat [(.defalt char-table)
                                                   @(.parent char-table)
                                                   (.purpose char-table)]
                                                  (.contents char-table)))))))</pre></td></tr><tr><td class="docs"><p>struct buffer_text in buffer.h. Contains many other low level fields we hopefully won't need.</p>
</td><td class="codes"><pre class="brush: clojure">(defrecord BufferText
    [;; /* Actual address of buffer contents.  If REL_ALLOC is defined,
     ;;    this address might change when blocks are relocated which can
     ;;    e.g. happen when malloc is called.  So, don't pass a pointer
     ;;    into a buffer's text to functions that malloc.  */
     beg;
     ;; /* This counts buffer-modification events
     ;;    for this buffer.  It is incremented for
     ;;    each such event, and never otherwise
     ;;    changed.  */
     modiff
     ;;	/* Previous value of modiff, as of last
     ;;    time buffer visited or saved a file.  */
     save-modiff
     ;; /* The markers that refer to this buffer.
     ;;    This is actually a single marker ---
     ;;    successive elements in its marker `chain'
     ;;    are the other markers referring to this buffer.
     ;;    This is a singly linked unordered list, which means that it's
     ;;    very cheap to add a marker to the list and it's also very cheap
     ;;    to move a marker within a buffer.  */
     markers])</pre></td></tr><tr><td class="docs"><p>struct buffer in buffer.h. Pretty large, so won't move it all over at once.
The buffer locals are specified with DEFVAR<em>PER</em>BUFFER, and their defaults with DEFVAR<em>BUFFER</em>DEFAULTS
Thet're all already defined as globals in buffer.clj. We need to put them (with default value at create) on this guy somehow.</p>
</td><td class="codes"><pre class="brush: clojure">(defrecord Buffer
    [;; /* This structure holds the coordinates of the buffer contents
     ;;    in ordinary buffers.  In indirect buffers, this is not used.  */
     own-text
     ;; /* This points to the `struct buffer_text' that used for this buffer.
     ;;    In an ordinary buffer, this is the own_text field above.
     ;;    In an indirect buffer, this is the own_text field of another buffer.  */
     text
     ;; /* Char position of point in buffer.  */
     pt
     ;; /* Char position of beginning of accessible range.  */
     begv
     ;; /* Char position of end of accessible range.  */
     zv
     ;; /* The name of this buffer.  */
     name
     ;; /* &quot;The mark&quot;.  This is a marker which may
     ;;    point into this buffer or may point nowhere.  */
     mark
     ;; /* Alist of elements (SYMBOL . VALUE-IN-THIS-BUFFER) for all
     ;;    per-buffer variables of this buffer.  For locally unbound
     ;;    symbols, just the symbol appears as the element.  */
     local-var-alist])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method Buffer [^Buffer buffer ^Writer w]
  (.write w (str &quot;#&lt;buffer &quot; @(.name buffer) &quot;&gt;&quot;)))</pre></td></tr><tr><td class="docs"><p>struct in buffer.h. Has many other fields, its also a linked list above. Attempting to use as a value object</p>
</td><td class="codes"><pre class="brush: clojure">(defrecord Marker
    [;; /* 1 means normal insertion at the marker's position
      ;;   leaves the marker after the inserted text.  */
     insertion-type
     ;; /* This is the buffer that the marker points into, or 0 if it points nowhere.
     ;;    Note: a chain of markers can contain markers pointing into different
     ;;    buffers (the chain is per buffer_text rather than per buffer, so it's
     ;;    shared between indirect buffers).  */
     ;; /* This is used for (other than NULL-checking):
     ;;    - Fmarker_buffer
     ;;    - Fset_marker: check eq(oldbuf, newbuf) to avoid unchain+rechain.
     ;;    - unchain_marker: to find the list from which to unchain.
     ;;    - Fkill_buffer: to only unchain the markers of current indirect buffer.
     ;;    */
     buffer;
     ;; /* This is the char position where the marker points.  */
     charpos])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method Marker [^Marker marker ^Writer w]
  (.write w (str &quot;#&lt;marker&quot; (if (and @(.charpos marker) @(.buffer marker))
                              (str &quot; at &quot; @(.charpos marker) &quot; in &quot; @(.name ^Buffer @(.buffer marker)))
                              (str &quot; in no buffer&quot;)) &quot;&gt;&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Frame
    [;; /* Name of this frame: a Lisp string.  It is used for looking up resources,
     ;;    as well as for the title in some cases.  */
     name
     ;; /* This frame's root window.  Every frame has one.
     ;;    If the frame has only a minibuffer window, this is it.
     ;;    Otherwise, if the frame has a minibuffer window, this is its sibling.  */
     root-window
     ;; /* This frame's selected window.
     ;;    Each frame has its own window hierarchy
     ;;    and one of the windows in it is selected within the frame.
     ;;    The selected window of the selected frame is Emacs's selected window.  */
     selected-window
     ;; /* This frame's minibuffer window.
     ;;    Most frames have their own minibuffer windows,
     ;;    but only the selected frame's minibuffer window
     ;;    can actually appear to exist.  */
     minibuffer-window
     ;; /* The terminal device that this frame uses.  If this is NULL, then
     ;;    the frame has been deleted. */
     terminal])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method Frame [^Frame frame ^Writer w]
  (.write w (str &quot;#&lt;frame &quot; (.name frame) &quot; &quot;
                 (format &quot;0x%x&quot; (System/identityHashCode frame)) &quot;&gt;&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Window
    [;; /* t if this window is a minibuffer window.  */
     mini-p
     ;; /* Following (to right or down) and preceding (to left or up) child
     ;;    at same level of tree.  */
     next prev
     ;; /* First child of this window: vchild is used if this is a vertical
     ;;    combination, hchild if this is a horizontal combination.  Of the
     ;;    fields vchild, hchild and buffer, one and only one is non-nil
     ;;    unless the window is dead.  */
     hchild
     vchild
     ;; /* The window this one is a child of.  */
     parent
     ;; /* The upper left corner coordinates of this window, as integers
     ;;    relative to upper left corner of frame = 0, 0.  */
     left-col
     top-line
     ;; /* The size of the window.  */
     total-lines
     total-cols
     ;; /* The normal size of the window.  */
     normal-lines
     normal-cols
     ;; /* The buffer displayed in this window.  Of the fields vchild,
     ;;    hchild and buffer, one and only one is non-nil unless the window
     ;;    is dead.  */
     buffer
     ;; /* A marker pointing to where in the text to start displaying.
     ;;    BIDI Note: This is the _logical-order_ start, i.e. the smallest
     ;;    buffer position visible in the window, not necessarily the
     ;;    character displayed in the top left corner of the window.  */
     start
     ;; /* A marker pointing to where in the text point is in this window,
     ;;    used only when the window is not selected.
     ;;    This exists so that when multiple windows show one buffer
     ;;    each one can have its own value of point.  */
     pointm
     ;; /* Unique number of window assigned when it was created.  */
     sequence-number])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method Window [^Window window ^Writer w]
  (.write w (str &quot;#&lt;window &quot; (.sequence-number window)
                 (when-let [buffer ^Buffer @(.buffer window)]
                   (str &quot; on &quot; @(.name buffer))) &quot;&gt;&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private coerce-number [x]
  (el/check-type 'number-or-marker-p
   (cond
     (char? x) (int x)
     (markerp x) @(.charpos ^Marker x)
     :else x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private coerce-numbers [xs]
  (map coerce-number xs))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a nonnegative integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun natnump (object)
  ((every-pred integer? (complement neg?)) object))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a marker (editor pointer).</p>
</td><td class="codes"><pre class="brush: clojure">(defun markerp (object)
  (instance? Marker object))</pre></td></tr><tr><td class="docs"><p>Return VALUE with its bits shifted left by COUNT.
  If COUNT is negative, shifting is actually to the right.
  In this case, the sign bit is duplicated.</p>
</td><td class="codes"><pre class="brush: clojure">(defun ash (value count)
  (if (pos? count)
    (bit-shift-left value count)
    (bit-shift-right value (c/- count))))</pre></td></tr><tr><td class="docs"><p>Return a symbol representing the type of OBJECT.
  The symbol returned names the object's basic type;
  for example, (type-of 1) returns `integer'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun type-of (object)
  (type object))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare symbol-function symbolp eq)</pre></td></tr><tr><td class="docs"><p>Navgeet's additions, not sure they've been tested against real world scenarios.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private indirect_function [object]
  (loop [hare object
         tortoise object]
    (if (symbolp hare)
      (let [hare1 (symbol-function hare)]
        (if (symbolp hare1)
          (let [hare2 (symbol-function hare1)
                tortoise1 (symbol-function tortoise)]
            (if (eq hare2 tortoise1)
              (el/throw 'cyclic-function-indirection '(object))
              (recur hare2 tortoise1)))
          hare1))
      hare)))</pre></td></tr><tr><td class="docs"><p>Return the function at the end of OBJECT's function chain.
  If OBJECT is not a symbol, just return it.  Otherwise, follow all
  function indirections to find the final function binding and return it.
  If the final symbol in the chain is unbound, signal a void-function error.
  Optional arg NOERROR non-nil means to return nil instead of signaling.
  Signal a cyclic-function-indirection error if there is a loop in the
  function chain of symbols.</p>
</td><td class="codes"><pre class="brush: clojure">(defun indirect-function (object &amp;optional noerror)
  (if (symbolp object)
    (el/try-with-tag
      (let [result (symbol-function object)]
        ;; Optimize for no indirection.
        (if (symbolp result)
          (indirect_function result)
          result))
      (catch 'void-function e
        (if noerror nil (throw e))))
    object))</pre></td></tr><tr><td class="docs"><p>Return SYMBOL's name, a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun symbol-name (symbol)
  (el/check-type 'symbolp symbol)
  (condp some [symbol]
    keyword? (str symbol)
    symbol? (name symbol)
    true? &quot;true&quot;
    nil? (pr-str nil)))</pre></td></tr><tr><td class="docs"><p>Make SYMBOL's value be void.
  Return SYMBOL.</p>
</td><td class="codes"><pre class="brush: clojure">(defun makunbound (symbol)
  (ns-unmap 'deuce.emacs-lisp.globals (el/sym symbol))
  symbol)</pre></td></tr><tr><td class="docs"><p>Return the interactive form of CMD or nil if none.
  If CMD is not a command, the return value is nil.
  Value, if non-nil, is a list (interactive SPEC).</p>
</td><td class="codes"><pre class="brush: clojure">(defun interactive-form (cmd))</pre></td></tr><tr><td class="docs"><p>Return bitwise-or of all the arguments.
  Arguments may be integers, or markers converted to integers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun logior (&amp;rest ints-or-markers)
  (apply bit-or (coerce-numbers ints-or-markers)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare arrayp listp)</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a sequence (list or array).</p>
</td><td class="codes"><pre class="brush: clojure">(defun sequencep (object)
  ((some-fn sequential? arrayp listp) object))</pre></td></tr><tr><td class="docs"><p>Return t if NUMBER is zero.</p>
</td><td class="codes"><pre class="brush: clojure">(defun zerop (number)
  (zero? number))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare symbol-value)</pre></td></tr><tr><td class="docs"><p>Return the variable at the end of OBJECT's variable chain.
  If OBJECT is a symbol, follow all variable indirections and return the final
  variable.  If OBJECT is not a symbol, just return it.
  Signal a cyclic-variable-indirection error if there is a loop in the
  variable chain of symbols.</p>
</td><td class="codes"><pre class="brush: clojure">(defun indirect-variable (object)
  (symbol-value object))</pre></td></tr><tr><td class="docs"><p>Return SYMBOL's value.  Error if that is void.</p>
</td><td class="codes"><pre class="brush: clojure">(defun symbol-value (symbol)
  (el/check-type 'symbolp symbol)
  (el/el-var-get* symbol))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a keyword.
  This means that it is a symbol with a print name beginning with `:'
  interned in the initial obarray.</p>
</td><td class="codes"><pre class="brush: clojure">(defun keywordp (object)
  (keyword? object))</pre></td></tr><tr><td class="docs"><p>Return NUMBER plus one.  NUMBER may be a number or a marker.
  Markers are converted to integers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun #el/sym &quot;1+&quot; (number)
  (inc (coerce-number number)))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a built-in function.</p>
</td><td class="codes"><pre class="brush: clojure">(defun subrp (object)
  (and (fn? object)
       (-&gt; object meta :ns)
       (not= (the-ns 'deuce.emacs) (-&gt; object meta :ns))))</pre></td></tr><tr><td class="docs"><p>Return SYMBOL's property list.</p>
</td><td class="codes"><pre class="brush: clojure">(defun symbol-plist (symbol)
  (cons/maybe-seq (map #(cons/pair (key val) (val %)) (@el/symbol-plists 'symbol))))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun stringp (object)
  (string? object))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is an integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun integerp (object)
  ((some-fn integer? char?) object))</pre></td></tr><tr><td class="docs"><p>Return t if SYMBOL's function definition is not void.</p>
</td><td class="codes"><pre class="brush: clojure">(defun fboundp (symbol)
  (when-let [v (and symbol (el/fun symbol))]
    (bound? v)))</pre></td></tr><tr><td class="docs"><p>Return remainder of X divided by Y.
  Both must be integers or markers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun % (x y)
  (rem x y))</pre></td></tr><tr><td class="docs"><p>Return sum of any number of arguments, which are numbers or markers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun + (&amp;rest numbers-or-markers)
  (apply c/+ (coerce-numbers numbers-or-markers)))</pre></td></tr><tr><td class="docs"><p>Return VALUE with its bits shifted left by COUNT.
  If COUNT is negative, shifting is actually to the right.
  In this case, zeros are shifted in on the left.</p>
</td><td class="codes"><pre class="brush: clojure">(defun lsh (value count)
  (if (pos? count)
    (bit-shift-left value count)
    (bit-shift-right value (c/- count))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare null)</pre></td></tr><tr><td class="docs"><p>Return t if the two args are the same Lisp object.</p>
</td><td class="codes"><pre class="brush: clojure">(defun eq (obj1 obj2)
  (cond
   (null obj1) (null obj2)
    ;; Macros can get confused by the exact namespace
   (and (symbol? obj1) (symbol? obj2)) (c/= (name obj1) (name obj2))
   (and (char? obj1) (char? obj2)) (c/= (coerce-number obj1) (coerce-number obj2))
   :else (identical? obj1 obj2)))</pre></td></tr><tr><td class="docs"><p>Return product of any number of arguments, which are numbers or markers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun * (&amp;rest numbers-or-markers)
  (apply c/* (coerce-numbers numbers-or-markers)))</pre></td></tr><tr><td class="docs"><p>Negate number or subtract numbers or markers and return the result.
  With one arg, negates it.  With more than one arg,
  subtracts all but the first from the first.</p>
</td><td class="codes"><pre class="brush: clojure">(defun - (&amp;optional number-or-marker &amp;rest more-numbers-or-markers)
  (apply c/- (coerce-numbers (c/cons number-or-marker more-numbers-or-markers))))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a multibyte string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun multibyte-string-p (object)
  (string? object))</pre></td></tr><tr><td class="docs"><p>Return bitwise-exclusive-or of all the arguments.
  Arguments may be integers, or markers converted to integers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun logxor (&amp;rest ints-or-markers)
  (apply c/bit-xor (coerce-numbers ints-or-markers))  )</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a floating point number.</p>
</td><td class="codes"><pre class="brush: clojure">(defun floatp (object)
  (float? object))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a number or a marker.</p>
</td><td class="codes"><pre class="brush: clojure">(defun number-or-marker-p (object)
  ((some-fn number? markerp) object))</pre></td></tr><tr><td class="docs"><p>Return the cdr of OBJECT if it is a cons cell, or else nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun cdr-safe (object)
  (when (consp object)
    (cdr object)))</pre></td></tr><tr><td class="docs"><p>Return first argument divided by all the remaining arguments.
  The arguments must be numbers or markers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun / (dividend divisor &amp;rest divisors)
  (if (zero? divisor)
    (el/throw 'arith-error nil)
    (c/reduce / (c/let [r (c/apply clojure.core// (coerce-numbers [dividend divisor]))]
                  (if (ratio? r) (long r) r))
              (coerce-numbers divisors))))</pre></td></tr><tr><td class="docs"><p>Return the byteorder for the machine.
  Returns 66 (ASCII uppercase B) for big endian machines or 108 (ASCII
  lowercase l) for small endian machines.</p>
</td><td class="codes"><pre class="brush: clojure">(defun byteorder ()
  ({ByteOrder/BIG_ENDIAN &quot;B&quot;
    ByteOrder/LITTLE_ENDIAN &quot;l&quot;}
   (ByteOrder/nativeOrder)))</pre></td></tr><tr><td class="docs"><p>Return name of subroutine SUBR.
  SUBR must be a built-in function.</p>
</td><td class="codes"><pre class="brush: clojure">(defun subr-name (subr)
  (-&gt; subr meta :name))</pre></td></tr><tr><td class="docs"><p>Make VARIABLE have a separate value in the current buffer.
  Other buffers will continue to share a common default value.
  (The buffer-local value of VARIABLE starts out as the same value
  VARIABLE previously had.  If VARIABLE was void, it remains void.)
  Return VARIABLE.</p>

<p>  If the variable is already arranged to become local when set,
  this function causes a local value to exist for this buffer,
  just as setting the variable would do.</p>

<p>  This function returns VARIABLE, and therefore
    (set (make-local-variable 'VARIABLE) VALUE-EXP)
  works.</p>

<p>  See also `make-variable-buffer-local'.</p>

<p>  Do not use `make-local-variable' to make a hook variable buffer-local.
  Instead, use `add-hook' and specify t for the LOCAL argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-local-variable (variable)
  (interactive &quot;vMake Local Variable: &quot;)
  (let [buffer-locals (.local-var-alist ^Buffer ((el/fun 'current-buffer)))]
    (when-not (contains? @buffer-locals variable)
      (swap! buffer-locals assoc variable (Var/create)))
    variable))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a number (floating point or integer).</p>
</td><td class="codes"><pre class="brush: clojure">(defun numberp (object)
  ((some-fn number? integerp) object))</pre></td></tr><tr><td class="docs"><p>Return bitwise-and of all the arguments.
  Arguments may be integers, or markers converted to integers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun logand (&amp;rest ints-or-markers)
  (apply c/bit-and (coerce-numbers ints-or-markers)))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a cons cell.</p>
</td><td class="codes"><pre class="brush: clojure">(defun consp (object)
  (cons/consp object))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a list, that is, a cons cell or nil.
  Otherwise, return nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun listp (object)
  (cons/listp object))</pre></td></tr><tr><td class="docs"><p>Return the element of ARRAY at index IDX.
  ARRAY may be a vector, a string, a char-table, a bool-vector,
  or a byte-code object.  IDX starts at 0.</p>
</td><td class="codes"><pre class="brush: clojure">(defun aref (array idx)
  (if (instance? CharTable array)
    (aref (.contents ^CharTable array) (int idx))
    (get array idx)))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a nonnegative integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun wholenump (object)
  ((every-pred integer? pos?) (coerce-number object)))</pre></td></tr><tr><td class="docs"><p>We probably don't want to do this due to interned strings.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:private string-chars (doto (.getDeclaredField String &quot;value&quot;)
                                     (.setAccessible true)))</pre></td></tr><tr><td class="docs"><p>Store into the element of ARRAY at index IDX the value NEWELT.
  Return NEWELT.  ARRAY may be a vector, a string, a char-table or a
  bool-vector.  IDX starts at 0.</p>
</td><td class="codes"><pre class="brush: clojure">(defun aset (array idx newelt)
  (if (instance? CharTable array)
    (aset (.contents ^CharTable array) idx newelt)
    (if (string? array)
      (do (timbre/warn &quot;modifying String&quot; (str &quot;\&quot;&quot; array &quot;\&quot;&quot;))
        (c/aset ^chars (.get ^Field string-chars array) idx (char newelt)))
      (c/aset ^objects array idx newelt))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare vectorp char-table-p)</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is an array (string or vector).</p>
</td><td class="codes"><pre class="brush: clojure">(defun arrayp (object)
  ((some-fn vectorp stringp char-table-p) object))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defun vectorp (object)
  (c/= array-class (type object)))</pre></td></tr><tr><td class="docs"><p>Make SYMBOL's function definition be void.
  Return SYMBOL.</p>
</td><td class="codes"><pre class="brush: clojure">(defun fmakunbound (symbol)
  (when-let [fun (el/fun (el/sym symbol))]
    (ns-unmap (-&gt; (el/fun symbol) meta :ns) (el/sym symbol)))
  symbol)</pre></td></tr><tr><td class="docs"><p>Return the bitwise complement of NUMBER.  NUMBER must be an integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun lognot (number)
  (bit-not (coerce-number number)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare atom)</pre></td></tr><tr><td class="docs"><p>Set the cdr of CELL to be NEWCDR.  Returns NEWCDR.</p>
</td><td class="codes"><pre class="brush: clojure">(defun setcdr (cell newcdr)
  (el/check-type 'consp cell)
  (cons/setcdr cell (cons/maybe-seq newcdr)))</pre></td></tr><tr><td class="docs"><p>Set SYMBOL's value to NEWVAL, and return NEWVAL.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set (symbol newval)
  (el/check-type 'symbolp symbol)
  (if (c/= symbol (c/symbol &quot;&quot;))
    nil ;; Hack for anonymous symbol used by abbrev.el, needs proper fix.
    (el/el-var-set* symbol newval)))</pre></td></tr><tr><td class="docs"><p>Return t if first arg is less than second arg.  Both must be numbers or markers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun &lt; (num1 num2)
  (c/&lt; (coerce-number num1) (coerce-number num2)))</pre></td></tr><tr><td class="docs"><p>Return the car of OBJECT if it is a cons cell, or else nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun car-safe (object)
  (when (consp object)
    (car object)))</pre></td></tr><tr><td class="docs"><p>Set SYMBOL's function definition to DEFINITION, and return DEFINITION.</p>
</td><td class="codes"><pre class="brush: clojure">(defun fset (symbol definition)
  (el/check-type 'symbolp symbol)
  (let [symbol (el/sym symbol)
        sym (el/fun symbol)]
    ;; Navgeet's additions, not sure they've been tested against real world scenarios.
    (when sym
      (when (and (consp @sym) (c/= (car @sym) 'autoload))
        ;; Creates a cyclic load dependency chain.
        ;; TODO: deuce.emacs.fns/put must be below deuce.emacs.data
        ;; (fns/put symbol 'autoload (cdr @sym))))
    (ns-unmap 'deuce.emacs symbol)
    (intern 'deuce.emacs symbol definition)
    definition))</pre></td></tr><tr><td class="docs"><p>Return the cdr of LIST.  If arg is nil, return nil.
  Error if arg is not nil and not a cons cell.  See also `cdr-safe'.</p>

<p>  See Info node `(elisp)Cons Cells' for a discussion of related basic
  Lisp concepts such as cdr, car, cons cell and list.</p>
</td><td class="codes"><pre class="brush: clojure">(defun cdr (list)
  (el/check-type 'listp list)
  (cons/cdr (cons/maybe-seq list)))</pre></td></tr><tr><td class="docs"><p>Return t if two args, both numbers or markers, are equal.</p>
</td><td class="codes"><pre class="brush: clojure">(defun = (num1 num2)
  (== (coerce-number num1) (coerce-number num2)))</pre></td></tr><tr><td class="docs"><p>Make VARIABLE become buffer-local whenever it is set.
  At any time, the value for the current buffer is in effect,
  unless the variable has never been set in this buffer,
  in which case the default value is in effect.
  Note that binding the variable with `let', or setting it while
  a `let'-style binding made in this buffer is in effect,
  does not make the variable buffer-local.  Return VARIABLE.</p>

<p>  In most cases it is better to use `make-local-variable',
  which makes a variable local in just one buffer.</p>

<p>  The function <code>default-value' gets the default value and</code>set-default' sets it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-variable-buffer-local (variable)
  (interactive &quot;vMake Variable Buffer Local: &quot;)
  (when-not (default-boundp variable)
    (set-default variable nil))
  (swap! el/buffer-locals conj variable)
  variable)</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a character or a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-or-string-p (object)
  ((some-fn char? integer? string?) object))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a char-table or vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defun vector-or-char-table-p (object)
  ((some-fn vectorp char-table-p) object))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is an editor buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun bufferp (object)
  (instance? Buffer object))</pre></td></tr><tr><td class="docs"><p>Return t if first arg is greater than second arg.  Both must be numbers or markers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun &gt; (num1 num2)
  (c/&gt; (coerce-number num1) (coerce-number num2)))</pre></td></tr><tr><td class="docs"><p>Return largest of all the arguments (which must be numbers or markers).
  The value is always a number; markers are converted to numbers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun max (number-or-marker &amp;rest numbers-or-markers)
  (apply c/max number-or-marker numbers-or-markers))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare local-variable-p)</pre></td></tr><tr><td class="docs"><p>Non-nil if VARIABLE will be local in buffer BUFFER when set there.
  More precisely, this means that setting the variable (with <code>set' or</code>setq'),
  while it does not have a `let'-style binding that was made in BUFFER,
  will produce a buffer local binding.  See Info node
  `(elisp)Creating Buffer-Local'.
  BUFFER defaults to the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun local-variable-if-set-p (variable &amp;optional buffer)
  (when (or (contains? @el/buffer-locals variable)
            (local-variable-p variable buffer))
    true))</pre></td></tr><tr><td class="docs"><p>Return t if SYMBOL has a non-void default value.
  This is the value that is seen in buffers that do not have their own values
  for this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defun default-boundp (symbol)
  (or (nil? symbol)
      (when-let [^Var v (el/global symbol)]
        (.hasRoot v))))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is not a list.  Lists include nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun nlistp (object)
  ((complement listp) object))</pre></td></tr><tr><td class="docs"><p>Return t if first arg is greater than or equal to second arg.
  Both must be numbers or markers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun &gt;= (num1 num2)
  (c/&gt;= (coerce-number num1) (coerce-number num2)))</pre></td></tr><tr><td class="docs"><p>Return t if SYMBOL's value is not void.</p>
</td><td class="codes"><pre class="brush: clojure">(defun boundp (symbol)
  (or (nil? symbol)
      (when-let [v (el/el-var symbol)]
        (bound? v))))</pre></td></tr><tr><td class="docs"><p>Return SYMBOL's default value.
  This is the value that is seen in buffers that do not have their own values
  for this variable.  The default value is meaningful for variables with
  local bindings in certain buffers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun default-value (symbol)
  (if-let [^Var v (el/global symbol)]
    (.getRawRoot v)
    (el/throw* 'void-variable (list symbol))))</pre></td></tr><tr><td class="docs"><p>Set the car of CELL to be NEWCAR.  Returns NEWCAR.</p>
</td><td class="codes"><pre class="brush: clojure">(defun setcar (cell newcar)
  (el/check-type 'consp cell)
  (cons/setcar cell (cons/maybe-seq newcar)))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a symbol.</p>
</td><td class="codes"><pre class="brush: clojure">(defun symbolp (object)
  (or ((some-fn symbol? keyword? nil? true?) object)
      (and (seq? object) (c/= `deref (first object)) (symbolp (second object)))))</pre></td></tr><tr><td class="docs"><p>Return t if first arg is less than or equal to second arg.
  Both must be numbers or markers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun &lt;= (num1 num2)
  (c/&lt;= (coerce-number num1) (coerce-number num2)))</pre></td></tr><tr><td class="docs"><p>Non-nil if VARIABLE has a local binding in buffer BUFFER.
  BUFFER defaults to the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun local-variable-p (variable &amp;optional buffer)
  (let [buffer-locals @(.local-var-alist ^Buffer (el/check-type 'bufferp (or buffer ((el/fun 'current-buffer)))))]
    (when (contains? buffer-locals variable)
      true)))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a byte-compiled function object.</p>
</td><td class="codes"><pre class="brush: clojure">(defun byte-code-function-p (object)
  (fn? object))</pre></td></tr><tr><td class="docs"><p>Set SYMBOL's function definition to DEFINITION, and return DEFINITION.
  Associates the function with the current load file, if any.
  The optional third argument DOCSTRING specifies the documentation string
  for SYMBOL; if it is omitted or nil, SYMBOL uses the documentation string
  determined by DEFINITION.</p>
</td><td class="codes"><pre class="brush: clojure">(defun defalias (symbol definition &amp;optional docstring)
  (let [lambda? (fn? definition)
        f (and (or lambda? (symbol? definition))  ;; guard against value
               (el/fun definition))]
    (when-let [alias (if-not lambda?
                       (fn alias [&amp;form &amp;env &amp; args] ;; Note implicit macro args
                         `(el/progn (~(el/fun definition) ~@args)))
                       definition)]
      (ns-unmap 'deuce.emacs symbol)
      (el/defvar-helper* 'deuce.emacs symbol alias (str symbol &quot; is an alias for `&quot; definition &quot;'.\n\n&quot;
                                                        (or docstring
                                                            (-&gt; f meta :doc)
                                                            (-&gt; definition meta :doc))))
      (alter-meta! (el/fun symbol) assoc :alias definition)
      (when-not lambda? (.setMacro ^Var (ns-resolve 'deuce.emacs symbol)))
      ;; We want this, but it currently wrecks havoc due to backquote
      ;; (when (and lambda? (-&gt; definition meta :macro)))
      ;;   (.setMacro (el/fun symbol)))))
    definition))</pre></td></tr><tr><td class="docs"><p>Set SYMBOL's property list to NEWPLIST, and return NEWPLIST.</p>
</td><td class="codes"><pre class="brush: clojure">(defun setplist (symbol newplist)
  (swap! el/symbol-plists assoc symbol (into {} (map #(vector (car %) (cdr %)) newplist)))
  newplist)</pre></td></tr><tr><td class="docs"><p>Set SYMBOL's default value to VALUE.  SYMBOL and VALUE are evaluated.
  The default value is seen in buffers that do not have their own values
  for this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-default (symbol value)
  (el/check-type 'symbolp symbol)
  (el/el-var-set-default* symbol value))</pre></td></tr><tr><td class="docs"><p>Return SYMBOL's function definition.  Error if that is void.</p>
</td><td class="codes"><pre class="brush: clojure">(defun symbol-function (symbol)
  (el/check-type 'symbolp symbol)
  (if-let [f (el/fun symbol)] ;; This should probably not use el/fun, as you can store keymaps and what not as functions.
    (if (var? f) (el/fun f) f) ;; See binding/mode-specific-command-prefix
    (el/throw 'void-function symbol)))</pre></td></tr><tr><td class="docs"><p>Make VARIABLE no longer have a separate value in the current buffer.
  From now on the default value will apply in this buffer.  Return VARIABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun kill-local-variable (variable)
  (interactive &quot;vKill Local Variable: &quot;)
  (let [buffer-locals (.local-var-alist ^Buffer ((el/fun 'current-buffer)))]
    (swap! buffer-locals dissoc variable)
    variable))</pre></td></tr><tr><td class="docs"><p>Return the car of LIST.  If arg is nil, return nil.
  Error if arg is not nil and not a cons cell.  See also `car-safe'.</p>

<p>  See Info node `(elisp)Cons Cells' for a discussion of related basic
  Lisp concepts such as car, cdr, cons cell and list.</p>
</td><td class="codes"><pre class="brush: clojure">(defun car (list)
  (el/check-type 'listp list)
  (cons/maybe-seq (cons/car list)))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a bool-vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defun bool-vector-p (object))</pre></td></tr><tr><td class="docs"><p>Return minimum and maximum number of args allowed for SUBR.
  SUBR must be a built-in function.
  The returned value is a pair (MIN . MAX).  MIN is the minimum number
  of args.  MAX is the maximum number or the symbol `many', for a
  function with <code>&amp;rest' args, or</code>unevalled' for a special form.</p>
</td><td class="codes"><pre class="brush: clojure">(defun subr-arity (subr)
  (-&gt; subr meta :arglists first count))</pre></td></tr><tr><td class="docs"><p>Return X modulo Y.
  The result falls between zero (inclusive) and Y (exclusive).
  Both X and Y must be numbers or markers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun mod (x y)
  (c/mod x y))</pre></td></tr><tr><td class="docs"><p>Return NUMBER minus one.  NUMBER may be a number or a marker.
  Markers are converted to integers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun #el/sym &quot;1-&quot; (number)
  (dec (coerce-number number)))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is not a cons cell.  This includes nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun atom (object)
  (not (consp object)))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun null (object)
  (when (or (nil? object) (c/= () object) (false? object))
    true))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a char-table.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-table-p (object)
  (instance? CharTable object))</pre></td></tr><tr><td class="docs"><p>This function is obsolete since 22.2;
  explicitly check for a frame-parameter instead.</p>

<p>  Enable VARIABLE to have frame-local bindings.
  This does not create any frame-local bindings for VARIABLE,
  it just makes them possible.</p>

<p>  A frame-local binding is actually a frame parameter value.
  If a frame F has a value for the frame parameter named VARIABLE,
  that also acts as a frame-local binding for VARIABLE in F--
  provided this function has been called to enable VARIABLE
  to have frame-local bindings at all.</p>

<p>  The only way to create a frame-local binding for VARIABLE in a frame
  is to set the VARIABLE frame parameter of that frame.  See
  `modify-frame-parameters' for how to set frame parameters.</p>

<p>  Note that since Emacs 23.1, variables cannot be both buffer-local and
  frame-local any more (buffer-local bindings used to take precedence over
  frame-local bindings).</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-variable-frame-local (variable)
  (interactive &quot;vMake Variable Frame Local: &quot;))</pre></td></tr><tr><td class="docs"><p>Return the decimal representation of NUMBER as a string.
  Uses a minus sign if negative.
  NUMBER may be an integer or a floating point number.</p>
</td><td class="codes"><pre class="brush: clojure">(defun number-to-string (number)
  (str number))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is an integer or a marker (editor pointer).</p>
</td><td class="codes"><pre class="brush: clojure">(defun integer-or-marker-p (object)
  ((some-fn integerp markerp) object))</pre></td></tr><tr><td class="docs"><p>Return smallest of all the arguments (which must be numbers or markers).
  The value is always a number; markers are converted to numbers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun min (number-or-marker &amp;rest numbers-or-markers)
  (apply c/min number-or-marker numbers-or-markers))</pre></td></tr><tr><td class="docs"><p>Parse STRING as a decimal number and return the number.
  This parses both integers and floating point numbers.
  It ignores leading spaces and tabs, and all trailing chars.</p>

<p>  If BASE, interpret STRING as a number in that base.  If BASE isn't
  present, base 10 is used.  BASE must be between 2 and 16 (inclusive).
  If the base used is not 10, STRING is always parsed as integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-to-number (string &amp;optional base)
  (try
    (long (BigInteger. (str string) (int (or base 10))))
    (catch NumberFormatException _
      (Double/parseDouble string))))</pre></td></tr><tr><td class="docs"><p>Return a value indicating where VARIABLE's current binding comes from.
  If the current binding is buffer-local, the value is the current buffer.
  If the current binding is frame-local, the value is the selected frame.
  If the current binding is global (the default), the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun variable-binding-locus (variable))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.callproc" name="deuce.emacs.callproc"><h1 class="project-name">deuce.emacs.callproc</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.callproc
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [clojure.java.io :as io]
            [clojure.java.shell :as sh]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns])
  (:import [java.io File])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Directory containing the DOC file that comes with GNU Emacs.
  This is usually the same as `data-directory'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar doc-directory &quot;etc/&quot;)</pre></td></tr><tr><td class="docs"><p>Directory of score files for games which come with GNU Emacs.
  If this variable is nil, then Emacs is unable to use a shared directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar shared-game-score-directory nil)</pre></td></tr><tr><td class="docs"><p>*List of suffixes to try to find executable file names.
  Each element is a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar exec-suffixes '(&quot;&quot;))</pre></td></tr><tr><td class="docs"><p>*File name to load inferior shells from.
  Initialized from the SHELL environment variable, or to a system-dependent
  default if SHELL is not set.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar shell-file-name (System/getenv &quot;SHELL&quot;))</pre></td></tr><tr><td class="docs"><p>*List of directories to search programs to run in subprocesses.
  Each element is a string (directory name) or nil (try default directory).</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar exec-path (apply list (.split (System/getenv &quot;PATH&quot;) File/pathSeparator)))</pre></td></tr><tr><td class="docs"><p>List of environment variables inherited from the parent process.
  Each element should be a string of the form ENVVARNAME=VALUE.
  The elements must normally be decoded (using `locale-coding-system') for use.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar initial-environment (apply list (map str (System/getenv))))</pre></td></tr><tr><td class="docs"><p>Directory of machine-independent files that come with GNU Emacs.
  These are files intended for Emacs to use while it runs.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar data-directory &quot;etc/&quot;)</pre></td></tr><tr><td class="docs"><p>List of overridden environment variables for subprocesses to inherit.
  Each element should be a string of the form ENVVARNAME=VALUE.</p>

<p>  Entries in this list take precedence to those in the frame-local
  environments.  Therefore, let-binding `process-environment' is an easy
  way to temporarily change the value of an environment variable,
  irrespective of where it comes from.  To use `process-environment' to
  remove an environment variable, include only its name in the list,
  without "=VALUE".</p>

<p>  This variable is set to nil when Emacs starts.</p>

<p>  If multiple entries define the same variable, the first one always
  takes precedence.</p>

<p>  Non-ASCII characters are encoded according to the initial value of
  `locale-coding-system', i.e. the elements must normally be decoded for
  use.</p>

<p>  See <code>setenv' and</code>getenv'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar process-environment (apply list (map (partial s/join &quot;=&quot;) (into {} (System/getenv)))))</pre></td></tr><tr><td class="docs"><p>Directory for executables for Emacs to invoke.
  More generally, this includes any architecture-dependent files
  that are built and installed from the Emacs distribution.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar exec-directory nil)</pre></td></tr><tr><td class="docs"><p>For internal use by the build procedure only.
  This is the name of the directory in which the build procedure installed
  Emacs's info files; the default value for `Info-default-directory-list'
  includes this.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar configure-info-directory &quot;/use/share/info&quot;)</pre></td></tr><tr><td class="docs"><p>Get the value of environment variable VARIABLE.
  VARIABLE should be a string.  Value is nil if VARIABLE is undefined in
  the environment.  Otherwise, value is a string.</p>

<p>  This function searches `process-environment' for VARIABLE.</p>

<p>  If optional parameter ENV is a list, then search this list instead of
  `process-environment', and return t when encountering a negative entry
  (an entry for a variable with no value).</p>
</td><td class="codes"><pre class="brush: clojure">(defun getenv-internal (variable &amp;optional env)
  (if-not env
    (System/getenv variable)
    (throw (IllegalArgumentException. &quot;doesn't yet support env argument&quot;))))</pre></td></tr><tr><td class="docs"><p>Send text from START to END to a synchronous process running PROGRAM.
  The remaining arguments are optional.
  Delete the text if fourth arg DELETE is non-nil.</p>

<p>  Insert output in BUFFER before point; t means current buffer; nil for
   BUFFER means discard it; 0 means discard and don't wait; and `(:file
   FILE)', where FILE is a file name string, means that it should be
   written to that file (if the file already exists it is overwritten).
  BUFFER can also have the form (REAL-BUFFER STDERR-FILE); in that case,
  REAL-BUFFER says what to do with standard output, as above,
  while STDERR-FILE says what to do with standard error in the child.
  STDERR-FILE may be nil (discard standard error output),
  t (mix it with ordinary output), or a file name string.</p>

<p>  Sixth arg DISPLAY non-nil means redisplay buffer as output is inserted.
  Remaining args are passed to PROGRAM at startup as command args.</p>

<p>  If BUFFER is 0, `call-process-region' returns immediately with value nil.
  Otherwise it waits for PROGRAM to terminate
  and returns a numeric exit status or a signal description string.
  If you quit, the process is killed with SIGINT, or SIGKILL if you quit again.</p>
</td><td class="codes"><pre class="brush: clojure">(defun call-process-region (start end program &amp;optional delete buffer display &amp;rest args))</pre></td></tr><tr><td class="docs"><p>Call PROGRAM synchronously in separate process.
  The remaining arguments are optional.
  The program's input comes from file INFILE (nil means `/dev/null').
  Insert output in BUFFER before point; t means current buffer; nil for BUFFER
   means discard it; 0 means discard and don't wait; and `(:file FILE)', where
   FILE is a file name string, means that it should be written to that file
   (if the file already exists it is overwritten).
  BUFFER can also have the form (REAL-BUFFER STDERR-FILE); in that case,
  REAL-BUFFER says what to do with standard output, as above,
  while STDERR-FILE says what to do with standard error in the child.
  STDERR-FILE may be nil (discard standard error output),
  t (mix it with ordinary output), or a file name string.</p>

<p>  Fourth arg DISPLAY non-nil means redisplay buffer as output is inserted.
  Remaining arguments are strings passed as command arguments to PROGRAM.</p>

<p>  If executable PROGRAM can't be found as an executable, `call-process'
  signals a Lisp error.  `call-process' reports errors in execution of
  the program only through its return and output.</p>

<p>  If BUFFER is 0, `call-process' returns immediately with value nil.
  Otherwise it waits for PROGRAM to terminate
  and returns a numeric exit status or a signal description string.
  If you quit, the process is killed with SIGINT, or SIGKILL if you quit again.</p>
</td><td class="codes"><pre class="brush: clojure">(defun call-process (program &amp;optional infile buffer display &amp;rest args)
  (let [opts (if infile [:in (io/file infile)] [])
        no-wait? (= 0 buffer)
        buffer (or no-wait?
                   (and (data/consp buffer) (= :file (data/car buffer)) (data/cdr buffer))
                   (and (true? buffer) (buffer/current-buffer))
                   (el/check-type 'bufferp (or (when (data/consp buffer) (data/car buffer))
                                               buffer (buffer/current-buffer))))
        stderr (when (data/consp buffer) (data/cdr buffer))
        runner (if no-wait? #(do (future-call %) nil) #(%))]
    (runner #(let [{:keys [exit out err]}
                   (apply sh/sh (concat (cons program args) opts))]
               (when (data/bufferp buffer)
                 (binding [buffer/*current-buffer* buffer]
                   (editfns/insert out)
                   (when (true? stderr)
                     (editfns/insert err))))
               (when (string? buffer)
                 (spit (io/file buffer) out))
               (when (string? stderr)
                 (spit (io/file stderr) err))
               exit))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.bytecode" name="deuce.emacs.bytecode"><h1 class="project-name">deuce.emacs.bytecode</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.bytecode
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Function used internally in byte-compiled code.
  The first argument, BYTESTR, is a string of byte code;
  the second, VECTOR, a vector of constants;
  the third, MAXDEPTH, the maximum stack depth used in this function.
  If the third argument is incorrect, Emacs may crash.</p>
</td><td class="codes"><pre class="brush: clojure">(defun byte-code (bytestr vector maxdepth))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.ccl" name="deuce.emacs.ccl"><h1 class="project-name">deuce.emacs.ccl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.ccl
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Vector of code conversion maps.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar code-conversion-map-vector nil)</pre></td></tr><tr><td class="docs"><p>Alist of fontname patterns vs corresponding CCL program.
  Each element looks like (REGEXP . CCL-CODE),
   where CCL-CODE is a compiled CCL program.
  When a font whose name matches REGEXP is used for displaying a character,
   CCL-CODE is executed to calculate the code point in the font
   from the charset number and position code(s) of the character which are set
   in CCL registers R0, R1, and R2 before the execution.
  The code point in the font is set in CCL registers R1 and R2
   when the execution terminated.
   If the font is single-byte font, the register R2 is not used.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar font-ccl-encoder-alist nil)</pre></td></tr><tr><td class="docs"><p>Vector containing all translation hash tables ever defined.
  Comprises pairs (SYMBOL . TABLE) where SYMBOL and TABLE were set up by calls
  to `define-translation-hash-table'.  The vector is indexed by the table id
  used by CCL.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar translation-hash-table-vector nil)</pre></td></tr><tr><td class="docs"><p>Register CCL program CCL-PROG as NAME in `ccl-program-table'.
  CCL-PROG should be a compiled CCL program (vector), or nil.
  If it is nil, just reserve NAME as a CCL program name.
  Return index number of the registered CCL program.</p>
</td><td class="codes"><pre class="brush: clojure">(defun register-ccl-program (name ccl-prog))</pre></td></tr><tr><td class="docs"><p>Execute CCL-PROGRAM with registers initialized by REGISTERS.</p>

<p>  CCL-PROGRAM is a CCL program name (symbol)
  or compiled code generated by `ccl-compile' (for backward compatibility.
  In the latter case, the execution overhead is bigger than in the former).
  No I/O commands should appear in CCL-PROGRAM.</p>

<p>  REGISTERS is a vector of [R0 R1 ... R7] where RN is an initial value
  for the Nth register.</p>

<p>  As side effect, each element of REGISTERS holds the value of
  the corresponding register after the execution.</p>

<p>  See the documentation of `define-ccl-program' for a definition of CCL
  programs.</p>
</td><td class="codes"><pre class="brush: clojure">(defun ccl-execute (ccl-prog reg))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a CCL program name or a compiled CCL program code.
  See the documentation of `define-ccl-program' for the detail of CCL program.</p>
</td><td class="codes"><pre class="brush: clojure">(defun ccl-program-p (object))</pre></td></tr><tr><td class="docs"><p>Register SYMBOL as code conversion map MAP.
  Return index number of the registered map.</p>
</td><td class="codes"><pre class="brush: clojure">(defun register-code-conversion-map (symbol map))</pre></td></tr><tr><td class="docs"><p>Execute CCL-PROGRAM with initial STATUS on STRING.</p>

<p>  CCL-PROGRAM is a symbol registered by `register-ccl-program',
  or a compiled code generated by `ccl-compile' (for backward compatibility,
  in this case, the execution is slower).</p>

<p>  Read buffer is set to STRING, and write buffer is allocated automatically.</p>

<p>  STATUS is a vector of [R0 R1 ... R7 IC], where
   R0..R7 are initial values of corresponding registers,
   IC is the instruction counter specifying from where to start the program.
  If R0..R7 are nil, they are initialized to 0.
  If IC is nil, it is initialized to head of the CCL program.</p>

<p>  If optional 4th arg CONTINUE is non-nil, keep IC on read operation
  when read buffer is exhausted, else, IC is always set to the end of
  CCL-PROGRAM on exit.</p>

<p>  It returns the contents of write buffer as a string,
   and as side effect, STATUS is updated.
  If the optional 5th arg UNIBYTE-P is non-nil, the returned string
  is a unibyte string.  By default it is a multibyte string.</p>

<p>  See the documentation of `define-ccl-program' for the detail of CCL program.</p>
</td><td class="codes"><pre class="brush: clojure">(defun ccl-execute-on-string (ccl-program status string &amp;optional continue unibyte-p))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.buffer" name="deuce.emacs.buffer"><h1 class="project-name">deuce.emacs.buffer</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.buffer
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [clojure.java.io :as io]
            [flatland.ordered.map :as ordered-map]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.data :as data]
            [deuce.emacs.eval :as eval]
            [deuce.emacs-lisp :as el]
            [deuce.emacs-lisp.cons :as cons]
            [deuce.emacs-lisp.globals :as globals])
  (:import [deuce.emacs.data Buffer BufferText Marker]
           [clojure.lang Var]
           [java.io PushbackReader])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>List of functions to call before each text change.
  Two arguments are passed to each function: the positions of
  the beginning and end of the range of old text to be changed.
  (For an insertion, the beginning and end are at the same place.)
  No information is given about the length of the text after the change.</p>

<p>  Buffer changes made while executing the `before-change-functions'
  don't call any before-change or after-change functions.
  That's because `inhibit-modification-hooks' is temporarily set non-nil.</p>

<p>  If an unhandled error happens in running these functions,
  the variable's value remains nil.  That prevents the error
  from happening repeatedly and making Emacs nonfunctional.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar before-change-functions nil)</pre></td></tr><tr><td class="docs"><p>Default value of `ctl-arrow' for buffers that do not override it.
  This is the same as (default-value 'ctl-arrow).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-ctl-arrow nil)</pre></td></tr><tr><td class="docs"><p>Hook to be run (by `run-hooks', which see) when a buffer is killed.
  The buffer being killed will be current while the hook is running.
  See `kill-buffer'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar kill-buffer-hook nil)</pre></td></tr><tr><td class="docs"><p>Default value of `line-spacing' for buffers that don't override it.
  This is the same as (default-value 'line-spacing).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-line-spacing nil)</pre></td></tr><tr><td class="docs"><p>Non-nil if Transient Mark mode is enabled.
  See the command `transient-mark-mode' for a description of this minor mode.</p>

<p>  Non-nil also enables highlighting of the region whenever the mark is active.
  The variable `highlight-nonselected-windows' controls whether to highlight
  all windows or just the selected window.</p>

<p>  Lisp programs may give this variable certain special values:</p>

<ul>
<li><p>A value of `lambda' enables Transient Mark mode temporarily.
It is disabled again after any subsequent action that would
normally deactivate the mark (e.g. buffer modification).</p></li>
<li><p>A value of (only . OLDVAL) enables Transient Mark mode
temporarily.  After any subsequent point motion command that is
not shift-translated, or any other action that would normally
deactivate the mark (e.g. buffer modification), the value of
`transient-mark-mode' is set to OLDVAL.</p>

<p>You can customize this variable.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defvar transient-mark-mode nil)</pre></td></tr><tr><td class="docs"><p>A number incremented each time this buffer is displayed in a window.
  The function `set-window-buffer' increments it.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-display-count nil)</pre></td></tr><tr><td class="docs"><p>*Position of this buffer's vertical scroll bar.
  The value takes effect whenever you tell a window to display this buffer;
  for instance, with <code>set-window-buffer' or when</code>display-buffer' displays it.</p>

<p>  A value of <code>left' or</code>right' means put the vertical scroll bar at that side
  of the window; a value of nil means don't show any vertical scroll bars.
  A value of t (the default) means do whatever the window's frame specifies.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar vertical-scroll-bar true)</pre></td></tr><tr><td class="docs"><p>Default value of `indicate-empty-lines' for buffers that don't override it.
  This is the same as (default-value 'indicate-empty-lines).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-indicate-empty-lines nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means that Emacs should use caches to handle long lines more quickly.</p>

<p>  Normally, the line-motion functions work by scanning the buffer for
  newlines.  Columnar operations (like `move-to-column' and
  `compute-motion') also work by scanning the buffer, summing character
  widths as they go.  This works well for ordinary text, but if the
  buffer's lines are very long (say, more than 500 characters), these
  motion functions will take longer to execute.  Emacs may also take
  longer to update the display.</p>

<p>  If `cache-long-line-scans' is non-nil, these motion functions cache the
  results of their scans, and consult the cache to avoid rescanning
  regions of the buffer until the text is modified.  The caches are most
  beneficial when they prevent the most searching---that is, when the
  buffer contains long lines and large regions of characters with the
  same, fixed screen width.</p>

<p>  When `cache-long-line-scans' is non-nil, processing short lines will
  become slightly slower (because of the overhead of consulting the
  cache), and the caches will use memory roughly proportional to the
  number of newlines and characters whose screen width varies.</p>

<p>  The caches require no explicit maintenance; their accuracy is
  maintained internally by the Emacs primitives.  Enabling or disabling
  the cache should not affect the behavior of any of the motion
  functions; it should only affect their performance.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar cache-long-line-scans nil)</pre></td></tr><tr><td class="docs"><p>*Default value of `enable-multibyte-characters' for buffers not overriding it.
  This is the same as (default-value 'enable-multibyte-characters).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-enable-multibyte-characters nil)</pre></td></tr><tr><td class="docs"><p>Default value of `fringes-outside-margins' for buffers that don't override it.
  This is the same as (default-value 'fringes-outside-margins).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-fringes-outside-margins nil)</pre></td></tr><tr><td class="docs"><p>Pretty name of current buffer's major mode.
  Usually a string, but can use any of the constructs for `mode-line-format',
  which see.
  Format with `format-mode-line' to produce a string value.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar mode-name &quot;Fundamental&quot;)</pre></td></tr><tr><td class="docs"><p>List of undo entries in current buffer.
  Recent changes come first; older changes follow newer.</p>

<p>  An entry (BEG . END) represents an insertion which begins at
  position BEG and ends at position END.</p>

<p>  An entry (TEXT . POSITION) represents the deletion of the string TEXT
  from (abs POSITION).  If POSITION is positive, point was at the front
  of the text being deleted; if negative, point was at the end.</p>

<p>  An entry (t HIGH . LOW) indicates that the buffer previously had
  "unmodified" status.  HIGH and LOW are the high and low 16-bit portions
  of the visited file's modification time, as of that time.  If the
  modification time of the most recent save is different, this entry is
  obsolete.</p>

<p>  An entry (nil PROPERTY VALUE BEG . END) indicates that a text property
  was modified between BEG and END.  PROPERTY is the property name,
  and VALUE is the old value.</p>

<p>  An entry (apply FUN-NAME . ARGS) means undo the change with
  (apply FUN-NAME ARGS).</p>

<p>  An entry (apply DELTA BEG END FUN-NAME . ARGS) supports selective undo
  in the active region.  BEG and END is the range affected by this entry
  and DELTA is the number of bytes added or deleted in that range by
  this change.</p>

<p>  An entry (MARKER . DISTANCE) indicates that the marker MARKER
  was adjusted in position by the offset DISTANCE (an integer).</p>

<p>  An entry of the form POSITION indicates that point was at the buffer
  location given by the integer.  Undoing an entry of this form places
  point at POSITION.</p>

<p>  Entries with value `nil' mark undo boundaries.  The undo command treats
  the changes between two undo boundaries as a single step to be undone.</p>

<p>  If the value of the variable is t, undo information is not recorded.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-undo-list nil)</pre></td></tr><tr><td class="docs"><p>Abbreviated truename of file visited in current buffer, or nil if none.
  The truename of a file is calculated by `file-truename'
  and then abbreviated with `abbreviate-file-name'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-file-truename nil)</pre></td></tr><tr><td class="docs"><p>*Width of this buffer's right fringe (in pixels).
  A value of 0 means no right fringe is shown in this buffer's window.
  A value of nil means to use the right fringe width from the window's frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar right-fringe-width nil)</pre></td></tr><tr><td class="docs"><p>Default value of `scroll-bar-width' for buffers that don't override it.
  This is the same as (default-value 'scroll-bar-width).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-scroll-bar-width nil)</pre></td></tr><tr><td class="docs"><p>List of functions called with no args to query before killing a buffer.
  The buffer being killed will be current while the functions are running.
  If any of them returns nil, the buffer is not killed.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar kill-buffer-query-functions nil)</pre></td></tr><tr><td class="docs"><p>Non-nil if self-insertion should replace existing text.
  The value should be one of `overwrite-mode-textual',
  `overwrite-mode-binary', or nil.
  If it is `overwrite-mode-textual', self-insertion still
  inserts at the end of a line, and inserts when point is before a tab,
  until the tab is filled in.
  If `overwrite-mode-binary', self-insertion replaces newlines and tabs too.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar overwrite-mode nil)</pre></td></tr><tr><td class="docs"><p>Default value of `right-fringe-width' for buffers that don't override it.
  This is the same as (default-value 'right-fringe-width).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-right-fringe-width nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means to use word-wrapping for continuation lines.
  When word-wrapping is on, continuation lines are wrapped at the space
  or tab character nearest to the right window edge.
  If nil, continuation lines are wrapped at the right screen edge.</p>

<p>  This variable has no effect if long lines are truncated (see
  <code>truncate-lines' and</code>truncate-partial-width-windows').  If you use
  word-wrapping, you might want to reduce the value of
  `truncate-partial-width-windows', since wrapping can make text readable
  in narrower windows.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar word-wrap nil)</pre></td></tr><tr><td class="docs"><p>*Format in which to write auto-save files.
  Should be a list of symbols naming formats that are defined in `format-alist'.
  If it is t, which is the default, auto-save files are written in the
  same format as a regular save would use.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-auto-save-file-format true)</pre></td></tr><tr><td class="docs"><p>*Value of `major-mode' for new buffers.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-major-mode nil)</pre></td></tr><tr><td class="docs"><p>Default value of `left-margin' for buffers that do not override it.
  This is the same as (default-value 'left-margin).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-left-margin nil)</pre></td></tr><tr><td class="docs"><p>Template for displaying mode line for current buffer.
  Each buffer has its own value of this variable.
  Value may be nil, a string, a symbol or a list or cons cell.
  A value of nil means don't display a mode line.
  For a symbol, its value is used (but it is ignored if t or nil).
   A string appearing directly as the value of a symbol is processed verbatim
   in that the %-constructs below are not recognized.
   Note that unless the symbol is marked as a `risky-local-variable', all
   properties in any strings, as well as all :eval and :propertize forms
   in the value of that symbol will be ignored.
  For a list of the form `(:eval FORM)', FORM is evaluated and the result
   is used as a mode line element.  Be careful--FORM should not load any files,
   because that can cause an infinite recursion.
  For a list of the form `(:propertize ELT PROPS...)', ELT is displayed
   with the specified properties PROPS applied.
  For a list whose car is a symbol, the symbol's value is taken,
   and if that is non-nil, the cadr of the list is processed recursively.
   Otherwise, the caddr of the list (if there is one) is processed.
  For a list whose car is a string or list, each element is processed
   recursively and the results are effectively concatenated.
  For a list whose car is an integer, the cdr of the list is processed
    and padded (if the number is positive) or truncated (if negative)
    to the width specified by that number.
  A string is printed verbatim in the mode line except for %-constructs:
    (%-constructs are allowed when the string is the entire mode-line-format
     or when it is found in a cons-cell or a list)
    %b -- print buffer name.      %f -- print visited file name.
    %F -- print frame name.
    %* -- print %, * or hyphen.   %+ -- print *, % or hyphen.
    %&amp; is like %*, but ignore read-only-ness.
    % means buffer is read-only and * means it is modified.
    For a modified read-only buffer, %* gives % and %+ gives *.
    %s -- print process status.   %l -- print the current line number.
    %c -- print the current column number (this makes editing slower).
          To make the column number update correctly in all cases,
    `column-number-mode' must be non-nil.
    %i -- print the size of the buffer.
    %I -- like %i, but use k, M, G, etc., to abbreviate.
    %p -- print percent of buffer above top of window, or Top, Bot or All.
    %P -- print percent of buffer above bottom of window, perhaps plus Top,
          or print Bottom or All.
    %n -- print Narrow if appropriate.
    %t -- visited file is text or binary (if OS supports this distinction).
    %z -- print mnemonics of keyboard, terminal, and buffer coding systems.
    %Z -- like %z, but including the end-of-line format.
    %e -- print error message about full memory.
    %@ -- print @ or hyphen.  @ means that default-directory is on a
          remote machine.
    %[ -- print one [ for each recursive editing level.  %] similar.
    %% -- print %.   %- -- print infinitely many dashes.
  Decimal digits after the % specify field width to which to pad.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar mode-line-format &quot;%-&quot;)</pre></td></tr><tr><td class="docs"><p>Normal hook run before changing the major mode of a buffer.
  The function `kill-all-local-variables' runs this before doing anything else.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar change-major-mode-hook nil)</pre></td></tr><tr><td class="docs"><p>How far to scroll windows downward.
  If you move point off the top, the window scrolls automatically.
  This variable controls how far it scrolls.  The value nil, the default,
  means scroll to center point.  A fraction means scroll to put point
  that fraction of the window's height from the top of the window.
  When the value is 0.0, point goes at the top line, which in the
  simple case that you moved off with C-b means scrolling just one line.
  1.0 means point goes at the bottom, so that in that simple case, the
  window scrolls by a full window height.  Meaningful values are
  between 0.0 and 1.0, inclusive.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar scroll-down-aggressively nil)</pre></td></tr><tr><td class="docs"><p>*Mapping from logical to physical fringe cursor bitmaps.
  The value is an alist where each element (CURSOR . BITMAP)
  specifies the fringe bitmaps used to display a specific logical
  cursor type in the fringe.</p>

<p>  CURSOR specifies the logical cursor type which is one of the following
  symbols: <code>box' ,</code>hollow', <code>bar',</code>hbar', or `hollow-small'.  The last
  one is used to show a hollow cursor on narrow lines display lines
  where the normal hollow cursor will not fit.</p>

<p>  BITMAP is the corresponding fringe bitmap shown for the logical
  cursor type.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar fringe-cursor-alist nil)</pre></td></tr><tr><td class="docs"><p>Function called (if non-nil) to perform auto-fill.
  It is called after self-inserting any character specified in
  the `auto-fill-chars' table.
  NOTE: This variable is not a hook;
  its value may not be a list of functions.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-fill-function nil)</pre></td></tr><tr><td class="docs"><p>Value of point before the last series of scroll operations, or nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar point-before-scroll nil)</pre></td></tr><tr><td class="docs"><p>*Width of right marginal area for display of a buffer.
  A value of nil means no marginal area.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar right-margin-width 0)</pre></td></tr><tr><td class="docs"><p>Default value of `cursor-type' for buffers that don't override it.
  This is the same as (default-value 'cursor-type).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-cursor-type nil)</pre></td></tr><tr><td class="docs"><p>*Width of this buffer's scroll bars in pixels.
  A value of nil means to use the scroll bar width from the window's frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar scroll-bar-width nil)</pre></td></tr><tr><td class="docs"><p>Display table that controls display of the contents of current buffer.</p>

<p>  If this variable is nil, the value of `standard-display-table' is used.
  Each window can have its own, overriding display table, see
  <code>set-window-display-table' and</code>window-display-table'.</p>

<p>  The display table is a char-table created with `make-display-table'.
  A char-table is an array indexed by character codes.  Normal array
  primitives <code>aref' and</code>aset' can be used to access elements of a char-table.</p>

<p>  Each of the char-table elements control how to display the corresponding
  text character: the element at index C in the table says how to display
  the character whose code is C.  Each element should be a vector of
  characters or nil.  The value nil means display the character in the
  default fashion; otherwise, the characters from the vector are delivered
  to the screen instead of the original character.</p>

<p>  For example, (aset buffer-display-table ?X [?Y]) tells Emacs
  to display a capital Y instead of each X character.</p>

<p>  In addition, a char-table has six extra slots to control the display of:</p>

<pre><code>the end of a truncated screen line (extra-slot 0, a single character);
the end of a continued line (extra-slot 1, a single character);
the escape character used to display character codes in octal
  (extra-slot 2, a single character);
the character used as an arrow for control characters (extra-slot 3,
  a single character);
the decoration indicating the presence of invisible lines (extra-slot 4,
  a vector of characters);
the character used to draw the border between side-by-side windows
  (extra-slot 5, a single character).
</code></pre>

<p>  See also the functions <code>display-table-slot' and</code>set-display-table-slot'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-display-table nil)</pre></td></tr><tr><td class="docs"><p>*Visually indicate buffer boundaries and scrolling.
  If non-nil, the first and last line of the buffer are marked in the fringe
  of a window on window-systems with angle bitmaps, or if the window can be
  scrolled, the top and bottom line of the window are marked with up and down
  arrow bitmaps.</p>

<p>  If value is a symbol <code>left' or</code>right', both angle and arrow bitmaps
  are displayed in the left or right fringe, resp.  Any other value
  that doesn't look like an alist means display the angle bitmaps in
  the left fringe but no arrows.</p>

<p>  You can exercise more precise control by using an alist as the
  value.  Each alist element (INDICATOR . POSITION) specifies
  where to show one of the indicators.  INDICATOR is one of `top',
  <code>bottom',</code>up', `down', or t, which specifies the default position,
  and POSITION is one of <code>left',</code>right', or nil, meaning do not show
  this indicator.</p>

<p>  For example, ((top . left) (t . right)) places the top angle bitmap in
  left fringe, the bottom angle bitmap in right fringe, and both arrow
  bitmaps in right fringe.  To show just the angle bitmaps in the left
  fringe, but no arrow bitmaps, use ((top .  left) (bottom . left)).</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar indicate-buffer-boundaries nil)</pre></td></tr><tr><td class="docs"><p>Default value of `left-margin-width' for buffers that don't override it.
  This is the same as (default-value 'left-margin-width).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-left-margin-width nil)</pre></td></tr><tr><td class="docs"><p>Name of default directory of current buffer.  Should end with slash.
  To interactively change the default directory, use command `cd'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-directory (some-&gt; (System/getProperty &quot;user.dir&quot;) (s/replace #&quot;([^/])$&quot; &quot;$1/&quot;)))</pre></td></tr><tr><td class="docs"><p>Non-nil if this buffer is read-only.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-read-only nil)</pre></td></tr><tr><td class="docs"><p>Symbol for current buffer's major mode.
  The default value (normally `fundamental-mode') affects new buffers.
  A value of nil means to use the current buffer's major mode, provided
  it is not marked as "special".</p>

<p>  When a mode is used by default, `find-file' switches to it before it
  reads the contents into the buffer and before it finishes setting up
  the buffer.  Thus, the mode and its hooks should not expect certain
  variables such as <code>buffer-read-only' and</code>buffer-file-coding-system'
  to be set up.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar major-mode 'fundamental-mode)</pre></td></tr><tr><td class="docs"><p>*Column beyond which automatic line-wrapping should happen.
  Interactively, you can set the buffer local value using C-x f.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar fill-column 70)</pre></td></tr><tr><td class="docs"><p>*Distance between tab stops (for display of tab characters), in columns.
  This should be an integer greater than zero.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar tab-width 8)</pre></td></tr><tr><td class="docs"><p>Default value of `cursor-in-non-selected-windows'.
  This is the same as (default-value 'cursor-in-non-selected-windows).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-cursor-in-non-selected-windows nil)</pre></td></tr><tr><td class="docs"><p>Default value of `case-fold-search' for buffers that don't override it.
  This is the same as (default-value 'case-fold-search).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-case-fold-search nil)</pre></td></tr><tr><td class="docs"><p>Length of current buffer when last read in, saved or auto-saved.
  0 initially.
  -1 means auto-saving turned off until next real save.</p>

<p>  If you set this to -2, that means don't turn off auto-saving in this buffer
  if its text size shrinks.   If you use `buffer-swap-text' on a buffer,
  you probably should set this to -2 in that buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-saved-size 0)</pre></td></tr><tr><td class="docs"><p>*Width of this buffer's left fringe (in pixels).
  A value of 0 means no left fringe is shown in this buffer's window.
  A value of nil means to use the left fringe width from the window's frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar left-fringe-width nil)</pre></td></tr><tr><td class="docs"><p>Coding system to be used for encoding the buffer contents on saving.
  This variable applies to saving the buffer, and also to `write-region'
  and other functions that use `write-region'.
  It does not apply to sending output to subprocesses, however.</p>

<p>  If this is nil, the buffer is saved without any code conversion
  unless some coding system is specified in `file-coding-system-alist'
  for the buffer file.</p>

<p>  If the text to be saved cannot be encoded as specified by this variable,
  an alternative encoding is selected by `select-safe-coding-system', which see.</p>

<p>  The variable `coding-system-for-write', if non-nil, overrides this variable.</p>

<p>  This variable is never applied to a way of decoding a file while reading it.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-file-coding-system nil)</pre></td></tr><tr><td class="docs"><p>*Column for the default `indent-line-function' to indent to.
  Linefeed indents to this column in Fundamental mode.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar left-margin 0)</pre></td></tr><tr><td class="docs"><p>Default value of `scroll-up-aggressively'.
  This value applies in buffers that don't have their own local values.
  This is the same as (default-value 'scroll-up-aggressively).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-scroll-up-aggressively nil)</pre></td></tr><tr><td class="docs"><p>Default value of `abbrev-mode' for buffers that do not override it.
  This is the same as (default-value 'abbrev-mode).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-abbrev-mode nil)</pre></td></tr><tr><td class="docs"><p>Non-nil if this buffer's file has been backed up.
  Backing up is done before the first time the file is saved.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-backed-up nil)</pre></td></tr><tr><td class="docs"><p>List of functions to call after each text change.
  Three arguments are passed to each function: the positions of
  the beginning and end of the range of changed text,
  and the length in bytes of the pre-change text replaced by that range.
  (For an insertion, the pre-change length is zero;
  for a deletion, that length is the number of bytes deleted,
  and the post-change beginning and end are at the same place.)</p>

<p>  Buffer changes made while executing the `after-change-functions'
  don't call any before-change or after-change functions.
  That's because `inhibit-modification-hooks' is temporarily set non-nil.</p>

<p>  If an unhandled error happens in running these functions,
  the variable's value remains nil.  That prevents the error
  from happening repeatedly and making Emacs nonfunctional.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar after-change-functions nil)</pre></td></tr><tr><td class="docs"><p>Default value of `fringe-indicator-alist' for buffers that don't override it.
  This is the same as (default-value 'fringe-indicator-alist').</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-fringe-indicator-alist nil)</pre></td></tr><tr><td class="docs"><p>Default value of `header-line-format' for buffers that don't override it.
  This is the same as (default-value 'header-line-format).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-header-line-format nil)</pre></td></tr><tr><td class="docs"><p>List of formats to use when saving this buffer.
  Formats are defined by `format-alist'.  This variable is
  set when a file is visited.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-file-format nil)</pre></td></tr><tr><td class="docs"><p>Analogous to `mode-line-format', but controls the header line.
  The header line appears, optionally, at the top of a window;
  the mode line appears at the bottom.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar header-line-format nil)</pre></td></tr><tr><td class="docs"><p>Name of file for auto-saving current buffer.
  If it is nil, that means don't auto-save this buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-auto-save-file-name nil)</pre></td></tr><tr><td class="docs"><p>Default value of `truncate-lines' for buffers that do not override it.
  This is the same as (default-value 'truncate-lines).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-truncate-lines nil)</pre></td></tr><tr><td class="docs"><p>Default value of `vertical-scroll-bar' for buffers that don't override it.
  This is the same as (default-value 'vertical-scroll-bar).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-vertical-scroll-bar nil)</pre></td></tr><tr><td class="docs"><p>Hook run when the buffer list changes.
  Functions running this hook are `get-buffer-create',
  <code>make-indirect-buffer',</code>rename-buffer', `kill-buffer',
  and `bury-buffer-internal'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-list-update-hook nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means do not display continuation lines.
  Instead, give each line of text just one screen line.</p>

<p>  Note that this is overridden by the variable
  `truncate-partial-width-windows' if that variable is non-nil
  and this buffer is not full-frame width.</p>

<p>  Minibuffers set this variable to nil.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar truncate-lines nil)</pre></td></tr><tr><td class="docs"><p>Time stamp updated each time this buffer is displayed in a window.
  The function `set-window-buffer' updates this variable
  to the value obtained by calling `current-time'.
  If the buffer has never been shown in a window, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-display-time nil)</pre></td></tr><tr><td class="docs"><p>*Visually indicate empty lines after the buffer end.
  If non-nil, a bitmap is displayed in the left fringe of a window on
  window-systems.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar indicate-empty-lines nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means display control chars with uparrow.
  A value of nil means use backslash and octal digits.
  This variable does not apply to characters whose display is specified
  in the current display table (if there is one).</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar ctl-arrow true)</pre></td></tr><tr><td class="docs"><p>*Non-nil if searches and matches should ignore case.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar case-fold-search true)</pre></td></tr><tr><td class="docs"><p>Default value of `indicate-buffer-boundaries' for buffers that don't override it.
  This is the same as (default-value 'indicate-buffer-boundaries).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-indicate-buffer-boundaries nil)</pre></td></tr><tr><td class="docs"><p>Additional space to put between lines when displaying a buffer.
  The space is measured in pixels, and put below lines on graphic displays,
  see `display-graphic-p'.
  If value is a floating point number, it specifies the spacing relative
  to the default frame line height.  A value of nil means add no extra space.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar line-spacing nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means the buffer contents are regarded as multi-byte characters.
  Otherwise they are regarded as unibyte.  This affects the display,
  file I/O and the behavior of various editing commands.</p>

<p>  This variable is buffer-local but you cannot set it directly;
  use the function `set-buffer-multibyte' to change a buffer's representation.
  See also Info node `(elisp)Text Representations'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar enable-multibyte-characters true)</pre></td></tr><tr><td class="docs"><p>*Width of left marginal area for display of a buffer.
  A value of nil means no marginal area.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar left-margin-width 0)</pre></td></tr><tr><td class="docs"><p>A list of functions to call before changing a buffer which is unmodified.
  The functions are run using the `run-hooks' function.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar first-change-hook nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means to display fringes outside display margins.
  A value of nil means to display fringes between margins and buffer text.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar fringes-outside-margins nil)</pre></td></tr><tr><td class="docs"><p>Non-nil if Abbrev mode is enabled.
  Use the command `abbrev-mode' to change this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar abbrev-mode nil)</pre></td></tr><tr><td class="docs"><p>How far to scroll windows upward.
  If you move point off the bottom, the window scrolls automatically.
  This variable controls how far it scrolls.  The value nil, the default,
  means scroll to center point.  A fraction means scroll to put point
  that fraction of the window's height from the bottom of the window.
  When the value is 0.0, point goes at the bottom line, which in the
  simple case that you moved off with C-f means scrolling just one line.
  1.0 means point goes at the top, so that in that simple case, the
  window scrolls by a full window height.  Meaningful values are
  between 0.0 and 1.0, inclusive.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar scroll-up-aggressively nil)</pre></td></tr><tr><td class="docs"><p>Default value of `fill-column' for buffers that do not override it.
  This is the same as (default-value 'fill-column).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-fill-column nil)</pre></td></tr><tr><td class="docs"><p>*Mapping from logical to physical fringe indicator bitmaps.
  The value is an alist where each element (INDICATOR . BITMAPS)
  specifies the fringe bitmaps used to display a specific logical
  fringe indicator.</p>

<p>  INDICATOR specifies the logical indicator type which is one of the
  following symbols: <code>truncation' ,</code>continuation', `overlay-arrow',
  <code>top',</code>bottom', <code>top-bottom',</code>up', <code>down', empty-line', or</code>unknown'.</p>

<p>  BITMAPS is a list of symbols (LEFT RIGHT [LEFT1 RIGHT1]) which specifies
  the actual bitmap shown in the left or right fringe for the logical
  indicator.  LEFT and RIGHT are the bitmaps shown in the left and/or
  right fringe for the specific indicator.  The LEFT1 or RIGHT1 bitmaps
  are used only for the <code>bottom' and</code>top-bottom' indicators when the
  last (only) line has no final newline.  BITMAPS may also be a single
  symbol which is used in both left and right fringes.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar fringe-indicator-alist nil)</pre></td></tr><tr><td class="docs"><p>Default value of `scroll-down-aggressively'.
  This value applies in buffers that don't have their own local values.
  This is the same as (default-value 'scroll-down-aggressively).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-scroll-down-aggressively nil)</pre></td></tr><tr><td class="docs"><p>Default value of `tab-width' for buffers that do not override it.
  This is the same as (default-value 'tab-width).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-tab-width nil)</pre></td></tr><tr><td class="docs"><p>Default value of `left-fringe-width' for buffers that don't override it.
  This is the same as (default-value 'left-fringe-width).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-left-fringe-width nil)</pre></td></tr><tr><td class="docs"><p>Name of file visited in current buffer, or nil if not visiting a file.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-file-name nil)</pre></td></tr><tr><td class="docs"><p>Default value of `buffer-file-coding-system' for buffers not overriding it.
  This is the same as (default-value 'buffer-file-coding-system).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-buffer-file-coding-system nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means show a cursor in non-selected windows.
  If nil, only shows a cursor in the selected window.
  If t, displays a cursor related to the usual cursor type
  (a solid box becomes hollow, a bar becomes a narrower bar).
  You can also specify the cursor type as in the `cursor-type' variable.
  Use Custom to set this variable and update the display."</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar cursor-in-non-selected-windows true)</pre></td></tr><tr><td class="docs"><p>Non-nil enables selective display.
  An integer N as value means display only lines
  that start with less than N columns of space.
  A value of t means that the character ^M makes itself and
  all the rest of the line invisible; also, when saving the buffer
  in a file, save the ^M as a newline.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar selective-display nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means display ... on previous line when a line is invisible.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar selective-display-ellipses true)</pre></td></tr><tr><td class="docs"><p>Cursor to use when this buffer is in the selected window.
  Values are interpreted as follows:</p>

<pre><code>t         use the cursor specified for the frame
nil       don't display a cursor
box       display a filled box cursor
hollow    display a hollow box cursor
bar       display a vertical bar cursor with default width
(bar . WIDTH)     display a vertical bar cursor with width WIDTH
hbar          display a horizontal bar cursor with default height
(hbar . HEIGHT) display a horizontal bar cursor with height HEIGHT
ANYTHING ELSE     display a hollow box cursor
</code></pre>

<p>  When the buffer is displayed in a non-selected window, the
  cursor's appearance is instead controlled by the variable
  `cursor-in-non-selected-windows'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar cursor-type true)</pre></td></tr><tr><td class="docs"><p>Non-nil means the mark and region are currently active in this buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar mark-active nil)</pre></td></tr><tr><td class="docs"><p>Default value of `fringe-cursor-alist' for buffers that don't override it.
  This is the same as (default-value 'fringe-cursor-alist').</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-fringe-cursor-alist nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means disregard read-only status of buffers or characters.
  If the value is t, disregard <code>buffer-read-only' and all</code>read-only'
  text properties.  If the value is a list, disregard `buffer-read-only'
  and disregard a `read-only' text property if the property value
  is a member of the list.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-read-only nil)</pre></td></tr><tr><td class="docs"><p>Invisibility spec of this buffer.
  The default is t, which means that text is invisible
  if it has a non-nil `invisible' property.
  If the value is a list, a text character is invisible if its `invisible'
  property is an element in that list (or is a list with members in common).
  If an element is a cons cell of the form (PROP . ELLIPSIS),
  then characters with property value PROP are invisible,
  and they have an ellipsis as well if ELLIPSIS is non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar buffer-invisibility-spec nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means reorder bidirectional text for display in the visual order.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar bidi-display-reordering true)</pre></td></tr><tr><td class="docs"><p>Default value of `right-margin-width' for buffers that don't override it.
  This is the same as (default-value 'right-margin-width).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-right-margin-width nil)</pre></td></tr><tr><td class="docs"><p>Local (mode-specific) abbrev table of current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar local-abbrev-table nil)</pre></td></tr><tr><td class="docs"><p>Default value of `mode-line-format' for buffers that don't override it.
  This is the same as (default-value 'mode-line-format).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-mode-line-format nil)</pre></td></tr><tr><td class="docs"><p>*If non-nil, forces directionality of text paragraphs in the buffer.</p>

<p>  If this is nil (the default), the direction of each paragraph is
  determined by the first strong directional character of its text.
  The values of <code>right-to-left' and</code>left-to-right' override that.
  Any other value is treated as nil.</p>

<p>  This variable has no effect unless the buffer's value of
  `bidi-display-reordering' is non-nil.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar bidi-paragraph-direction nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private not-buffer-locals
  '#{kill-buffer-hook before-change-functions after-change-functions
     first-change-hook transient-mark-mode inhibit-read-only
     kill-buffer-query-functions change-major-mode-hook buffer-list-update-hook})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private read-buffer-locals []
  (with-open [r (PushbackReader. (io/reader (io/resource (str (s/replace (ns-name *ns*) &quot;.&quot; &quot;/&quot;) &quot;.clj&quot;))))]
    (group-by #(keyword (or (re-find #&quot;default&quot; (name %)) &quot;local&quot;))
              (remove not-buffer-locals
                      (map second
                           (filter (every-pred seq? (comp '#{defvar} first))
                                   (take-while (complement nil?)
                                               (repeatedly #(read r false nil)))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private init-buffer-locals []
  (let [{:keys [default local]} (read-buffer-locals)]
    (reset! el/buffer-locals (set local))
    (doseq [d default
            :when (not= 'default-directory d)]
      (let [l (el/global (@el/buffer-locals (symbol (s/replace (name d) &quot;default-&quot; ))))]
        (.refer (the-ns 'deuce.emacs-lisp.globals) d l)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(init-buffer-locals)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private buffer-alist (atom (ordered-map/ordered-map)))
(def ^:dynamic ^:private *current-buffer* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare current-buffer set-buffer other-buffer buffer-name
         get-buffer buffer-local-value set-buffer-modified-p)</pre></td></tr><tr><td class="docs"><p>Signal a `buffer-read-only' error if the current buffer is read-only.</p>
</td><td class="codes"><pre class="brush: clojure">(defun barf-if-buffer-read-only ()
  (when (buffer-local-value 'buffer-read-only (current-buffer))
    (el/throw* 'buffer-read-only (buffer-name))))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is an overlay.</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlayp (object))</pre></td></tr><tr><td class="docs"><p>Create a new overlay with range BEG to END in BUFFER.
  If omitted, BUFFER defaults to the current buffer.
  BEG and END may be integers or markers.
  The fourth arg FRONT-ADVANCE, if non-nil, makes the marker
  for the front of the overlay advance when text is inserted there
  (which means the text <em>is not</em> included in the overlay).
  The fifth arg REAR-ADVANCE, if non-nil, makes the marker
  for the rear of the overlay advance when text is inserted there
  (which means the text <em>is</em> included in the overlay).</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-overlay (beg end &amp;optional buffer front-advance rear-advance)
  beg)</pre></td></tr><tr><td class="docs"><p>Return non-nil if OBJECT is a buffer which has not been killed.
  Value is nil if OBJECT is not a buffer or if it has been killed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-live-p (object)
  (contains? (set (vals @buffer-alist)) object))</pre></td></tr><tr><td class="docs"><p>Like `set-buffer-modified-p', with a difference concerning redisplay.
  It is not ensured that mode lines will be updated to show the modified
  state of the current buffer.  Use with care.</p>
</td><td class="codes"><pre class="brush: clojure">(defun restore-buffer-modified-p (flag)
  (set-buffer-modified-p flag))</pre></td></tr><tr><td class="docs"><p>Return t if BUFFER was modified since its file was last read or saved.
  No argument or nil as argument means use current buffer as BUFFER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-modified-p (&amp;optional buffer)
  (let [buffer ^Buffer (el/check-type 'bufferp (or buffer (current-buffer)))
        text ^BufferText (.text buffer)
        modiff @(.modiff text)]
    (and modiff (&gt; modiff @(.save-modiff text)))))</pre></td></tr><tr><td class="docs"><p>Return BUFFER's character-change tick counter.
  Each buffer has a character-change tick counter, which is set to the
  value of the buffer's tick counter (see `buffer-modified-tick'), each
  time text in that buffer is inserted or deleted.  By comparing the
  values returned by two individual calls of `buffer-chars-modified-tick',
  you can tell whether a character change occurred in that buffer in
  between these calls.  No argument or nil as argument means use current
  buffer as BUFFER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-chars-modified-tick (&amp;optional buffer))</pre></td></tr><tr><td class="docs"><p>Return a string that is the name of no existing buffer based on NAME.
  If there is no live buffer named NAME, then return NAME.
  Otherwise modify name by appending `&lt;NUMBER>', incrementing NUMBER
  (starting at 2) until an unused name is found, and then return that name.
  Optional second argument IGNORE specifies a name that is okay to use (if
  it is in the sequence to be tried) even if a buffer with that name exists.</p>
</td><td class="codes"><pre class="brush: clojure">(defun generate-new-buffer-name (name &amp;optional ignore)
  (if-not (contains? @buffer-alist name)
    name
    (loop [idx 2]
      (let [name (str name  &quot;&lt;&quot; idx &quot;&gt;&quot;)]
        (if (and (contains? @buffer-alist name) (not= ignore name))
          (recur (inc idx))
          name)))))</pre></td></tr><tr><td class="docs"><p>Set the multibyte flag of the current buffer to FLAG.
  If FLAG is t, this makes the buffer a multibyte buffer.
  If FLAG is nil, this makes the buffer a single-byte buffer.
  In these cases, the buffer contents remain unchanged as a sequence of
  bytes but the contents viewed as characters do change.
  If FLAG is `to', this makes the buffer a multibyte buffer by changing
  all eight-bit bytes to eight-bit characters.
  If the multibyte flag was really changed, undo information of the
  current buffer is cleared.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-buffer-multibyte (flag))</pre></td></tr><tr><td class="docs"><p>Recenter the overlays of the current buffer around position POS.
  That makes overlay lookup faster for positions near POS (but perhaps slower
  for positions far away from POS).</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlay-recenter (pos))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private allocate-marker [insertion-type buffer charpos]
  (Marker. (atom  insertion-type) (atom buffer) (atom charpos)))</pre></td></tr><tr><td class="docs"><p>The eternal battle of how to represent mutable data like pt and name, nested atoms or updates via root buffer-alist?
The latter doesn't work properly, save-current-buffer for example allows destructive updates to the current buffer it restores.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private allocate-buffer [name]
  (let [now (System/currentTimeMillis)
        text (BufferText. (StringBuilder.) (atom nil) (atom now) (atom nil))
        own-text text
        pt (atom 1)
        begv (atom nil)
        zv (atom nil)
        mark (atom (alloc/make-marker))
        buffer-locals (atom {})
        buffer (Buffer. own-text text pt begv zv (atom name) mark buffer-locals)]
    buffer))</pre></td></tr><tr><td class="docs"><p>Return the buffer specified by BUFFER-OR-NAME, creating a new one if needed.
  If BUFFER-OR-NAME is a string and a live buffer with that name exists,
  return that buffer.  If no such buffer exists, create a new buffer with
  that name and return it.  If BUFFER-OR-NAME starts with a space, the new
  buffer does not keep undo information.</p>

<p>  If BUFFER-OR-NAME is a buffer instead of a string, return it as given,
  even if it is dead.  The return value is never nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-buffer-create (buffer-or-name)
  (if (data/bufferp buffer-or-name)
    buffer-or-name
    (or (get-buffer buffer-or-name)
        (let [buffer (allocate-buffer buffer-or-name)]
          (swap! buffer-alist assoc buffer-or-name buffer)
          buffer))))</pre></td></tr><tr><td class="docs"><p>Return the position at which OVERLAY starts.</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlay-start (overlay))</pre></td></tr><tr><td class="docs"><p>Return the buffer named BUFFER-OR-NAME.
  BUFFER-OR-NAME must be either a string or a buffer.  If BUFFER-OR-NAME
  is a string and there is no buffer with that name, return nil.  If
  BUFFER-OR-NAME is a buffer, return it as given.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-buffer (buffer-or-name)
  (if (data/bufferp buffer-or-name)
    buffer-or-name
    (and (el/check-type 'stringp buffer-or-name)
         (@buffer-alist buffer-or-name))))</pre></td></tr><tr><td class="docs"><p>Create and return an indirect buffer for buffer BASE-BUFFER, named NAME.
  BASE-BUFFER should be a live buffer, or the name of an existing buffer.
  NAME should be a string which is not the name of an existing buffer.
  Optional argument CLONE non-nil means preserve BASE-BUFFER's state,
  such as major and minor modes, in the indirect buffer.
  CLONE nil means the indirect buffer's state is reset to default values.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-indirect-buffer (base-buffer name &amp;optional clone))</pre></td></tr><tr><td class="docs"><p>Return the current buffer as a Lisp object.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-buffer ()
  *current-buffer*)</pre></td></tr><tr><td class="docs"><p>Delete the overlay OVERLAY from its buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-overlay (overlay))</pre></td></tr><tr><td class="docs"><p>Return the base buffer of indirect buffer BUFFER.
  If BUFFER is not indirect, return nil.
  BUFFER defaults to the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-base-buffer (&amp;optional buffer))</pre></td></tr><tr><td class="docs"><p>Change current buffer's name to NEWNAME (a string).
  If second arg UNIQUE is nil or omitted, it is an error if a
  buffer named NEWNAME already exists.
  If UNIQUE is non-nil, come up with a new name using
  `generate-new-buffer-name'.
  Interactively, you can set UNIQUE with a prefix argument.
  We return the name we actually gave the buffer.
  This does not change the name of the visited file (if any).</p>
</td><td class="codes"><pre class="brush: clojure">(defun rename-buffer (newname &amp;optional unique)
  (interactive &quot;(list (read-string \&quot;Rename buffer (to new name): \&quot;  nil 'buffer-name-history (buffer-name (current-buffer))) current-prefix-arg)&quot;)
  (let [buffer-exists? (contains? @buffer-alist newname)]
    (if (= newname (buffer-name))
      newname
      (if (and unique buffer-exists?)
        (el/throw* 'error (format &quot;Buffer name `%s' is in use&quot; newname))
        (let [newname (if buffer-exists? (generate-new-buffer-name newname) newname)]
          (swap! buffer-alist dissoc (buffer-name))
          (swap! buffer-alist assoc newname (current-buffer))
          (reset! (.name ^Buffer (current-buffer)) newname))))))</pre></td></tr><tr><td class="docs"><p>Return the buffer OVERLAY belongs to.
  Return nil if OVERLAY has been deleted.</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlay-buffer (overlay))</pre></td></tr><tr><td class="docs"><p>Delete the entire contents of the current buffer.
  Any narrowing restriction in effect (see `narrow-to-region') is removed,
  so the buffer is truly empty after this.</p>
</td><td class="codes"><pre class="brush: clojure">(defun erase-buffer ()
  (interactive &quot;*&quot;)
  (let [text ^BufferText (.text ^Buffer (current-buffer))]
    ((el/fun 'widen))
    ((el/fun 'delete-region) 1 (inc (.length ^StringBuilder (.beg text))))
    nil))</pre></td></tr><tr><td class="docs"><p>Switch to Fundamental mode by killing current buffer's local variables.
  Most local variable bindings are eliminated so that the default values
  become effective once more.  Also, the syntax table is set from
  `standard-syntax-table', the local keymap is set to nil,
  and the abbrev table from `fundamental-mode-abbrev-table'.
  This function also forces redisplay of the mode line.</p>

<p>  Every function to select a new major mode starts by
  calling this function.</p>

<p>  As a special exception, local variables whose names have
  a non-nil `permanent-local' property are not eliminated by this function.</p>

<p>  The first thing this function does is run
  the normal hook `change-major-mode-hook'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun kill-all-local-variables ()
  ;; (eval/run-hooks 'change-major-mode-hook)
  ;; (swap! (.local-var-alist ^Buffer (current-buffer)) empty))</pre></td></tr><tr><td class="docs"><p>Return the position at which OVERLAY ends.</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlay-end (overlay))</pre></td></tr><tr><td class="docs"><p>Return the name of BUFFER, as a string.
  BUFFER defaults to the current buffer.
  Return nil if BUFFER has been killed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-name (&amp;optional buffer)
  @(.name ^Buffer (el/check-type 'bufferp (or buffer (current-buffer)))))</pre></td></tr><tr><td class="docs"><p>Set one property of overlay OVERLAY: give property PROP value VALUE.
  VALUE will be returned.</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlay-put (overlay prop value))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private get-exisiting-buffer [buffer-or-name]
  (or (get-buffer buffer-or-name)
      (el/throw* 'error (format  &quot;No buffer named %s&quot; buffer-or-name))))</pre></td></tr><tr><td class="docs"><p>Make buffer BUFFER-OR-NAME current for editing operations.
  BUFFER-OR-NAME may be a buffer or the name of an existing buffer.  See
  also `save-excursion' when you want to make a buffer current
  temporarily.  This function does not display the buffer, so its effect
  ends when the current command terminates.  Use `switch-to-buffer' or
  `pop-to-buffer' to switch buffers permanently.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-buffer (buffer-or-name)
  ;; This is not correct, should only change the binding, but will do for now.
  (let [buffer (when buffer-or-name
                 (get-exisiting-buffer buffer-or-name))]
    (when buffer
      (swap! buffer-alist dissoc @(.name ^Buffer buffer))
      (swap! buffer-alist assoc @(.name ^Buffer buffer) buffer))
    (alter-var-root #'*current-buffer* (constantly buffer))))</pre></td></tr><tr><td class="docs"><p>Start keeping undo information for buffer BUFFER.
  No argument or nil as argument means do this for the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-enable-undo (&amp;optional buffer)
  (interactive))</pre></td></tr><tr><td class="docs"><p>Return a list of all existing live buffers.
  If the optional arg FRAME is a frame, we return the buffer list in the
  proper order for that frame: the buffers show in FRAME come first,
  followed by the rest of the buffers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-list (&amp;optional frame)
  (cons/maybe-seq (vals @buffer-alist)))</pre></td></tr><tr><td class="docs"><p>Move BUFFER to the end of the buffer list.</p>
</td><td class="codes"><pre class="brush: clojure">(defun bury-buffer-internal (buffer))</pre></td></tr><tr><td class="docs"><p>Return the previous position before POS where an overlay starts or ends.
  If there are no overlay boundaries from (point-min) to POS,
  the value is (point-min).</p>
</td><td class="codes"><pre class="brush: clojure">(defun previous-overlay-change (pos))</pre></td></tr><tr><td class="docs"><p>Return an alist of variables that are buffer-local in BUFFER.
  Most elements look like (SYMBOL . VALUE), describing one variable.
  For a symbol that is locally unbound, just the symbol appears in the value.
  Note that storing new VALUEs in these elements doesn't change the variables.
  No argument or nil as argument means use current buffer as BUFFER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-local-variables (&amp;optional buffer)
  (let [buffer ^Buffer (el/check-type 'bufferp (or buffer (current-buffer)))]
    (cons/maybe-seq (map #(alloc/cons (key %) (when-let [v (val %)] @v))
                         (merge (zipmap @el/buffer-locals (repeat nil))
                                @(.local-var-alist buffer))))))</pre></td></tr><tr><td class="docs"><p>Kill buffer BUFFER-OR-NAME.
  The argument may be a buffer or the name of an existing buffer.
  Argument nil or omitted means kill the current buffer.  Return t if the
  buffer is actually killed, nil otherwise.</p>

<p>  This function calls `replace-buffer-in-windows' for cleaning up all
  windows currently displaying the buffer to be killed.  The functions in
  `kill-buffer-query-functions' are called with the buffer to be killed as
  the current buffer.  If any of them returns nil, the buffer is not
  killed.  The hook `kill-buffer-hook' is run before the buffer is
  actually killed.  The buffer being killed will be current while the hook
  is running.</p>

<p>  Any processes that have this buffer as the `process-buffer' are killed
  with SIGHUP.</p>
</td><td class="codes"><pre class="brush: clojure">(defun kill-buffer (&amp;optional buffer-or-name)
  (interactive &quot;bKill buffer: &quot;)
  (let [buffer (if buffer-or-name
                 (get-exisiting-buffer buffer-or-name)
                 (current-buffer))]
    (if (or (not buffer)
            (and globals/kill-buffer-query-functions
                 (binding [*current-buffer* buffer]
                   (some nil? (map eval/funcall globals/kill-buffer-query-functions)))))
      false
      (do
        (binding [*current-buffer* buffer]
          (eval/run-hooks 'kill-buffer-hook))
        (swap! buffer-alist dissoc @(.name ^Buffer buffer))
        (set-buffer (other-buffer))
        true))))</pre></td></tr><tr><td class="docs"><p>Return a list of the overlays that overlap the region BEG ... END.
  Overlap means that at least one character is contained within the overlay
  and also contained within the specified region.
  Empty overlays are included in the result if they are located at BEG,
  between BEG and END, or at END provided END denotes the position at the
  end of the buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlays-in (beg end))</pre></td></tr><tr><td class="docs"><p>Return the next position after POS where an overlay starts or ends.
  If there are no overlay boundaries from POS to (point-max),
  the value is (point-max).</p>
</td><td class="codes"><pre class="brush: clojure">(defun next-overlay-change (pos))</pre></td></tr><tr><td class="docs"><p>Swap the text between current buffer and BUFFER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-swap-text (buffer))</pre></td></tr><tr><td class="docs"><p>Get the property of overlay OVERLAY with property name PROP.</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlay-get (overlay prop))</pre></td></tr><tr><td class="docs"><p>Return a pair of lists giving all the overlays of the current buffer.
  The car has all the overlays before the overlay center;
  the cdr has all the overlays after the overlay center.
  Recentering overlays moves overlays between these lists.
  The lists you get are copies, so that changing them has no effect.
  However, the overlays you get are the real objects that the buffer uses.</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlay-lists ())</pre></td></tr><tr><td class="docs"><p>Mark current buffer as modified or unmodified according to FLAG.
  A non-nil FLAG means mark the buffer modified.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-buffer-modified-p (flag)
  (reset! (.modiff ^BufferText (.text ^Buffer (current-buffer))) (when flag (System/currentTimeMillis))))</pre></td></tr><tr><td class="docs"><p>Set the endpoints of OVERLAY to BEG and END in BUFFER.
  If BUFFER is omitted, leave OVERLAY in the same buffer it inhabits now.
  If BUFFER is omitted, and OVERLAY is in no buffer, put it in the current
  buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun move-overlay (overlay beg end &amp;optional buffer))</pre></td></tr><tr><td class="docs"><p>Return BUFFER's tick counter, incremented for each change in text.
  Each buffer has a tick counter which is incremented each time the
  text in that buffer is changed.  It wraps around occasionally.
  No argument or nil as argument means use current buffer as BUFFER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-modified-tick (&amp;optional buffer))</pre></td></tr><tr><td class="docs"><p>Return name of file BUFFER is visiting, or nil if none.
  No argument or nil as argument means use the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-file-name (&amp;optional buffer)
  (buffer-local-value 'buffer-file-name (or buffer (current-buffer))))</pre></td></tr><tr><td class="docs"><p>Return the value of VARIABLE in BUFFER.
  If VARIABLE does not have a buffer-local binding in BUFFER, the value
  is the default binding of the variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-local-value (variable buffer)
  (binding [*current-buffer* buffer]
    (data/symbol-value variable)))</pre></td></tr><tr><td class="docs"><p>Return the buffer visiting file FILENAME (a string).
  The buffer's `buffer-file-name' must match exactly the expansion of FILENAME.
  If there is no such live buffer, return nil.
  See also `find-buffer-visiting'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-file-buffer (filename)
  (first (filter (comp #{((el/fun 'expand-file-name) filename)} buffer-file-name) (vals @buffer-alist))))</pre></td></tr><tr><td class="docs"><p>Return a list of the properties on OVERLAY.
  This is a copy of OVERLAY's plist; modifying its conses has no effect on
  OVERLAY.</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlay-properties (overlay))</pre></td></tr><tr><td class="docs"><p>Return most recently selected buffer other than BUFFER.
  Buffers not visible in windows are preferred to visible buffers, unless
  optional second argument VISIBLE-OK is non-nil.  Ignore the argument
  BUFFER unless it denotes a live buffer.  If the optional third argument
  FRAME is non-nil, use that frame's buffer list instead of the selected
  frame's buffer list.</p>

<p>  The buffer is found by scanning the selected or specified frame's buffer
  list first, followed by the list of all buffers.  If no other buffer
  exists, return the buffer `<em>scratch</em>' (creating it if necessary).</p>
</td><td class="codes"><pre class="brush: clojure">(defun other-buffer (&amp;optional buffer visible-ok frame)
  (or (last (remove #{(el/check-type 'bufferp (or buffer (current-buffer)))}
                    (vals @buffer-alist)))
      (get-buffer-create &quot;*scratch*&quot;)))</pre></td></tr><tr><td class="docs"><p>Return a list of the overlays that contain the character at POS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun overlays-at (pos))</pre></td></tr><tr><td class="docs"><p>Set an appropriate major mode for BUFFER.
  For the <em>scratch</em> buffer, use `initial-major-mode', otherwise choose a mode
  according to `default-major-mode'.
  Use this function before selecting the buffer, since it may need to inspect
  the current buffer's major mode.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-buffer-major-mode (buffer)
  (when-let [mode (if (= &quot;*scratch*&quot; (buffer-name buffer))
                    (data/symbol-value 'initial-major-mode)
                    (or (data/default-value 'major-mode)
                        (data/symbol-value 'major-mode)))]
    (binding [*current-buffer* buffer]
      (eval/funcall mode))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.chartab" name="deuce.emacs.chartab"><h1 class="project-name">deuce.emacs.chartab</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.chartab
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.data :as data]
            [deuce.emacs.fns :as fns])
  (:import [deuce.emacs.data CharTable]
           [java.util Arrays])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Alist of character property name vs char-table containing property values.
  Internal use only.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar char-code-property-alist nil)</pre></td></tr><tr><td class="docs"><p>Return the parent char-table of CHAR-TABLE.
  The value is either nil or another char-table.
  If CHAR-TABLE holds nil for a given character,
  then the actual applicable value is inherited from the parent char-table
  (or from its parents, if necessary).</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-table-parent (char-table)
  @(.parent ^CharTable char-table))</pre></td></tr><tr><td class="docs"><p>Set the parent char-table of CHAR-TABLE to PARENT.
  Return PARENT.  PARENT must be either nil or another char-table.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-char-table-parent (char-table parent)
  (reset! (.parent ^CharTable char-table) parent))</pre></td></tr><tr><td class="docs"><p>Call FUNCTION for each character in CHAR-TABLE that has non-nil value.
  FUNCTION is called with two arguments--a key and a value.
  The key is a character code or a cons of character codes specifying a
  range of characters that have the same value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun map-char-table (function char-table))</pre></td></tr><tr><td class="docs"><p>Return the value of CHAR-TABLE's extra-slot number N.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-table-extra-slot (char-table n)
  (aget ^objects (.extras ^CharTable char-table) n))</pre></td></tr><tr><td class="docs"><p>Return the subtype of char-table CHAR-TABLE.  The value is a symbol.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-table-subtype (char-table)
  (.purpose ^CharTable char-table))</pre></td></tr><tr><td class="docs"><p>Set the value in CHAR-TABLE for a range of characters RANGE to VALUE.
  RANGE should be t (for all characters), nil (for the default value),
  a cons of character codes (for characters in the range),
  or a character code.  Return VALUE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-char-table-range (char-table range value)
  (let [[start end] (if (data/consp range)
                      [(int (data/car range)) (int (data/cdr range))]
                      [0 (count (.contents ^CharTable  char-table))])]
    (Arrays/fill ^objects (.contents ^CharTable char-table) (int start) (int end)
                 (if (nil? range) (.defalt ^CharTable char-table) value)))
  value)</pre></td></tr><tr><td class="docs"><p>Return an element of CHAR-TABLE for character CH.
  CHAR-TABLE must be what returned by `unicode-property-table-internal'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-unicode-property-internal (char-table ch))</pre></td></tr><tr><td class="docs"><p>Set CHAR-TABLE's extra-slot number N to VALUE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-char-table-extra-slot (char-table n value)
  (aset ^objects (.extras ^CharTable char-table) n value))</pre></td></tr><tr><td class="docs"><p>Return a char-table for Unicode character property PROP.
  Use `get-unicode-property-internal' and
  <code>put-unicode-property-internal' instead of</code>aref' and `aset' to get
  and put an element value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun unicode-property-table-internal (prop))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private char-table-size 4194303)</pre></td></tr><tr><td class="docs"><p>Return a newly created char-table, with purpose PURPOSE.
  Each element is initialized to INIT, which defaults to nil.</p>

<p>  PURPOSE should be a symbol.  If it has a `char-table-extra-slots'
  property, the property's value should be an integer between 0 and 10
  that specifies how many extra slots the char-table has.  Otherwise,
  the char-table has no extra slot.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-char-table (purpose &amp;optional init)
  (CharTable. init (atom nil) purpose
              (alloc/make-vector char-table-size init)
              (when-let [extras (fns/get purpose 'char-table-extra-slots)]
                (alloc/make-vector extras init))))</pre></td></tr><tr><td class="docs"><p>This function is obsolete since 23.1;
  generic characters no longer exist.</p>

<p>  This function is obsolete and has no effect.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-char-table-default (char-table ch value)
  nil)</pre></td></tr><tr><td class="docs"><p>Return the value in CHAR-TABLE for a range of characters RANGE.
  RANGE should be nil (for the default value),
  a cons of character codes (for characters in the range), or a character code.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-table-range (char-table range))</pre></td></tr><tr><td class="docs"><p>Optimize CHAR-TABLE.
  TEST is the comparison function used to decide whether two entries are
  equivalent and can be merged.  It defaults to `equal'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun optimize-char-table (char-table &amp;optional test)
  nil)</pre></td></tr><tr><td class="docs"><p>Set an element of CHAR-TABLE for character CH to VALUE.
  CHAR-TABLE must be what returned by `unicode-property-table-internal'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun put-unicode-property-internal (char-table ch value))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.filelock" name="deuce.emacs.filelock"><h1 class="project-name">deuce.emacs.filelock</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.filelock
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs.fileio :as fileio])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>The directory for writing temporary files.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar temporary-file-directory (fileio/file-name-as-directory (System/getProperty &quot;java.io.tmpdir&quot;)))</pre></td></tr><tr><td class="docs"><p>Lock FILE, if current buffer is modified.
  FILE defaults to current buffer's visited file,
  or else nothing is done if current buffer isn't visiting a file.</p>
</td><td class="codes"><pre class="brush: clojure">(defun lock-buffer (&amp;optional file))</pre></td></tr><tr><td class="docs"><p>Unlock the file visited in the current buffer.
  If the buffer is not modified, this does nothing because the file
  should not be locked in that case.</p>
</td><td class="codes"><pre class="brush: clojure">(defun unlock-buffer ())</pre></td></tr><tr><td class="docs"><p>Return a value indicating whether FILENAME is locked.
  The value is nil if the FILENAME is not locked,
  t if it is locked by you, else a string saying which user has locked it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-locked-p (filename))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.casetab" name="deuce.emacs.casetab"><h1 class="project-name">deuce.emacs.casetab</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.casetab
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs.chartab :as chartab]
            [deuce.emacs.data :as data]
            [deuce.emacs.fns :as fns])
  (:import [deuce.emacs.data CharTable])
  (:refer-clojure &quot;exclude&quot; []))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fns/put 'case-table 'char-table-extra-slots 3)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ascii-downcase-table (atom (chartab/make-char-table 'case-table)))</pre></td></tr><tr><td class="docs"><p>Select a new standard case table for new buffers.
  See `set-case-table' for more info on case tables.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-standard-case-table (table)
  (reset! ascii-downcase-table table))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a case table.
  See `set-case-table' for more information on these data structures.</p>
</td><td class="codes"><pre class="brush: clojure">(defun case-table-p (object)
  (and (data/char-table-p object) (= 'case-table (.purpose ^CharTable object))))</pre></td></tr><tr><td class="docs"><p>Return the case table of the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-case-table ())</pre></td></tr><tr><td class="docs"><p>Select a new case table for the current buffer.
  A case table is a char-table which maps characters
  to their lower-case equivalents.  It also has three "extra" slots
  which may be additional char-tables or nil.
  These slots are called UPCASE, CANONICALIZE and EQUIVALENCES.
  UPCASE maps each non-upper-case character to its upper-case equivalent.
   (The value in UPCASE for an upper-case character is never used.)
   If lower and upper case characters are in 1-1 correspondence,
   you may use nil and the upcase table will be deduced from DOWNCASE.
  CANONICALIZE maps each character to a canonical equivalent;
   any two characters that are related by case-conversion have the same
   canonical equivalent character; it may be nil, in which case it is
   deduced from DOWNCASE and UPCASE.
  EQUIVALENCES is a map that cyclically permutes each equivalence class
   (of characters with the same canonical equivalent); it may be nil,
   in which case it is deduced from CANONICALIZE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-case-table (table))</pre></td></tr><tr><td class="docs"><p>Return the standard case table.
  This is the one used for new buffers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun standard-case-table ()
  @ascii-downcase-table)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.coding" name="deuce.emacs.coding"><h1 class="project-name">deuce.emacs.coding</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.coding
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.charset :as charset]
            [deuce.emacs.fns :as fns]
            [deuce.emacs-lisp.globals :as globals])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>If non-nil, Emacs ignores null bytes on code detection.
  By default, Emacs treats it as binary data, and does not attempt to
  decode it.  The effect is as if you specified `no-conversion' for
  reading that text.</p>

<p>  Set this to non-nil when a regular text happens to include null bytes.
  Examples are Index nodes of Info files and null-byte delimited output
  from GNU Find and GNU Grep.  Emacs will then ignore the null bytes and
  decode text as usual.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-null-byte-detection nil)</pre></td></tr><tr><td class="docs"><p>*String displayed in mode line when end-of-line format is not yet determined.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar eol-mnemonic-undecided &quot;:&quot;)</pre></td></tr><tr><td class="docs"><p>Table of extra Latin codes in the range 128..159 (inclusive).
  This is a vector of length 256.
  If Nth element is non-nil, the existence of code N in a file
  (or output of subprocess) doesn't prevent it to be detected as
  a coding system of ISO 2022 variant which has a flag
  `accept-latin-extra-code' t (e.g. iso-latin-1) on reading a file
  or reading output of a subprocess.
  Only 128th through 159th elements have a meaning.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar latin-extra-code-table nil)</pre></td></tr><tr><td class="docs"><p>Coding system used in the latest file or process I/O.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar last-coding-system-used nil)</pre></td></tr><tr><td class="docs"><p>Alist of charsets vs revision numbers.
  While encoding, if a charset (car part of an element) is found,
  designate it with the escape sequence identifying revision (cdr part
  of the element).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar charset-revision-table nil)</pre></td></tr><tr><td class="docs"><p>Table for translating characters while decoding.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar standard-translation-table-for-decode nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, Emacs ignores ISO-2022 escape sequences during code detection.</p>

<p>  When Emacs reads text, it tries to detect how the text is encoded.
  This code detection is sensitive to escape sequences.  If Emacs sees
  a valid ISO-2022 escape sequence, it assumes the text is encoded in one
  of the ISO2022 encodings, and decodes text by the corresponding coding
  system (e.g. `iso-2022-7bit').</p>

<p>  However, there may be a case that you want to read escape sequences in
  a file as is.  In such a case, you can set this variable to non-nil.
  Then the code detection will ignore any escape sequences, and no text is
  detected as encoded in some ISO-2022 encoding.  The result is that all
  escape sequences become visible in a buffer.</p>

<p>  The default value is nil, and it is strongly recommended not to change
  it.  That is because many Emacs Lisp source files that contain
  non-ASCII characters are encoded by the coding system `iso-2022-7bit'
  in Emacs's distribution, and they won't be decoded correctly on
  reading if you suppress escape sequence detection.</p>

<p>  The other way to read escape sequences in a file without decoding is
  to explicitly specify some coding system that doesn't use ISO-2022
  escape sequence (e.g `latin-1') on reading by C-x RET c.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-iso-escape-detection nil)</pre></td></tr><tr><td class="docs"><p>List of coding systems.</p>

<p>  Do not alter the value of this variable manually.  This variable should be
  updated by the functions `define-coding-system' and
  `define-coding-system-alias'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar coding-system-list nil)</pre></td></tr><tr><td class="docs"><p>Table for translating characters while encoding.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar standard-translation-table-for-encode nil)</pre></td></tr><tr><td class="docs"><p>Specify the coding system for write operations.
  Programs bind this variable with `let', but you should not set it globally.
  If the value is a coding system, it is used for encoding of output,
  when writing it to a file and when sending it to a file or subprocess.</p>

<p>  If this does not specify a coding system, an appropriate element
  is used from one of the coding system alists.
  There are three such tables: `file-coding-system-alist',
  <code>process-coding-system-alist', and</code>network-coding-system-alist'.
  For output to files, if the above procedure does not specify a coding system,
  the value of `buffer-file-coding-system' is used.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar coding-system-for-write nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil enables character translation while encoding and decoding.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar enable-character-translation nil)</pre></td></tr><tr><td class="docs"><p>*String displayed in mode line for UNIX-like (LF) end-of-line format.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar eol-mnemonic-unix &quot;:&quot;)</pre></td></tr><tr><td class="docs"><p>Specify the coding system for read operations.
  It is useful to bind this variable with `let', but do not set it globally.
  If the value is a coding system, it is used for decoding on read operation.
  If not, an appropriate element is used from one of the coding system alists.
  There are three such tables: `file-coding-system-alist',
  <code>process-coding-system-alist', and</code>network-coding-system-alist'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar coding-system-for-read nil)</pre></td></tr><tr><td class="docs"><p>*String displayed in mode line for MAC-like (CR) end-of-line format.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar eol-mnemonic-mac &quot;/&quot;)</pre></td></tr><tr><td class="docs"><p>Non-nil means process buffer inherits coding system of process output.
  Bind it to t if the process output is to be treated as if it were a file
  read from some filesystem.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inherit-process-coding-system nil)</pre></td></tr><tr><td class="docs"><p>Function to call to select safe coding system for encoding a text.</p>

<p>  If set, this function is called to force a user to select a proper
  coding system which can encode the text in the case that a default
  coding system used in each operation can't encode the text.  The
  function should take care that the buffer is not modified while
  the coding system is being selected.</p>

<p>  The default value is `select-safe-coding-system' (which see).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar select-safe-coding-system-function nil)</pre></td></tr><tr><td class="docs"><p>*String displayed in mode line for DOS-like (CRLF) end-of-line format.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar eol-mnemonic-dos &quot;\\&quot;)</pre></td></tr><tr><td class="docs"><p>Error status of the last code conversion.</p>

<p>  When an error was detected in the last code conversion, this variable
  is set to one of the following symbols.
    `insufficient-source'
    `inconsistent-eol'
    `invalid-source'
    `interrupted'
    `insufficient-memory'
  When no error was detected, the value doesn't change.  So, to check
  the error status of a code conversion by this variable, you must
  explicitly set this variable to nil before performing code
  conversion.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar last-code-conversion-error nil)</pre></td></tr><tr><td class="docs"><p>Alist to decide a coding system to use for a file I/O operation.
  The format is ((PATTERN . VAL) ...),
  where PATTERN is a regular expression matching a file name,
  VAL is a coding system, a cons of coding systems, or a function symbol.
  If VAL is a coding system, it is used for both decoding and encoding
  the file contents.
  If VAL is a cons of coding systems, the car part is used for decoding,
  and the cdr part is used for encoding.
  If VAL is a function symbol, the function must return a coding system
  or a cons of coding systems which are used as above.  The function is
  called with an argument that is a list of the arguments with which
  `find-operation-coding-system' was called.  If the function can't decide
  a coding system, it can return `undecided' so that the normal
  code-detection is performed.</p>

<p>  See also the function `find-operation-coding-system'
  and the variable `auto-coding-alist'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar file-coding-system-alist nil)</pre></td></tr><tr><td class="docs"><p>Alist to decide a coding system to use for a network I/O operation.
  The format is ((PATTERN . VAL) ...),
  where PATTERN is a regular expression matching a network service name
  or is a port number to connect to,
  VAL is a coding system, a cons of coding systems, or a function symbol.
  If VAL is a coding system, it is used for both decoding what received
  from the network stream and encoding what sent to the network stream.
  If VAL is a cons of coding systems, the car part is used for decoding,
  and the cdr part is used for encoding.
  If VAL is a function symbol, the function must return a coding system
  or a cons of coding systems which are used as above.</p>

<p>  See also the function `find-operation-coding-system'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar network-coding-system-alist nil)</pre></td></tr><tr><td class="docs"><p>Cons of coding systems used for process I/O by default.
  The car part is used for decoding a process output,
  the cdr part is used for encoding a text to be sent to a process.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-process-coding-system nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means always inhibit code conversion of end-of-line format.
  See info node <code>Coding Systems' and info node</code>Text and Binary' concerning
  such conversion.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-eol-conversion nil)</pre></td></tr><tr><td class="docs"><p>Alist of coding system names.
  Each element is one element list of coding system name.
  This variable is given to `completing-read' as COLLECTION argument.</p>

<p>  Do not alter the value of this variable manually.  This variable should be
  updated by the functions `make-coding-system' and
  `define-coding-system-alias'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar coding-system-alist nil)</pre></td></tr><tr><td class="docs"><p>Internal use only.
  If non-nil, on writing a file, `select-safe-coding-system-function' is
  called even if `coding-system-for-write' is non-nil.  The command
  `universal-coding-system-argument' binds this variable to t temporarily.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar coding-system-require-warning nil)</pre></td></tr><tr><td class="docs"><p>Coding system to use with system messages.
  Also used for decoding keyboard input on X Window system.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar locale-coding-system nil)</pre></td></tr><tr><td class="docs"><p>Char table for translating self-inserting characters.
  This is applied to the result of input methods, not their input.
  See also `keyboard-translate-table'.</p>

<p>  Use of this variable for character code unification was rendered
  obsolete in Emacs 23.1 and later, since Unicode is now the basis of
  internal character representation.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar translation-table-for-input nil)</pre></td></tr><tr><td class="docs"><p>List of coding-categories (symbols) ordered by priority.</p>

<p>  On detecting a coding system, Emacs tries code detection algorithms
  associated with each coding-category one by one in this order.  When
  one algorithm agrees with a byte sequence of source text, the coding
  system bound to the corresponding coding-category is selected.</p>

<p>  Don't modify this variable directly, but use `set-coding-system-priority'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar coding-category-list nil)</pre></td></tr><tr><td class="docs"><p>Alist to decide a coding system to use for a process I/O operation.
  The format is ((PATTERN . VAL) ...),
  where PATTERN is a regular expression matching a program name,
  VAL is a coding system, a cons of coding systems, or a function symbol.
  If VAL is a coding system, it is used for both decoding what received
  from the program and encoding what sent to the program.
  If VAL is a cons of coding systems, the car part is used for decoding,
  and the cdr part is used for encoding.
  If VAL is a function symbol, the function must return a coding system
  or a cons of coding systems which are used as above.</p>

<p>  See also the function `find-operation-coding-system'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar process-coding-system-alist nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare check-coding-system)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fns/put 'translation-table 'char-table-extra-slots 2)</pre></td></tr><tr><td class="docs"><p>Return the base of CODING-SYSTEM.
  Any alias or subsidiary coding system is not a base coding system.</p>
</td><td class="codes"><pre class="brush: clojure">(defun coding-system-base (coding-system))</pre></td></tr><tr><td class="docs"><p>Encode the Big5 character CH to BIG5 coding system.
  Return the corresponding character code in Big5.</p>
</td><td class="codes"><pre class="brush: clojure">(defun encode-big5-char (ch))</pre></td></tr><tr><td class="docs"><p>Return eol-type of CODING-SYSTEM.
  An eol-type is an integer 0, 1, 2, or a vector of coding systems.</p>

<p>  Integer values 0, 1, and 2 indicate a format of end-of-line; LF, CRLF,
  and CR respectively.</p>

<p>  A vector value indicates that a format of end-of-line should be
  detected automatically.  Nth element of the vector is the subsidiary
  coding system whose eol-type is N.</p>
</td><td class="codes"><pre class="brush: clojure">(defun coding-system-eol-type (coding-system)
  ({&quot;\n&quot; '0 &quot;\r\n&quot; 1 &quot;\r&quot; 2} (System/lineSeparator)))</pre></td></tr><tr><td class="docs"><p>Return the list of aliases of CODING-SYSTEM.</p>
</td><td class="codes"><pre class="brush: clojure">(defun coding-system-aliases (coding-system))</pre></td></tr><tr><td class="docs"><p>Internal use only.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-safe-terminal-coding-system-internal (coding-system))</pre></td></tr><tr><td class="docs"><p>Define ALIAS as an alias for CODING-SYSTEM.</p>
</td><td class="codes"><pre class="brush: clojure">(defun define-coding-system-alias (alias coding-system))</pre></td></tr><tr><td class="docs"><p>Decode a Big5 character which has CODE in BIG5 coding system.
  Return the corresponding character.</p>
</td><td class="codes"><pre class="brush: clojure">(defun decode-big5-char (code))</pre></td></tr><tr><td class="docs"><p>Internal use only.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-keyboard-coding-system-internal (coding-system &amp;optional terminal))</pre></td></tr><tr><td class="docs"><p>Return the property list of CODING-SYSTEM.</p>
</td><td class="codes"><pre class="brush: clojure">(defun coding-system-plist (coding-system))</pre></td></tr><tr><td class="docs"><p>Internal use only.</p>
</td><td class="codes"><pre class="brush: clojure">(defun find-coding-systems-region-internal (start end &amp;optional exclude))</pre></td></tr><tr><td class="docs"><p>Decode the current region from the specified coding system.
  When called from a program, takes four arguments:
    START, END, CODING-SYSTEM, and DESTINATION.
  START and END are buffer positions.</p>

<p>  Optional 4th arguments DESTINATION specifies where the decoded text goes.
  If nil, the region between START and END is replaced by the decoded text.
  If buffer, the decoded text is inserted in that buffer after point (point
  does not move).
  In those cases, the length of the decoded text is returned.
  If DESTINATION is t, the decoded text is returned.</p>

<p>  This function sets `last-coding-system-used' to the precise coding system
  used (which may be different from CODING-SYSTEM if CODING-SYSTEM is
  not fully specified.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun decode-coding-region (start end coding-system &amp;optional destination)
  (interactive &quot;r\nzCoding system: &quot;))</pre></td></tr><tr><td class="docs"><p>Detect coding system of the text in STRING.
  Return a list of possible coding systems ordered by priority.
  The coding systems to try and their priorities follows what
  the function `coding-system-priority-list' (which see) returns.</p>

<p>  If only ASCII characters are found (except for such ISO-2022 control
  characters as ESC), it returns a list of single element `undecided'
  or its subsidiary coding system according to a detected end-of-line
  format.</p>

<p>  If optional argument HIGHEST is non-nil, return the coding system of
  highest priority.</p>
</td><td class="codes"><pre class="brush: clojure">(defun detect-coding-string (string &amp;optional highest))</pre></td></tr><tr><td class="docs"><p>Encode the current region by specified coding system.
  When called from a program, takes four arguments:
          START, END, CODING-SYSTEM and DESTINATION.
  START and END are buffer positions.</p>

<p>  Optional 4th arguments DESTINATION specifies where the encoded text goes.
  If nil, the region between START and END is replace by the encoded text.
  If buffer, the encoded text is inserted in that buffer after point (point
  does not move).
  In those cases, the length of the encoded text is returned.
  If DESTINATION is t, the encoded text is returned.</p>

<p>  This function sets `last-coding-system-used' to the precise coding system
  used (which may be different from CODING-SYSTEM if CODING-SYSTEM is
  not fully specified.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun encode-coding-region (start end coding-system &amp;optional destination)
  (interactive &quot;r\nzCoding system: &quot;))</pre></td></tr><tr><td class="docs"><p>Decode a Japanese character which has CODE in shift_jis encoding.
  Return the corresponding character.</p>
</td><td class="codes"><pre class="brush: clojure">(defun decode-sjis-char (code))</pre></td></tr><tr><td class="docs"><p>Return position of first un-encodable character in a region.
  START and END specify the region and CODING-SYSTEM specifies the
  encoding to check.  Return nil if CODING-SYSTEM does encode the region.</p>

<p>  If optional 4th argument COUNT is non-nil, it specifies at most how
  many un-encodable characters to search.  In this case, the value is a
  list of positions.</p>

<p>  If optional 5th argument STRING is non-nil, it is a string to search
  for un-encodable characters.  In that case, START and END are indexes
  to the string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun unencodable-char-position (start end coding-system &amp;optional count string))</pre></td></tr><tr><td class="docs"><p>Read a coding system from the minibuffer, prompting with string PROMPT.
  If the user enters null input, return second argument DEFAULT-CODING-SYSTEM.
  Ignores case when completing coding systems (all Emacs coding systems
  are lower-case).</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-coding-system (prompt &amp;optional default-coding-system))</pre></td></tr><tr><td class="docs"><p>Check if the region is encodable by coding systems.</p>

<p>  START and END are buffer positions specifying the region.
  CODING-SYSTEM-LIST is a list of coding systems to check.</p>

<p>  The value is an alist ((CODING-SYSTEM POS0 POS1 ...) ...), where
  CODING-SYSTEM is a member of CODING-SYSTEM-LIST and can't encode the
  whole region, POS0, POS1, ... are buffer positions where non-encodable
  characters are found.</p>

<p>  If all coding systems in CODING-SYSTEM-LIST can encode the region, the
  value is nil.</p>

<p>  START may be a string.  In that case, check if the string is
  encodable, and the value contains indices to the string instead of
  buffer positions.  END is ignored.</p>

<p>  If the current buffer (or START if it is a string) is unibyte, the value
  is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun check-coding-systems-region (start end coding-system-list))</pre></td></tr><tr><td class="docs"><p>Encode STRING to CODING-SYSTEM, and return the result.</p>

<p>  Optional third arg NOCOPY non-nil means it is OK to return STRING
  itself if the encoding operation is trivial.</p>

<p>  Optional fourth arg BUFFER non-nil means that the encoded text is
  inserted in that buffer after point (point does not move).  In this
  case, the return value is the length of the encoded text.</p>

<p>  This function sets `last-coding-system-used' to the precise coding system
  used (which may be different from CODING-SYSTEM if CODING-SYSTEM is
  not fully specified.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun encode-coding-string (string coding-system &amp;optional nocopy buffer)
  (check-coding-system coding-system)
  (el/setq last-coding-system-used coding-system)
  string)</pre></td></tr><tr><td class="docs"><p>Choose a coding system for an operation based on the target name.
  The value names a pair of coding systems: (DECODING-SYSTEM . ENCODING-SYSTEM).
  DECODING-SYSTEM is the coding system to use for decoding
  (in case OPERATION does decoding), and ENCODING-SYSTEM is the coding system
  for encoding (in case OPERATION does encoding).</p>

<p>  The first argument OPERATION specifies an I/O primitive:
    For file I/O, <code>insert-file-contents' or</code>write-region'.
    For process I/O, <code>call-process',</code>call-process-region', or `start-process'.
    For network I/O, `open-network-stream'.</p>

<p>  The remaining arguments should be the same arguments that were passed
  to the primitive.  Depending on which primitive, one of those arguments
  is selected as the TARGET.  For example, if OPERATION does file I/O,
  whichever argument specifies the file name is TARGET.</p>

<p>  TARGET has a meaning which depends on OPERATION:
    For file I/O, TARGET is a file name (except for the special case below).
    For process I/O, TARGET is a process name.
    For network I/O, TARGET is a service name or a port number.</p>

<p>  This function looks up what is specified for TARGET in
  <code>file-coding-system-alist',</code>process-coding-system-alist',
  or `network-coding-system-alist' depending on OPERATION.
  They may specify a coding system, a cons of coding systems,
  or a function symbol to call.
  In the last case, we call the function with one argument,
  which is a list of all the arguments given to this function.
  If the function can't decide a coding system, it can return
  `undecided' so that the normal code-detection is performed.</p>

<p>  If OPERATION is `insert-file-contents', the argument corresponding to
  TARGET may be a cons (FILENAME . BUFFER).  In that case, FILENAME is a
  file name to look up, and BUFFER is a buffer that contains the file's
  contents (not yet decoded).  If `file-coding-system-alist' specifies a
  function to call for FILENAME, that function should examine the
  contents of BUFFER instead of reading the file.</p>
</td><td class="codes"><pre class="brush: clojure">(defun find-operation-coding-system (operation &amp;rest arguments))</pre></td></tr><tr><td class="docs"><p>Return coding system specified for terminal output on the given terminal.
  TERMINAL may be a terminal object, a frame, or nil for the selected
  frame's terminal device.</p>
</td><td class="codes"><pre class="brush: clojure">(defun terminal-coding-system (&amp;optional terminal))</pre></td></tr><tr><td class="docs"><p>Return a list of coding systems ordered by their priorities.
  The list contains a subset of coding systems; i.e. coding systems
  assigned to each coding category (see `coding-category-list').</p>

<p>  HIGHESTP non-nil means just return the highest priority one.</p>
</td><td class="codes"><pre class="brush: clojure">(defun coding-system-priority-list (&amp;optional highestp))</pre></td></tr><tr><td class="docs"><p>Return coding system specified for decoding keyboard input.</p>
</td><td class="codes"><pre class="brush: clojure">(defun keyboard-coding-system (&amp;optional terminal)
  'iso-latin-1-unix)</pre></td></tr><tr><td class="docs"><p>Detect coding system of the text in the region between START and END.
  Return a list of possible coding systems ordered by priority.
  The coding systems to try and their priorities follows what
  the function `coding-system-priority-list' (which see) returns.</p>

<p>  If only ASCII characters are found (except for such ISO-2022 control
  characters as ESC), it returns a list of single element `undecided'
  or its subsidiary coding system according to a detected end-of-line
  format.</p>

<p>  If optional argument HIGHEST is non-nil, return the coding system of
  highest priority.</p>
</td><td class="codes"><pre class="brush: clojure">(defun detect-coding-region (start end &amp;optional highest))</pre></td></tr><tr><td class="docs"><p>For internal use only.</p>
</td><td class="codes"><pre class="brush: clojure">(defun define-coding-system-internal (&amp;rest args))</pre></td></tr><tr><td class="docs"><p>Change value in CODING-SYSTEM's property list PROP to VAL.</p>
</td><td class="codes"><pre class="brush: clojure">(defun coding-system-put (coding-system prop val))</pre></td></tr><tr><td class="docs"><p>Decode STRING which is encoded in CODING-SYSTEM, and return the result.</p>

<p>  Optional third arg NOCOPY non-nil means it is OK to return STRING itself
  if the decoding operation is trivial.</p>

<p>  Optional fourth arg BUFFER non-nil means that the decoded text is
  inserted in that buffer after point (point does not move).  In this
  case, the return value is the length of the decoded text.</p>

<p>  This function sets `last-coding-system-used' to the precise coding system
  used (which may be different from CODING-SYSTEM if CODING-SYSTEM is
  not fully specified.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun decode-coding-string (string coding-system &amp;optional nocopy buffer)
  (check-coding-system coding-system)
  (el/setq last-coding-system-used coding-system)
  string)</pre></td></tr><tr><td class="docs"><p>Internal use only.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-terminal-coding-system-internal (coding-system &amp;optional terminal))</pre></td></tr><tr><td class="docs"><p>Read a coding system from the minibuffer, prompting with string PROMPT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun read-non-nil-coding-system (prompt))</pre></td></tr><tr><td class="docs"><p>Encode a Japanese character CH to shift_jis encoding.
  Return the corresponding code in SJIS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun encode-sjis-char (ch))</pre></td></tr><tr><td class="docs"><p>Assign higher priority to the coding systems given as arguments.
  If multiple coding systems belong to the same category,
  all but the first one are ignored.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-coding-system-priority (&amp;rest coding-systems))</pre></td></tr><tr><td class="docs"><p>Check validity of CODING-SYSTEM.
  If valid, return CODING-SYSTEM, else signal a `coding-system-error' error.
  It is valid if it is nil or a symbol defined as a coding system by the
  function `define-coding-system'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun check-coding-system (coding-system)
  (if (nil? coding-system)
    coding-system
    (el/throw 'coding-system-error coding-system)))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is nil or a coding-system.
  See the documentation of `define-coding-system' for information
  about coding-system objects.</p>
</td><td class="codes"><pre class="brush: clojure">(defun coding-system-p (object))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.marker" name="deuce.emacs.marker"><h1 class="project-name">deuce.emacs.marker</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.marker
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data])
  (:import [deuce.emacs.data Buffer BufferText Marker])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Non-nil enables debugging checks in byte/char position conversions.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar byte-debug-flag nil)</pre></td></tr><tr><td class="docs"><p>Return the position MARKER points at, as a character number.
  Returns nil if MARKER points nowhere.</p>
</td><td class="codes"><pre class="brush: clojure">(defun marker-position (marker)
  @(.charpos ^Marker marker))</pre></td></tr><tr><td class="docs"><p>Return t if there are markers pointing at POSITION in the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun buffer-has-markers-at (position))</pre></td></tr><tr><td class="docs"><p>Return a new marker pointing at the same place as MARKER.
  If argument is a number, makes a new marker pointing
  at that position in the current buffer.
  If MARKER is not specified, the new marker does not point anywhere.
  The optional argument TYPE specifies the insertion type of the new marker;
  see `marker-insertion-type'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun copy-marker (&amp;optional marker type)
  ((ns-resolve 'deuce.emacs.buffer 'allocate-marker) type
   (buffer/current-buffer) (if (data/markerp marker)
                             @(.charpos ^Marker marker)
                             (el/check-type 'integerp marker))))</pre></td></tr><tr><td class="docs"><p>Return insertion type of MARKER: t if it stays after inserted text.
  The value nil means the marker stays before text inserted there.</p>
</td><td class="codes"><pre class="brush: clojure">(defun marker-insertion-type (marker)
  @(.insertion-type ^Marker marker))</pre></td></tr><tr><td class="docs"><p>Set the insertion-type of MARKER to TYPE.
  If TYPE is t, it means the marker advances when you insert text at it.
  If TYPE is nil, it means the marker stays behind when you insert text at it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-marker-insertion-type (marker type)
  (reset! (.insertion-type ^Marker marker) type))</pre></td></tr><tr><td class="docs"><p>Return the buffer that MARKER points into, or nil if none.
  Returns nil if MARKER points into a dead buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun marker-buffer (marker)
  @(.buffer ^Marker marker))</pre></td></tr><tr><td class="docs"><p>Position MARKER before character number POSITION in BUFFER.
  BUFFER defaults to the current buffer.
  If POSITION is nil, makes marker point nowhere.
  Then it no longer slows down editing in any buffer.
  Returns MARKER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-marker (marker position &amp;optional buffer)
  (let [^Buffer buffer (el/check-type 'bufferp (or buffer (buffer/current-buffer)))
        ^Marker marker marker]
    (when-let [^Buffer old-buffer @(.buffer marker)]
      (swap! (.markers ^BufferText (.text old-buffer)) #(seq (remove #{marker} %))))
    (reset! (.buffer marker) buffer)
    (reset! (.charpos marker) position)
    (swap! (.markers ^BufferText (.text buffer)) conj marker)
    marker))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.category" name="deuce.emacs.category"><h1 class="project-name">deuce.emacs.category</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.category
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs.fns :as fns])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>List of pair (cons) of categories to determine word boundary.
  See the documentation of the variable `word-combining-categories'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar word-separating-categories nil)</pre></td></tr><tr><td class="docs"><p>List of pair (cons) of categories to determine word boundary.</p>

<p>  Emacs treats a sequence of word constituent characters as a single
  word (i.e. finds no word boundary between them) only if they belong to
  the same script.  But, exceptions are allowed in the following cases.</p>

<p>  (1) The case that characters are in different scripts is controlled
  by the variable `word-combining-categories'.</p>

<p>  Emacs finds no word boundary between characters of different scripts
  if they have categories matching some element of this list.</p>

<p>  More precisely, if an element of this list is a cons of category CAT1
  and CAT2, and a multibyte character C1 which has CAT1 is followed by
  C2 which has CAT2, there's no word boundary between C1 and C2.</p>

<p>  For instance, to tell that Han characters followed by Hiragana
  characters can form a single word, the element `(?C . ?H)' should be
  in this list.</p>

<p>  (2) The case that character are in the same script is controlled by
  the variable `word-separating-categories'.</p>

<p>  Emacs finds a word boundary between characters of the same script
  if they have categories matching some element of this list.</p>

<p>  More precisely, if an element of this list is a cons of category CAT1
  and CAT2, and a multibyte character C1 which has CAT1 but not CAT2 is
  followed by C2 which has CAT2 but not CAT1, there's a word boundary
  between C1 and C2.</p>

<p>  For instance, to tell that there's a word boundary between Hiragana
  and Katakana (both are in the same script `kana'),
  the element `(?H . ?K) should be in this list.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar word-combining-categories nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fns/put 'category-table 'char-table-extra-slots 2)</pre></td></tr><tr><td class="docs"><p>Return the standard category table.
  This is the one used for new buffers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun standard-category-table ())</pre></td></tr><tr><td class="docs"><p>Construct a new and empty category table and return it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-category-table ())</pre></td></tr><tr><td class="docs"><p>Construct a new category table and return it.
  It is a copy of the TABLE, which defaults to the standard category table.</p>
</td><td class="codes"><pre class="brush: clojure">(defun copy-category-table (&amp;optional table))</pre></td></tr><tr><td class="docs"><p>Return the category set of CHAR.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-category-set (char))</pre></td></tr><tr><td class="docs"><p>Return a newly created category-set which contains CATEGORIES.
  CATEGORIES is a string of category mnemonics.
  The value is a bool-vector which has t at the indices corresponding to
  those categories.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-category-set (categories))</pre></td></tr><tr><td class="docs"><p>Return a string containing mnemonics of the categories in CATEGORY-SET.
  CATEGORY-SET is a bool-vector, and the categories "in" it are those
  that are indexes where t occurs in the bool-vector.
  The return value is a string containing those same categories.</p>
</td><td class="codes"><pre class="brush: clojure">(defun category-set-mnemonics (category-set))</pre></td></tr><tr><td class="docs"><p>Specify TABLE as the category table for the current buffer.
  Return TABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-category-table (table))</pre></td></tr><tr><td class="docs"><p>Return t if ARG is a category table.</p>
</td><td class="codes"><pre class="brush: clojure">(defun category-table-p (arg))</pre></td></tr><tr><td class="docs"><p>Return the current category table.
  This is the one specified by the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun category-table ())</pre></td></tr><tr><td class="docs"><p>Modify the category set of CHARACTER by adding CATEGORY to it.
  The category is changed only for table TABLE, which defaults to
  the current buffer's category table.
  CHARACTER can be either a single character or a cons representing the
  lower and upper ends of an inclusive character range to modify.
  If optional fourth argument RESET is non-nil,
  then delete CATEGORY from the category set instead of adding it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun modify-category-entry (character category &amp;optional table reset))</pre></td></tr><tr><td class="docs"><p>Return the documentation string of CATEGORY, as defined in TABLE.
  TABLE should be a category table and defaults to the current buffer's
  category table.</p>
</td><td class="codes"><pre class="brush: clojure">(defun category-docstring (category &amp;optional table))</pre></td></tr><tr><td class="docs"><p>Define CATEGORY as a category which is described by DOCSTRING.
  CATEGORY should be an ASCII printing character in the range <code>' to</code>~'.
  DOCSTRING is the documentation string of the category.  The first line
  should be a terse text (preferably less than 16 characters),
  and the rest lines should be the full description.
  The category is defined only in category table TABLE, which defaults to
  the current buffer's category table.</p>
</td><td class="codes"><pre class="brush: clojure">(defun define-category (category docstring &amp;optional table))</pre></td></tr><tr><td class="docs"><p>Return a category which is not yet defined in TABLE.
  If no category remains available, return nil.
  The optional argument TABLE specifies which category table to modify;
  it defaults to the current buffer's category table.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-unused-category (&amp;optional table))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.print" name="deuce.emacs.print"><h1 class="project-name">deuce.emacs.print</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.print
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns])
  (:refer-clojure :exclude [print]))</pre></td></tr><tr><td class="docs"><p>*Non-nil means print recursive structures using #N= and #N# syntax.
  If nil, printing proceeds recursively and may lead to
  `max-lisp-eval-depth' being exceeded or an error may occur:
  "Apparently circular structure being printed."  Also see
  <code>print-length' and</code>print-level'.
  If non-nil, shared substructures anywhere in the structure are printed
  with `#N=' before the first occurrence (in the order of the print
  representation) and `#N#' in place of each subsequent occurrence,
  where N is a positive decimal integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-circle nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means print uninterned symbols so they will read as uninterned.
  I.e., the value of (make-symbol "foobar") prints as #:foobar.
  When the uninterned symbol appears within a recursive data structure,
  and the symbol appears more than once, in addition use the #N# and #N=
  constructs as needed, so that multiple references to the same symbol are
  shared once again when the text is read back.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-gensym nil)</pre></td></tr><tr><td class="docs"><p>A flag to control printing of `charset' text property on printing a string.
  The value must be nil, t, or `default'.</p>

<p>  If the value is nil, don't print the text property `charset'.</p>

<p>  If the value is t, always print the text property `charset'.</p>

<p>  If the value is <code>default', print the text property</code>charset' only when
  the value is different from what is guessed in the current charset
  priorities.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-charset-text-property nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means print multibyte characters in strings as \xXXXX.
  (XXXX is the hex representation of the character code.)
  This affects only `prin1'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-escape-multibyte nil
  &quot;Non-nil means print multibyte characters in strings as \\xXXXX.
  (XXXX is the hex representation of the character code.)
  This affects only `prin1'.&quot;)</pre></td></tr><tr><td class="docs"><p>Output stream `print' uses by default for outputting a character.
  This may be any function of one argument.
  It may also be a buffer (output is inserted before point)
  or a marker (output is inserted and the marker is advanced)
  or the symbol t (output appears in the echo area).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar standard-output nil)</pre></td></tr><tr><td class="docs"><p>The format descriptor string used to print floats.
  This is a %-spec like those accepted by `printf' in C,
  but with some restrictions.  It must start with the two characters `%.'.
  After that comes an integer precision specification,
  and then a letter which controls the format.
  The letters allowed are <code>e',</code>f' and `g'.
  Use `e' for exponential notation "DIG.DIGITSeEXPT"
  Use `f' for decimal point notation "DIGITS.DIGITS".
  Use `g' to choose the shorter of those two formats for the number at hand.
  The precision in any of these cases is the number of digits following
  the decimal point.  With `f', a precision of 0 means to omit the
  decimal point.  0 is not allowed with <code>e' or</code>g'.</p>

<p>  A value of nil means to use the shortest notation
  that represents the number without losing information.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar float-output-format nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means print newlines in strings as `\n'.
  Also print formfeeds as `\f'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-escape-newlines nil
  &quot;Non-nil means print newlines in strings as `\\n'.
  Also print formfeeds as `\\f'.&quot;)</pre></td></tr><tr><td class="docs"><p>Non-nil means print quoted forms with reader syntax.
  I.e., (quote foo) prints as 'foo, (function foo) as #'foo.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-quoted nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means number continuously across print calls.
  This affects the numbers printed for #N= labels and #M# references.
  See also <code>print-circle',</code>print-gensym', and `print-number-table'.
  This variable should not be set with <code>setq'; bind it with a</code>let' instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-continuous-numbering nil)</pre></td></tr><tr><td class="docs"><p>Maximum depth of list nesting to print before abbreviating.
  A value of nil means no limit.  See also `eval-expression-print-level'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-level nil)</pre></td></tr><tr><td class="docs"><p>A vector used internally to produce <code>#N=' labels and</code>#N#' references.
  The Lisp printer uses this vector to detect Lisp objects referenced more
  than once.</p>

<p>  When you bind `print-continuous-numbering' to t, you should probably
  also bind `print-number-table' to nil.  This ensures that the value of
  `print-number-table' can be garbage-collected once the printing is
  done.  If all elements of `print-number-table' are nil, it means that
  the printing done so far has not found any shared structure or objects
  that need to be recorded in the table.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-number-table nil)</pre></td></tr><tr><td class="docs"><p>Maximum length of list to print before abbreviating.
  A value of nil means no limit.  See also `eval-expression-print-length'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-length nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means print unibyte non-ASCII chars in strings as \OOO.
  (OOO is the octal representation of the character code.)
  Only single-byte characters are affected, and only in `prin1'.
  When the output goes in a multibyte buffer, this feature is
  enabled regardless of the value of the variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar print-escape-nonascii nil
  &quot;Non-nil means print unibyte non-ASCII chars in strings as \\OOO.
  (OOO is the octal representation of the character code.)
  Only single-byte characters are affected, and only in `prin1'.
  When the output goes in a multibyte buffer, this feature is
  enabled regardless of the value of the variable.&quot;)</pre></td></tr><tr><td class="docs"><p>Convert an error value (ERROR-SYMBOL . DATA) to an error message.
  See Info anchor `(elisp)Definition of signal' for some details on how this
  error message is constructed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun error-message-string (obj))</pre></td></tr><tr><td class="docs"><p>Output the printed representation of OBJECT, with newlines around it.
  Quoting characters are printed when needed to make output that `read'
  can handle, whenever this is possible.  For complex objects, the behavior
  is controlled by <code>print-level' and</code>print-length', which see.</p>

<p>  OBJECT is any of the Lisp data types: a number, a string, a symbol,
  a list, a buffer, a window, a frame, etc.</p>

<p>  A printed representation of an object is text which describes that object.</p>

<p>  Optional argument PRINTCHARFUN is the output stream, which can be one
  of these:</p>

<pre><code> - a buffer, in which case output is inserted into that buffer at point;
 - a marker, in which case output is inserted at marker's position;
 - a function, in which case that function is called once for each
   character of OBJECT's printed representation;
 - a symbol, in which case that symbol's function definition is called; or
 - t, in which case the output is displayed in the echo area.
</code></pre>

<p>  If PRINTCHARFUN is omitted, the value of `standard-output' (which see)
  is used instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun print (object &amp;optional printcharfun)
  (println object)
  object)</pre></td></tr><tr><td class="docs"><p>Redirect debugging output (stderr stream) to file FILE.
  If FILE is nil, reset target to the initial stderr stream.
  Optional arg APPEND non-nil (interactively, with prefix arg) means
  append to existing target file.</p>
</td><td class="codes"><pre class="brush: clojure">(defun redirect-debugging-output (file &amp;optional append))</pre></td></tr><tr><td class="docs"><p>Output a newline to stream PRINTCHARFUN.
  If PRINTCHARFUN is omitted or nil, the value of `standard-output' is used.</p>
</td><td class="codes"><pre class="brush: clojure">(defun terpri (&amp;optional printcharfun)
  (println)
  true)</pre></td></tr><tr><td class="docs"><p>Return a string containing the printed representation of OBJECT.
  OBJECT can be any Lisp object.  This function outputs quoting characters
  when necessary to make output that `read' can handle, whenever possible,
  unless the optional second argument NOESCAPE is non-nil.  For complex objects,
  the behavior is controlled by <code>print-level' and</code>print-length', which see.</p>

<p>  OBJECT is any of the Lisp data types: a number, a string, a symbol,
  a list, a buffer, a window, a frame, etc.</p>

<p>  A pqrinted representation of an object is text which describes that object.</p>
</td><td class="codes"><pre class="brush: clojure">(defun prin1-to-string (object &amp;optional noescape)
  (pr-str object))</pre></td></tr><tr><td class="docs"><p>Output the printed representation of OBJECT, any Lisp object.
  Quoting characters are printed when needed to make output that `read'
  can handle, whenever this is possible.  For complex objects, the behavior
  is controlled by <code>print-level' and</code>print-length', which see.</p>

<p>  OBJECT is any of the Lisp data types: a number, a string, a symbol,
  a list, a buffer, a window, a frame, etc.</p>

<p>  A printed representation of an object is text which describes that object.</p>

<p>  Optional argument PRINTCHARFUN is the output stream, which can be one
  of these:</p>

<pre><code> - a buffer, in which case output is inserted into that buffer at point;
 - a marker, in which case output is inserted at marker's position;
 - a function, in which case that function is called once for each
   character of OBJECT's printed representation;
 - a symbol, in which case that symbol's function definition is called; or
 - t, in which case the output is displayed in the echo area.
</code></pre>

<p>  If PRINTCHARFUN is omitted, the value of `standard-output' (which see)
  is used instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun prin1 (object &amp;optional printcharfun)
  (let [printcharfun (or printcharfun (data/symbol-value 'standard-output))
        s (prin1-to-string object)]
    (condp some [printcharfun]
      #{nil true} (editfns/message s)
      data/bufferp (binding [buffer/*current-buffer* printcharfun]
                     (editfns/insert s)))))</pre></td></tr><tr><td class="docs"><p>Write CHARACTER to stderr.
  You can call print while debugging emacs, and pass it this function
  to make it write to the debugging output.</p>
</td><td class="codes"><pre class="brush: clojure">(defun external-debugging-output (character))</pre></td></tr><tr><td class="docs"><p>Output the printed representation of OBJECT, any Lisp object.
  No quoting characters are used; no delimiters are printed around
  the contents of strings.</p>

<p>  OBJECT is any of the Lisp data types: a number, a string, a symbol,
  a list, a buffer, a window, a frame, etc.</p>

<p>  A printed representation of an object is text which describes that object.</p>

<p>  Optional argument PRINTCHARFUN is the output stream, which can be one
  of these:</p>

<pre><code> - a buffer, in which case output is inserted into that buffer at point;
 - a marker, in which case output is inserted at marker's position;
 - a function, in which case that function is called once for each
   character of OBJECT's printed representation;
 - a symbol, in which case that symbol's function definition is called; or
 - t, in which case the output is displayed in the echo area.
</code></pre>

<p>  If PRINTCHARFUN is omitted, the value of `standard-output' (which see)
  is used instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun princ (object &amp;optional printcharfun)
  (println object))</pre></td></tr><tr><td class="docs"><p>Output character CHARACTER to stream PRINTCHARFUN.
  PRINTCHARFUN defaults to the value of `standard-output' (which see).</p>
</td><td class="codes"><pre class="brush: clojure">(defun write-char (character &amp;optional printcharfun))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.xfaces" name="deuce.emacs.xfaces"><h1 class="project-name">deuce.emacs.xfaces</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.xfaces
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Alist of fonts vs the rescaling factors.
  Each element is a cons (FONT-PATTERN . RESCALE-RATIO), where
  FONT-PATTERN is a font-spec or a regular expression matching a font name, and
  RESCALE-RATIO is a floating point number to specify how much larger
  (or smaller) font we should use.  For instance, if a face requests
  a font of 10 point, we actually use a font of 10 * RESCALE-RATIO point.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar face-font-rescale-alist nil)</pre></td></tr><tr><td class="docs"><p>Alist of face remappings.
  Each element is of the form:</p>

<pre><code> (FACE . REPLACEMENT),
</code></pre>

<p>  which causes display of the face FACE to use REPLACEMENT instead.
  REPLACEMENT is a face specification, i.e. one of the following:</p>

<pre><code>(1) a face name
(2) a property list of attribute/value pairs, or
(3) a list in which each element has the form of (1) or (2).
</code></pre>

<p>  List values for REPLACEMENT are merged to form the final face
  specification, with earlier entries taking precedence, in the same as
  as in the `face' text property.</p>

<p>  Face-name remapping cycles are suppressed; recursive references use
  the underlying face instead of the remapped face.  So a remapping of
  the form:</p>

<pre><code> (FACE EXTRA-FACE... FACE)
</code></pre>

<p>  or:</p>

<pre><code> (FACE (FACE-ATTR VAL ...) FACE)
</code></pre>

<p>  causes EXTRA-FACE... or (FACE-ATTR VAL ...) to be <em>merged</em> with the
  existing definition of FACE.  Note that this isn't necessary for the
  default face, since every face inherits from the default face.</p>

<p>  If this variable is made buffer-local, the face remapping takes effect
  only in that buffer.  For instance, the mode my-mode could define a
  face `my-mode-default', and then in the mode setup function, do:</p>

<pre><code> (set (make-local-variable 'face-remapping-alist)
'((default my-mode-default)))).
</code></pre>

<p>  Because Emacs normally only redraws screen areas when the underlying
  buffer contents change, you may need to call `redraw-display' after
  changing this variable for it to take effect.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar face-remapping-alist nil)</pre></td></tr><tr><td class="docs"><p>An alist of defined terminal colors and their RGB values.
  See the docstring of `tty-color-alist' for the details.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar tty-defined-color-alist nil)</pre></td></tr><tr><td class="docs"><p>*Default stipple pattern used on monochrome displays.
  This stipple pattern is used on monochrome displays
  instead of shades of gray for a face background color.
  See `set-face-stipple' for possible values for this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar face-default-stipple nil)</pre></td></tr><tr><td class="docs"><p>*Limit for font matching.
  If an integer > 0, font matching functions won't load more than
  that number of fonts when searching for a matching font.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar font-list-limit nil)</pre></td></tr><tr><td class="docs"><p>Allowed scalable fonts.
  A value of nil means don't allow any scalable fonts.
  A value of t means allow any scalable font.
  Otherwise, value must be a list of regular expressions.  A font may be
  scaled if its name matches a regular expression in the list.
  Note that if value is nil, a scalable font might still be used, if no
  other font of the appropriate family and registry is available.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar scalable-fonts-allowed nil)</pre></td></tr><tr><td class="docs"><p>List of ignored fonts.
  Each element is a regular expression that matches names of fonts to
  ignore.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar face-ignored-fonts nil)</pre></td></tr><tr><td class="docs"><p>List of global face definitions (for internal use only.)</p>
</td><td class="codes"><pre class="brush: clojure">(defvar face-new-frame-defaults nil)</pre></td></tr><tr><td class="docs"><p>Make FACE, a symbol, a Lisp face with all attributes nil.
  If FACE was not known as a face before, create a new one.
  If optional argument FRAME is specified, make a frame-local face
  for that frame.  Otherwise operate on the global face definition.
  Value is a vector of face attributes.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-make-lisp-face (face &amp;optional frame)
  nil)</pre></td></tr><tr><td class="docs"><p>Return non-nil if all the face attributes in ATTRIBUTES are supported.
  The optional argument DISPLAY can be a display name, a frame, or
  nil (meaning the selected frame's display).</p>

<p>  The definition of `supported' is somewhat heuristic, but basically means
  that a face containing all the attributes in ATTRIBUTES, when merged
  with the default face for display, can be represented in a way that's</p>

<p>   (1) different in appearance than the default face, and
   (2) `close in spirit' to what the attributes specify, if not exact.</p>

<p>  Point (2) implies that a `:weight black' attribute will be satisfied by
  any display that can display bold, and a `:foreground "yellow"' as long
  as it can display a yellowish color, but `:slant italic' will <em>not</em> be
  satisfied by the tty display code's automatic substitution of a `dim'
  face for italic.</p>
</td><td class="codes"><pre class="brush: clojure">(defun display-supports-face-attributes-p (attributes &amp;optional display)
  nil)</pre></td></tr><tr><td class="docs"><p>Check whether a face attribute value is relative.
  Specifically, this function returns t if the attribute ATTRIBUTE
  with the value VALUE is relative.</p>

<p>  A relative value is one that doesn't entirely override whatever is
  inherited from another face.  For most possible attributes,
  the only relative value that users see is `unspecified'.
  However, for :height, floating point values are also relative.</p>
</td><td class="codes"><pre class="brush: clojure">(defun face-attribute-relative-p (attribute value))</pre></td></tr><tr><td class="docs"><p>Return non-nil if COLOR can be displayed on FRAME.
  BACKGROUND-P non-nil means COLOR is used as a background.
  Otherwise, this function tells whether it can be used as a foreground.
  If FRAME is nil or omitted, use the selected frame.
  COLOR must be a valid color name.</p>
</td><td class="codes"><pre class="brush: clojure">(defun color-supported-p (color &amp;optional frame background-p))</pre></td></tr><tr><td class="docs"><p>Create an alist of color entries from an external file.</p>

<p>  The file should define one named RGB color per line like so:
    R G B   name
  where R,G,B are numbers between 0 and 255 and name is an arbitrary string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun x-load-color-file (filename))</pre></td></tr><tr><td class="docs"><p>True if FACE has no attribute specified.
  If the optional argument FRAME is given, report on face FACE in that frame.
  If FRAME is t, report on the defaults for face FACE (for new frames).
  If FRAME is omitted or nil, use the selected frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-lisp-face-empty-p (face &amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Set attribute ATTR of FACE to VALUE.
  FRAME being a frame means change the face on that frame.
  FRAME nil means change the face of the selected frame.
  FRAME t means change the default for new frames.
  FRAME 0 means change the face on all frames, and change the default
    for new frames.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-set-lisp-face-attribute (face attr value &amp;optional frame)
  nil)</pre></td></tr><tr><td class="docs"><p>Clear face caches on all frames.
  Optional THOROUGHLY non-nil means try to free unused fonts, too.</p>
</td><td class="codes"><pre class="brush: clojure">(defun clear-face-cache (&amp;optional thoroughly))</pre></td></tr><tr><td class="docs"><p>Define alternative font registries to try in face font selection.
  ALIST is an alist of (REGISTRY ALTERNATIVE1 ALTERNATIVE2 ...) entries.
  Each ALTERNATIVE is tried in order if no fonts of font registry REGISTRY can
  be found.  Value is ALIST.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-set-alternative-font-registry-alist (alist)
  nil)</pre></td></tr><tr><td class="docs"><p>Return face ATTRIBUTE VALUE1 merged with VALUE2.
  If VALUE1 or VALUE2 are absolute (see `face-attribute-relative-p'), then
  the result will be absolute, otherwise it will be relative.</p>
</td><td class="codes"><pre class="brush: clojure">(defun merge-face-attribute (attribute value1 value2))</pre></td></tr><tr><td class="docs"><p>Return non-nil if COLOR is a shade of gray (or white or black).
  FRAME specifies the frame and thus the display for interpreting COLOR.
  If FRAME is nil or omitted, use the selected frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun color-gray-p (color &amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Suppress/allow boldness of faces with inverse default colors.
  SUPPRESS non-nil means suppress it.
  This affects bold faces on TTYs whose foreground is the default background
  color of the display and whose background is the default foreground color.
  For such faces, the bold face attribute is ignored if this variable
  is non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun tty-suppress-bold-inverse-default-colors (suppress))</pre></td></tr><tr><td class="docs"><p>Add attributes from frame-default definition of FACE to FACE on FRAME.
  Default face attributes override any local face attributes.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-merge-in-global-face (face frame))</pre></td></tr><tr><td class="docs"><p>Return the font name of face FACE, or nil if it is unspecified.
  The font name is, by default, for ASCII characters.
  If the optional argument FRAME is given, report on face FACE in that frame.
  If FRAME is t, report on the defaults for face FACE (for new frames).
    The font default for a face is either nil, or a list
    of the form (bold), (italic) or (bold italic).
  If FRAME is omitted or nil, use the selected frame.  And, in this case,
  if the optional third argument CHARACTER is given,
  return the font name used for CHARACTER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun face-font (face &amp;optional frame character))</pre></td></tr><tr><td class="docs"><p>Return a list of valid discrete values for face attribute ATTR.
  Value is nil if ATTR doesn't have a discrete set of valid values.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-lisp-face-attribute-values (attr))</pre></td></tr><tr><td class="docs"><p>True if FACE1 and FACE2 are equal.
  If the optional argument FRAME is given, report on FACE1 and FACE2 in that frame.
  If FRAME is t, report on the defaults for FACE1 and FACE2 (for new frames).
  If FRAME is omitted or nil, use the selected frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-lisp-face-equal-p (face1 face2 &amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Set font selection order for face font selection to ORDER.
  ORDER must be a list of length 4 containing the symbols `:width',
  <code>:height',</code>:weight', and `:slant'.  Face attributes appearing
  first in ORDER are matched first, e.g. if `:height' appears before
  `:weight' in ORDER, font selection first tries to find a font with
  a suitable height, and then tries to match the font weight.
  Value is ORDER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-set-font-selection-order (order))</pre></td></tr><tr><td class="docs"><p>Return non-nil if FACE names a face.
  FACE should be a symbol or string.
  If optional second argument FRAME is non-nil, check for the
  existence of a frame-local face with name FACE on that frame.
  Otherwise check for the existence of a global face.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-lisp-face-p (face &amp;optional frame)
  nil)</pre></td></tr><tr><td class="docs"><p>Copy face FROM to TO.
  If FRAME is t, copy the global face definition of FROM.
  Otherwise, copy the frame-local definition of FROM on FRAME.
  If NEW-FRAME is a frame, copy that data into the frame-local
  definition of TO on NEW-FRAME.  If NEW-FRAME is nil,
  FRAME controls where the data is copied to.</p>

<p>  The value is TO.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-copy-lisp-face (from to frame new-frame))</pre></td></tr><tr><td class="docs"><p>Return an alist of frame-local faces defined on FRAME.
  For internal use only.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-face-alist (&amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Define alternative font families to try in face font selection.
  ALIST is an alist of (FAMILY ALTERNATIVE1 ALTERNATIVE2 ...) entries.
  Each ALTERNATIVE is tried in order if no fonts of font family FAMILY can
  be found.  Value is ALIST.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-set-alternative-font-family-alist (alist))</pre></td></tr><tr><td class="docs"><p>Return a vector of face attributes corresponding to PLIST.</p>
</td><td class="codes"><pre class="brush: clojure">(defun face-attributes-as-vector (plist))</pre></td></tr><tr><td class="docs"><p>Return face attribute KEYWORD of face SYMBOL.
  If SYMBOL does not name a valid Lisp face or KEYWORD isn't a valid
  face attribute name, signal an error.
  If the optional argument FRAME is given, report on face SYMBOL in that
  frame.  If FRAME is t, report on the defaults for face SYMBOL (for new
  frames).  If FRAME is omitted or nil, use the selected frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-get-lisp-face-attribute (symbol keyword &amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Return an integer distance between COLOR1 and COLOR2 on FRAME.
  COLOR1 and COLOR2 may be either strings containing the color name,
  or lists of the form (RED GREEN BLUE).
  If FRAME is unspecified or nil, the current frame is used.</p>
</td><td class="codes"><pre class="brush: clojure">(defun color-distance (color1 color2 &amp;optional frame))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.macros" name="deuce.emacs.macros"><h1 class="project-name">deuce.emacs.macros</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.macros
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Last kbd macro defined, as a string or vector; nil if none defined.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar last-kbd-macro nil)</pre></td></tr><tr><td class="docs"><p>Non-nil while a keyboard macro is being defined.  Don't set this!
  The value is the symbol `append' while appending to the definition of
  an existing macro.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar defining-kbd-macro nil)</pre></td></tr><tr><td class="docs"><p>Normal hook run whenever a keyboard macro terminates.
  This is run whether the macro ends normally or prematurely due to an error.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar kbd-macro-termination-hook nil)</pre></td></tr><tr><td class="docs"><p>Index in currently executing keyboard macro; undefined if none executing.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar executing-kbd-macro-index nil)</pre></td></tr><tr><td class="docs"><p>Currently executing keyboard macro (string or vector).
  This is nil when not executing a keyboard macro.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar executing-kbd-macro nil)</pre></td></tr><tr><td class="docs"><p>Record subsequent keyboard input, defining a keyboard macro.
  The commands are recorded even as they are executed.
  Use M-x end-kbd-macro to finish recording and make the macro available.
  Use M-x name-last-kbd-macro to give it a permanent name.
  Non-nil arg (prefix arg) means append to last macro defined;
  this begins by re-executing that macro as if you typed it again.
  If optional second arg, NO-EXEC, is non-nil, do not re-execute last
  macro before appending to it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun start-kbd-macro (append &amp;optional no-exec)
  (interactive &quot;P&quot;))</pre></td></tr><tr><td class="docs"><p>Record subsequent keyboard input, defining a keyboard macro.
  The commands are recorded even as they are executed.
  Use M-x end-kbd-macro to finish recording and make the macro available.
  Use M-x name-last-kbd-macro to give it a permanent name.
  Non-nil arg (prefix arg) means append to last macro defined;
  this begins by re-executing that macro as if you typed it again.
  If optional second arg, NO-EXEC, is non-nil, do not re-execute last
  macro before appending to it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun defining-kbd-macro (append &amp;optional no-exec))</pre></td></tr><tr><td class="docs"><p>Execute MACRO as string of editor command characters.
  If MACRO is a symbol, its function definition is used.
  COUNT is a repeat count, or nil for once, or 0 for infinite loop.</p>

<p>  Optional third arg LOOPFUNC may be a function that is called prior to
  each iteration of the macro.  Iteration stops if LOOPFUNC returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun execute-kbd-macro (macro &amp;optional count loopfunc))</pre></td></tr><tr><td class="docs"><p>Finish defining a keyboard macro.
  The definition was started by M-x start-kbd-macro.
  The macro is now available for use via M-x call-last-kbd-macro,
  or it can be given a name with M-x name-last-kbd-macro and then invoked
  under that name.</p>

<p>  With numeric arg, repeat macro now that many times,
  counting the definition just completed as the first repetition.
  An argument of zero means repeat until error.</p>

<p>  In Lisp, optional second arg LOOPFUNC may be a function that is called prior to
  each iteration of the macro.  Iteration stops if LOOPFUNC returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun end-kbd-macro (&amp;optional repeat loopfunc)
  (interactive &quot;p&quot;))</pre></td></tr><tr><td class="docs"><p>Call the last keyboard macro that you defined with M-x start-kbd-macro.</p>

<p>  A prefix argument serves as a repeat count.  Zero means repeat until error.</p>

<p>  To make a macro permanent so you can call it even after
  defining others, use M-x name-last-kbd-macro.</p>

<p>  In Lisp, optional second arg LOOPFUNC may be a function that is called prior to
  each iteration of the macro.  Iteration stops if LOOPFUNC returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun call-last-kbd-macro (&amp;optional prefix loopfunc)
  (interactive &quot;p&quot;))</pre></td></tr><tr><td class="docs"><p>Cancel the events added to a keyboard macro for this command.</p>
</td><td class="codes"><pre class="brush: clojure">(defun cancel-kbd-macro-events ())</pre></td></tr><tr><td class="docs"><p>Store EVENT into the keyboard macro being defined.</p>
</td><td class="codes"><pre class="brush: clojure">(defun store-kbd-macro-event (event))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.dired" name="deuce.emacs.dired"><h1 class="project-name">deuce.emacs.dired</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.dired
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [clojure.java.io :as io]
            [deuce.emacs-lisp.cons :as cons])
  (:import [java.io File])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Completion ignores file names ending in any string in this list.
  It does not ignore them if all possible completions end in one of
  these strings or when displaying a list of completions.
  It ignores directory names if they match any string in this list which
  ends in a slash.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar completion-ignored-extensions nil)</pre></td></tr><tr><td class="docs"><p>Return a list of attributes of file FILENAME.
  Value is nil if specified file cannot be opened.</p>

<p>  ID-FORMAT specifies the preferred format of attributes uid and gid (see
  below) - valid values are 'string and 'integer.  The latter is the
  default, but we plan to change that, so you should specify a non-nil value
  for ID-FORMAT if you use the returned uid or gid.</p>

<p>  Elements of the attribute list are:
   0. t for directory, string (name linked to) for symbolic link, or nil.
   1. Number of links to file.
   2. File uid as a string or a number.  If a string value cannot be
    looked up, a numeric value, either an integer or a float, is returned.
   3. File gid, likewise.
   4. Last access time, as a list of two integers.
    First integer has high-order 16 bits of time, second has low 16 bits.
    (See a note below about access time on FAT-based filesystems.)
   5. Last modification time, likewise.  This is the time of the last
    change to the file's contents.
   6. Last status change time, likewise.  This is the time of last change
    to the file's attributes: owner and group, access mode bits, etc.
   7. Size in bytes.
    This is a floating point number if the size is too large for an integer.
   8. File modes, as a string of ten letters or dashes as in ls -l.
   9. t if file's gid would change if file were deleted and recreated.
  10. inode number.  If it is larger than what an Emacs integer can hold,
    this is of the form (HIGH . LOW): first the high bits, then the low 16 bits.
    If even HIGH is too large for an Emacs integer, this is instead of the form
    (HIGH MIDDLE . LOW): first the high bits, then the middle 24 bits,
    and finally the low 16 bits.
  11. Filesystem device number.  If it is larger than what the Emacs
    integer can hold, this is a cons cell, similar to the inode number.</p>

<p>  On most filesystems, the combination of the inode and the device
  number uniquely identifies the file.</p>

<p>  On MS-Windows, performance depends on `w32-get-true-file-attributes',
  which see.</p>

<p>  On some FAT-based filesystems, only the date of last access is recorded,
  so last access time will always be midnight of that day.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-attributes (filename &amp;optional id-format))</pre></td></tr><tr><td class="docs"><p>Return a list of names of files in DIRECTORY.
  There are three optional arguments:
  If FULL is non-nil, return absolute file names.  Otherwise return names
   that are relative to the specified directory.
  If MATCH is non-nil, mention only file names that match the regexp MATCH.
  If NOSORT is non-nil, the list is not sorted--its order is unpredictable.
   Otherwise, the list returned is sorted with `string-lessp'.
   NOSORT is useful if you plan to sort the result yourself.</p>
</td><td class="codes"><pre class="brush: clojure">(defun directory-files (directory &amp;optional full match nosort)
  (cons/maybe-seq
   ((if nosort identity sort)
    (filter (if match
              #(re-find (re-pattern
                         ((ns-resolve 'deuce.emacs.search
                                      'emacs-regex-to-java) match)) %)
              identity)
            (map (fn [^File f]
                   (if full
                     (.getCanonicalPath f)
                     (.getName f)))
                 (.listFiles (io/file directory)))))))</pre></td></tr><tr><td class="docs"><p>Complete file name FILE in directory DIRECTORY.
  Returns the longest string
  common to all file names in DIRECTORY that start with FILE.
  If there is only one and FILE matches it exactly, returns t.
  Returns nil if DIRECTORY contains no name starting with FILE.</p>

<p>  If PREDICATE is non-nil, call PREDICATE with each possible
  completion (in absolute form) and ignore it if PREDICATE returns nil.</p>

<p>  This function ignores some of the possible completions as
  determined by the variable `completion-ignored-extensions', which see.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-name-completion (file directory &amp;optional predicate))</pre></td></tr><tr><td class="docs"><p>Return a list of all completions of file name FILE in directory DIRECTORY.
  These are all file names in directory DIRECTORY which begin with FILE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-name-all-completions (file directory))</pre></td></tr><tr><td class="docs"><p>Return t if first arg file attributes list is less than second.
  Comparison is in lexicographic order and case is significant.</p>
</td><td class="codes"><pre class="brush: clojure">(defun file-attributes-lessp (f1 f2))</pre></td></tr><tr><td class="docs"><p>Return a list of names of files and their attributes in DIRECTORY.
  There are four optional arguments:
  If FULL is non-nil, return absolute file names.  Otherwise return names
   that are relative to the specified directory.
  If MATCH is non-nil, mention only file names that match the regexp MATCH.
  If NOSORT is non-nil, the list is not sorted--its order is unpredictable.
   NOSORT is useful if you plan to sort the result yourself.
  ID-FORMAT specifies the preferred format of attributes uid and gid, see
  `file-attributes' for further documentation.
  On MS-Windows, performance depends on `w32-get-true-file-attributes',
  which see.</p>
</td><td class="codes"><pre class="brush: clojure">(defun directory-files-and-attributes (directory &amp;optional full match nosort id-format))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.undo" name="deuce.emacs.undo"><h1 class="project-name">deuce.emacs.undo</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.undo
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Don't keep more than this much size of undo information.
  This limit is applied when garbage collection happens.
  When a previous command increases the total undo list size past this
  value, that command and the earlier commands that came before it are forgotten.
  However, the most recent buffer-modifying command's undo info
  is never discarded for this reason.</p>

<p>  The size is counted as the number of bytes occupied,
  which includes both saved text and other data.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar undo-strong-limit nil)</pre></td></tr><tr><td class="docs"><p>Keep no more undo information once it exceeds this size.
  This limit is applied when garbage collection happens.
  When a previous command increases the total undo list size past this
  value, the earlier commands that came before it are forgotten.</p>

<p>  The size is counted as the number of bytes occupied,
  which includes both saved text and other data.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar undo-limit nil)</pre></td></tr><tr><td class="docs"><p>Outer limit on size of undo information for one command.
  At garbage collection time, if the current command has produced
  more than this much undo information, it discards the info and displays
  a warning.  This is a last-ditch limit to prevent memory overflow.</p>

<p>  The size is counted as the number of bytes occupied, which includes
  both saved text and other data.  A value of nil means no limit.  In
  this case, accumulating one huge undo entry could make Emacs crash as
  a result of memory overflow.</p>

<p>  In fact, this calls the function which is the value of
  `undo-outer-limit-function' with one argument, the size.
  The text above describes the behavior of the function
  that variable usually specifies.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar undo-outer-limit nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means do not record <code>point' in</code>buffer-undo-list'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar undo-inhibit-record-point nil)</pre></td></tr><tr><td class="docs"><p>Function to call when an undo list exceeds `undo-outer-limit'.
  This function is called with one argument, the current undo list size
  for the most recent command (since the last undo boundary).
  If the function returns t, that means truncation has been fully handled.
  If it returns nil, the other forms of truncation are done.</p>

<p>  Garbage collection is inhibited around the call to this function,
  so it must make sure not to do a lot of consing.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar undo-outer-limit-function nil)</pre></td></tr><tr><td class="docs"><p>Mark a boundary between units of undo.
  An undo command will stop at this point,
  but another undo command will undo to the previous boundary.</p>
</td><td class="codes"><pre class="brush: clojure">(defun undo-boundary ())</pre></td></tr><tr><td class="docs"><p>Undo N records from the front of the list LIST.
  Return what remains of the list.</p>
</td><td class="codes"><pre class="brush: clojure">(defun primitive-undo (n list))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.charset" name="deuce.emacs.charset"><h1 class="project-name">deuce.emacs.charset</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.charset
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.fns :as fns]
            [deuce.emacs-lisp.globals :as globals])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Inhibit loading of charset maps.  Used when dumping Emacs.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-load-charset-map nil)</pre></td></tr><tr><td class="docs"><p>ISO639 language mnemonic symbol for the current language environment.
  If the current language environment is for multiple languages (e.g. "Latin-1"),
  the value may be a list of mnemonics.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar current-iso639-language nil)</pre></td></tr><tr><td class="docs"><p>List of all charsets ever defined.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar charset-list (alloc/list))</pre></td></tr><tr><td class="docs"><p>*List of directories to search for charset map files.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar charset-map-path nil)</pre></td></tr><tr><td class="docs"><p>Sort charset list CHARSETS by a priority of each charset.
  Return the sorted list.  CHARSETS is modified by side effects.
  See also <code>charset-priority-list' and</code>set-charset-priority'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun sort-charsets (charsets))</pre></td></tr><tr><td class="docs"><p>Return the property list of CHARSET.</p>
</td><td class="codes"><pre class="brush: clojure">(defun charset-plist (charset))</pre></td></tr><tr><td class="docs"><p>Set CHARSET's property list to PLIST.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-charset-plist (charset plist))</pre></td></tr><tr><td class="docs"><p>Return charset of a character in the current buffer at position POS.
  If POS is nil, it defaults to the current point.
  If POS is out of range, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun charset-after (&amp;optional pos))</pre></td></tr><tr><td class="docs"><p>For internal use only.</p>
</td><td class="codes"><pre class="brush: clojure">(defun define-charset-internal (&amp;rest args))</pre></td></tr><tr><td class="docs"><p>Define ALIAS as an alias for charset CHARSET.</p>
</td><td class="codes"><pre class="brush: clojure">(defun define-charset-alias (alias charset))</pre></td></tr><tr><td class="docs"><p>Return non-nil if and only if OBJECT is a charset.</p>
</td><td class="codes"><pre class="brush: clojure">(defun charsetp (object))</pre></td></tr><tr><td class="docs"><p>Encode the character CH into a code-point of CHARSET.
  Return nil if CHARSET doesn't include CH.</p>

<p>  Optional argument RESTRICTION specifies a way to map CH to a
  code-point in CCS.  Currently not supported and just ignored.</p>
</td><td class="codes"><pre class="brush: clojure">(defun encode-char (ch charset &amp;optional restriction))</pre></td></tr><tr><td class="docs"><p>Internal use only.
  Return charset identification number of CHARSET.</p>
</td><td class="codes"><pre class="brush: clojure">(defun charset-id-internal (&amp;optional charset))</pre></td></tr><tr><td class="docs"><p>Return list of charset and one to four position-codes of CH.
  The charset is decided by the current priority order of charsets.
  A position-code is a byte value of each dimension of the code-point of
  CH in the charset.</p>
</td><td class="codes"><pre class="brush: clojure">(defun split-char (ch))</pre></td></tr><tr><td class="docs"><p>Return a list of charsets in the region between BEG and END.
  BEG and END are buffer positions.
  Optional arg TABLE if non-nil is a translation table to look up.</p>

<p>  If the current buffer is unibyte, the returned list may contain
  only <code>ascii',</code>eight-bit-control', and `eight-bit-graphic'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun find-charset-region (beg end &amp;optional table))</pre></td></tr><tr><td class="docs"><p>Unify characters of CHARSET with Unicode.
  This means reading the relevant file and installing the table defined
  by CHARSET's `:unify-map' property.</p>

<p>  Optional second arg UNIFY-MAP is a file name string or a vector.  It has
  the same meaning as the `:unify-map' attribute in the function
  `define-charset' (which see).</p>

<p>  Optional third argument DEUNIFY, if non-nil, means to de-unify CHARSET.</p>
</td><td class="codes"><pre class="brush: clojure">(defun unify-charset (charset &amp;optional unify-map deunify)
  nil)</pre></td></tr><tr><td class="docs"><p>Return a list of charsets in STR.
  Optional arg TABLE if non-nil is a translation table to look up.</p>

<p>  If STR is unibyte, the returned list may contain
  only <code>ascii',</code>eight-bit-control', and `eight-bit-graphic'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun find-charset-string (str &amp;optional table))</pre></td></tr><tr><td class="docs"><p>Assign higher priority to the charsets given as arguments.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-charset-priority (&amp;rest charsets))</pre></td></tr><tr><td class="docs"><p>Declare an equivalent charset for ISO-2022 decoding.</p>

<p>  On decoding by an ISO-2022 base coding system, when a charset
  specified by DIMENSION, CHARS, and FINAL-CHAR is designated, behave as
  if CHARSET is designated instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun declare-equiv-charset (dimension chars final-char charset))</pre></td></tr><tr><td class="docs"><p>Internal use only.
  Clear temporary charset mapping tables.
  It should be called only from temacs invoked for dumping.</p>
</td><td class="codes"><pre class="brush: clojure">(defun clear-charset-maps ())</pre></td></tr><tr><td class="docs"><p>Return an unused ISO final char for a charset of DIMENSION and CHARS.
  DIMENSION is the number of bytes to represent a character: 1 or 2.
  CHARS is the number of characters in a dimension: 94 or 96.</p>

<p>  This final char is for private use, thus the range is <code>0' (48) ..</code>?' (63).
  If there's no unused final char for the specified kind of charset,
  return nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-unused-iso-final-char (dimension chars))</pre></td></tr><tr><td class="docs"><p>Return the list of charsets ordered by priority.
  HIGHESTP non-nil means just return the highest priority one.</p>
</td><td class="codes"><pre class="brush: clojure">(defun charset-priority-list (&amp;optional highestp))</pre></td></tr><tr><td class="docs"><p>Call FUNCTION for all characters in CHARSET.
  FUNCTION is called with an argument RANGE and the optional 3rd
  argument ARG.</p>

<p>  RANGE is a cons (FROM .  TO), where FROM and TO indicate a range of
  characters contained in CHARSET.</p>

<p>  The optional 4th and 5th arguments FROM-CODE and TO-CODE specify the
  range of code points (in CHARSET) of target characters.</p>
</td><td class="codes"><pre class="brush: clojure">(defun map-charset-chars (function charset &amp;optional arg from-code to-code))</pre></td></tr><tr><td class="docs"><p>Return a character of CHARSET whose position codes are CODEn.</p>

<p>  CODE1 through CODE4 are optional, but if you don't supply sufficient
  position codes, it is assumed that the minimum code in each dimension
  is specified.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-char (charset &amp;optional code1 code2 code3 code4))</pre></td></tr><tr><td class="docs"><p>Return the charset of highest priority that contains CH.
  If optional 2nd arg RESTRICTION is non-nil, it is a list of charsets
  from which to find the charset.  It may also be a coding system.  In
  that case, find the charset from what supported by that coding system.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-charset (ch &amp;optional restriction))</pre></td></tr><tr><td class="docs"><p>Decode the pair of CHARSET and CODE-POINT into a character.
  Return nil if CODE-POINT is not valid in CHARSET.</p>

<p>  CODE-POINT may be a cons (HIGHER-16-BIT-VALUE . LOWER-16-BIT-VALUE).</p>

<p>  Optional argument RESTRICTION specifies a way to map the pair of CCS
  and CODE-POINT to a character.  Currently not supported and just ignored.</p>
</td><td class="codes"><pre class="brush: clojure">(defun decode-char (charset code-point &amp;optional restriction))</pre></td></tr><tr><td class="docs"><p>Return charset of ISO's specification DIMENSION, CHARS, and FINAL-CHAR.</p>

<p>  ISO 2022's designation sequence (escape sequence) distinguishes charsets
  by their DIMENSION, CHARS, and FINAL-CHAR,
  whereas Emacs distinguishes them by charset symbol.
  See the documentation of the function `charset-info' for the meanings of
  DIMENSION, CHARS, and FINAL-CHAR.</p>
</td><td class="codes"><pre class="brush: clojure">(defun iso-charset (dimension chars final-char))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.process" name="deuce.emacs.process"><h1 class="project-name">deuce.emacs.process</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.process
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [clojure.java.shell :as sh])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>*Non-nil means delete processes immediately when they exit.
  A value of nil means don't delete them until `list-processes' is run.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar delete-exited-processes nil)</pre></td></tr><tr><td class="docs"><p>Control type of device used to communicate with subprocesses.
  Values are nil to use a pipe, or t or `pty' to use a pty.
  The value has no effect if the system has no ptys or if all ptys are busy:
  then a pipe is used in any case.
  The value takes effect when `start-process' is called.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar process-connection-type nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, improve receive buffering by delaying after short reads.
  On some systems, when Emacs reads the output from a subprocess, the output data
  is read in very small blocks, potentially resulting in very poor performance.
  This behavior can be remedied to some extent by setting this variable to a
  non-nil value, as it will automatically delay reading from such processes, to
  allow them to produce more output before Emacs tries to read it.
  If the value is t, the delay is reset after each write to the process; any other
  non-nil value means that the delay is not reset on write.
  The variable takes effect when `start-process' is called.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar process-adaptive-read-buffering nil)</pre></td></tr><tr><td class="docs"><p>Delete PROCESS: kill it and forget about it immediately.
  PROCESS may be a process, a buffer, the name of a process or buffer, or
  nil, indicating the current buffer's process.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-process (process))</pre></td></tr><tr><td class="docs"><p>Send PROCESS the signal with code SIGCODE.
  PROCESS may also be a number specifying the process id of the
  process to signal; in this case, the process need not be a child of
  this Emacs.
  SIGCODE may be an integer, or a symbol whose name is a signal name.</p>
</td><td class="codes"><pre class="brush: clojure">(defun signal-process (process sigcode)
  (interactive &quot;sProcess (name or number): \nnSignal code: &quot;))</pre></td></tr><tr><td class="docs"><p>Give PROCESS the sentinel SENTINEL; nil for none.
  The sentinel is called as a function when the process changes state.
  It gets two arguments: the process, and a string describing the change.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-process-sentinel (process sentinel))</pre></td></tr><tr><td class="docs"><p>Continue process PROCESS.  May be process or name of one.
  See function `interrupt-process' for more details on usage.
  If PROCESS is a network or serial process, resume handling of incoming
  traffic.</p>
</td><td class="codes"><pre class="brush: clojure">(defun continue-process (&amp;optional process current-group))</pre></td></tr><tr><td class="docs"><p>Return the exit status of PROCESS or the signal number that killed it.
  If PROCESS has not yet exited or died, return 0.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-exit-status (process))</pre></td></tr><tr><td class="docs"><p>Tell PROCESS that it has logical window size HEIGHT and WIDTH.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-process-window-size (process height width))</pre></td></tr><tr><td class="docs"><p>Return attributes of the process given by its PID, a number.</p>

<p>  Value is an alist where each element is a cons cell of the form</p>

<pre><code>  (KEY . VALUE)
</code></pre>

<p>  If this functionality is unsupported, the value is nil.</p>

<p>  See `list-system-processes' for getting a list of all process IDs.</p>

<p>  The KEYs of the attributes that this function may return are listed
  below, together with the type of the associated VALUE (in parentheses).
  Not all platforms support all of these attributes; unsupported
  attributes will not appear in the returned alist.
  Unless explicitly indicated otherwise, numbers can have either
  integer or floating point values.</p>

<p>   euid    -- Effective user User ID of the process (number)
   user    -- User name corresponding to euid (string)
   egid    -- Effective user Group ID of the process (number)
   group   -- Group name corresponding to egid (string)
   comm    -- Command name (executable name only) (string)
   state   -- Process state code, such as "S", "R", or "T" (string)
   ppid    -- Parent process ID (number)
   pgrp    -- Process group ID (number)
   sess    -- Session ID, i.e. process ID of session leader (number)
   ttname  -- Controlling tty name (string)
   tpgid   -- ID of foreground process group on the process's tty (number)
   minflt  -- number of minor page faults (number)
   majflt  -- number of major page faults (number)
   cminflt -- cumulative number of minor page faults (number)
   cmajflt -- cumulative number of major page faults (number)
   utime   -- user time used by the process, in the (HIGH LOW USEC) format
   stime   -- system time used by the process, in the (HIGH LOW USEC) format
   time    -- sum of utime and stime, in the (HIGH LOW USEC) format
   cutime  -- user time used by the process and its children, (HIGH LOW USEC)
   cstime  -- system time used by the process and its children, (HIGH LOW USEC)
   ctime   -- sum of cutime and cstime, in the (HIGH LOW USEC) format
   pri     -- priority of the process (number)
   nice    -- nice value of the process (number)
   thcount -- process thread count (number)
   start   -- time the process started, in the (HIGH LOW USEC) format
   vsize   -- virtual memory size of the process in KB's (number)
   rss     -- resident set size of the process in KB's (number)
   etime   -- elapsed time the process is running, in (HIGH LOW USEC) format
   pcpu    -- percents of CPU time used by the process (floating-point number)
   pmem    -- percents of total physical memory used by process's resident set
                (floating-point number)
   args    -- command line which invoked the process (string).</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-attributes (pid))</pre></td></tr><tr><td class="docs"><p>Create and return a network server or client process.</p>

<p>  In Emacs, network connections are represented by process objects, so
  input and output work as for subprocesses and `delete-process' closes
  a network connection.  However, a network process has no process id,
  it cannot be signaled, and the status codes are different from normal
  processes.</p>

<p>  Arguments are specified as keyword/argument pairs.  The following
  arguments are defined:</p>

<p>  :name NAME -- NAME is name for process.  It is modified if necessary
  to make it unique.</p>

<p>  :buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate
  with the process.  Process output goes at end of that buffer, unless
  you specify an output stream or filter function to handle the output.
  BUFFER may be also nil, meaning that this process is not associated
  with any buffer.</p>

<p>  :host HOST -- HOST is name of the host to connect to, or its IP
  address.  The symbol `local' specifies the local host.  If specified
  for a server process, it must be a valid name or address for the local
  host, and only clients connecting to that address will be accepted.</p>

<p>  :service SERVICE -- SERVICE is name of the service desired, or an
  integer specifying a port number to connect to.  If SERVICE is t,
  a random port number is selected for the server.  (If Emacs was
  compiled with getaddrinfo, a port number can also be specified as a
  string, e.g. "80", as well as an integer.  This is not portable.)</p>

<p>  :type TYPE -- TYPE is the type of connection.  The default (nil) is a
  stream type connection, `datagram' creates a datagram type connection,
  `seqpacket' creates a reliable datagram connection.</p>

<p>  :family FAMILY -- FAMILY is the address (and protocol) family for the
  service specified by HOST and SERVICE.  The default (nil) is to use
  whatever address family (IPv4 or IPv6) that is defined for the host
  and port number specified by HOST and SERVICE.  Other address families
  supported are:
    local -- for a local (i.e. UNIX) address specified by SERVICE.
    ipv4  -- use IPv4 address family only.
    ipv6  -- use IPv6 address family only.</p>

<p>  :local ADDRESS -- ADDRESS is the local address used for the connection.
  This parameter is ignored when opening a client process. When specified
  for a server process, the FAMILY, HOST and SERVICE args are ignored.</p>

<p>  :remote ADDRESS -- ADDRESS is the remote partner's address for the
  connection.  This parameter is ignored when opening a stream server
  process.  For a datagram server process, it specifies the initial
  setting of the remote datagram address.  When specified for a client
  process, the FAMILY, HOST, and SERVICE args are ignored.</p>

<p>  The format of ADDRESS depends on the address family:
  - An IPv4 address is represented as an vector of integers [A B C D P]
  corresponding to numeric IP address A.B.C.D and port number P.
  - A local address is represented as a string with the address in the
  local address space.
  - An "unsupported family" address is represented by a cons (F . AV)
  where F is the family number and AV is a vector containing the socket
  address data with one element per address data byte.  Do not rely on
  this format in portable code, as it may depend on implementation
  defined constants, data sizes, and data structure alignment.</p>

<p>  :coding CODING -- If CODING is a symbol, it specifies the coding
  system used for both reading and writing for this process.  If CODING
  is a cons (DECODING . ENCODING), DECODING is used for reading, and
  ENCODING is used for writing.</p>

<p>  :nowait BOOL -- If BOOL is non-nil for a stream type client process,
  return without waiting for the connection to complete; instead, the
  sentinel function will be called with second arg matching "open" (if
  successful) or "failed" when the connect completes.  Default is to use
  a blocking connect (i.e. wait) for stream type connections.</p>

<p>  :noquery BOOL -- Query the user unless BOOL is non-nil, and process is
  running when Emacs is exited.</p>

<p>  :stop BOOL -- Start process in the `stopped' state if BOOL non-nil.
  In the stopped state, a server process does not accept new
  connections, and a client process does not handle incoming traffic.
  The stopped state is cleared by `continue-process' and set by
  `stop-process'.</p>

<p>  :filter FILTER -- Install FILTER as the process filter.</p>

<p>  :filter-multibyte BOOL -- If BOOL is non-nil, strings given to the
  process filter are multibyte, otherwise they are unibyte.
  If this keyword is not specified, the strings are multibyte if
  the default value of `enable-multibyte-characters' is non-nil.</p>

<p>  :sentinel SENTINEL -- Install SENTINEL as the process sentinel.</p>

<p>  :log LOG -- Install LOG as the server process log function.  This
  function is called when the server accepts a network connection from a
  client.  The arguments are SERVER, CLIENT, and MESSAGE, where SERVER
  is the server process, CLIENT is the new process for the connection,
  and MESSAGE is a string.</p>

<p>  :plist PLIST -- Install PLIST as the new process' initial plist.</p>

<p>  :server QLEN -- if QLEN is non-nil, create a server process for the
  specified FAMILY, SERVICE, and connection type (stream or datagram).
  If QLEN is an integer, it is used as the max. length of the server's
  pending connection queue (also known as the backlog); the default
  queue length is 5.  Default is to create a client process.</p>

<p>  The following network options can be specified for this connection:</p>

<p>  :broadcast BOOL    -- Allow send and receive of datagram broadcasts.
  :dontroute BOOL    -- Only send to directly connected hosts.
  :keepalive BOOL    -- Send keep-alive messages on network stream.
  :linger BOOL or TIMEOUT -- Send queued messages before closing.
  :oobinline BOOL    -- Place out-of-band data in receive data stream.
  :priority INT      -- Set protocol defined priority for sent packets.
  :reuseaddr BOOL    -- Allow reusing a recently used local address
                        (this is allowed by default for a server process).
  :bindtodevice NAME -- bind to interface NAME.  Using this may require
                        special privileges on some systems.</p>

<p>  Consult the relevant system programmer's manual pages for more
  information on using these options.</p>

<p>  A server process will listen for and accept connections from clients.
  When a client connection is accepted, a new network process is created
  for the connection with the following parameters:</p>

<ul>
<li>The client's process name is constructed by concatenating the server
process' NAME and a client identification string.</li>
<li>If the FILTER argument is non-nil, the client process will not get a
separate process buffer; otherwise, the client's process buffer is a newly
created buffer named after the server process' BUFFER name or process
NAME concatenated with the client identification string.</li>
<li>The connection type and the process filter and sentinel parameters are
inherited from the server process' TYPE, FILTER and SENTINEL.</li>
<li>The client process' contact info is set according to the client's
addressing information (typically an IP address and a port number).</li>
<li><p>The client process' plist is initialized from the server's plist.</p>

<p>Notice that the FILTER and SENTINEL args are never used directly by
the server process.  Also, the BUFFER argument is not used directly by
the server process, but via the optional :log function, accepted (and
failed) connections may be logged in the server process' buffer.</p>

<p>The original argument list, modified with the actual connection
information, is available via the `process-contact' function.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defun make-network-process (&amp;rest args))</pre></td></tr><tr><td class="docs"><p>Specify if query is needed for PROCESS when Emacs is exited.
  If the second argument FLAG is non-nil, Emacs will query the user before
  exiting or killing a buffer if PROCESS is running.  This function
  returns FLAG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-process-query-on-exit-flag (process flag))</pre></td></tr><tr><td class="docs"><p>Send QUIT signal to process PROCESS.  May be process or name of one.
  See function `interrupt-process' for more details on usage.</p>
</td><td class="codes"><pre class="brush: clojure">(defun quit-process (&amp;optional process current-group))</pre></td></tr><tr><td class="docs"><p>Return the name of the terminal PROCESS uses, or nil if none.
  This is the terminal that the process itself reads and writes on,
  not the name of the pty that Emacs uses to talk with that terminal.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-tty-name (process))</pre></td></tr><tr><td class="docs"><p>Stop process PROCESS.  May be process or name of one.
  See function `interrupt-process' for more details on usage.
  If PROCESS is a network or serial process, inhibit handling of incoming
  traffic.</p>
</td><td class="codes"><pre class="brush: clojure">(defun stop-process (&amp;optional process current-group))</pre></td></tr><tr><td class="docs"><p>Send PROCESS the contents of STRING as input.
  PROCESS may be a process, a buffer, the name of a process or buffer, or
  nil, indicating the current buffer's process.
  If STRING is more than 500 characters long,
  it is sent in several bunches.  This may happen even for shorter strings.
  Output from processes can arrive in between bunches.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-send-string (process string))</pre></td></tr><tr><td class="docs"><p>Convert network ADDRESS from internal format to a string.
  A 4 or 5 element vector represents an IPv4 address (with port number).
  An 8 or 9 element vector represents an IPv6 address (with port number).
  If optional second argument OMIT-PORT is non-nil, don't include a port
  number in the string, even when present in ADDRESS.
  Returns nil if format of ADDRESS is invalid.</p>
</td><td class="codes"><pre class="brush: clojure">(defun format-network-address (address &amp;optional omit-port))</pre></td></tr><tr><td class="docs"><p>Return information about network interface named IFNAME.
  The return value is a list (ADDR BCAST NETMASK HWADDR FLAGS),
  where ADDR is the layer 3 address, BCAST is the layer 3 broadcast address,
  NETMASK is the layer 3 network mask, HWADDR is the layer 2 address, and
  FLAGS is the current flags of the interface.</p>
</td><td class="codes"><pre class="brush: clojure">(defun network-interface-info (ifname))</pre></td></tr><tr><td class="docs"><p>Returns the filter function of PROCESS; nil if none.
  See `set-process-filter' for more info on filter functions.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-filter (process))</pre></td></tr><tr><td class="docs"><p>Return the value of inherit-coding-system flag for PROCESS.
  If this flag is t, `buffer-file-coding-system' of the buffer
  associated with PROCESS will inherit the coding system used to decode
  the process output.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-inherit-coding-system-flag (process))</pre></td></tr><tr><td class="docs"><p>This function is obsolete since 23.1.</p>

<p>  Return t if a multibyte string is given to PROCESS's filter.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-filter-multibyte-p (process))</pre></td></tr><tr><td class="docs"><p>Return a cons of coding systems for decoding and encoding of PROCESS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-coding-system (process))</pre></td></tr><tr><td class="docs"><p>Return the name of PROCESS, as a string.
  This is the name of the program invoked in PROCESS,
  possibly modified to make it unique among process names.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-name (process))</pre></td></tr><tr><td class="docs"><p>Set buffer associated with PROCESS to BUFFER (a buffer, or nil).
  Return BUFFER.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-process-buffer (process buffer))</pre></td></tr><tr><td class="docs"><p>Returns non-nil if Emacs is waiting for input from the user.
  This is intended for use by asynchronous process output filters and sentinels.</p>
</td><td class="codes"><pre class="brush: clojure">(defun waiting-for-user-input-p ())</pre></td></tr><tr><td class="docs"><p>Return the contact info of PROCESS; t for a real child.
  For a network or serial connection, the value depends on the optional
  KEY arg.  If KEY is nil, value is a cons cell of the form (HOST
  SERVICE) for a network connection or (PORT SPEED) for a serial
  connection.  If KEY is t, the complete contact information for the
  connection is returned, else the specific value for the keyword KEY is
  returned.  See <code>make-network-process' or</code>make-serial-process' for a
  list of keywords.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-contact (process &amp;optional key))</pre></td></tr><tr><td class="docs"><p>Return the sentinel of PROCESS; nil if none.
  See `set-process-sentinel' for more info on sentinels.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-sentinel (process))</pre></td></tr><tr><td class="docs"><p>Send current contents of region as input to PROCESS.
  PROCESS may be a process, a buffer, the name of a process or buffer, or
  nil, indicating the current buffer's process.
  Called from program, takes three arguments, PROCESS, START and END.
  If the region is more than 500 characters long,
  it is sent in several bunches.  This may happen even for shorter regions.
  Output from processes can arrive in between bunches.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-send-region (process start end))</pre></td></tr><tr><td class="docs"><p>Get the current datagram address associated with PROCESS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-datagram-address (process))</pre></td></tr><tr><td class="docs"><p>Return the status of PROCESS.
  The returned value is one of the following symbols:
  run  -- for a process that is running.
  stop -- for a process stopped but continuable.
  exit -- for a process that has exited.
  signal -- for a process that has got a fatal signal.
  open -- for a network stream connection that is open.
  listen -- for a network stream server that is listening.
  closed -- for a network stream connection that is closed.
  connect -- when waiting for a non-blocking connection to complete.
  failed -- when a non-blocking connection has failed.
  nil -- if arg is a process name and no such process exists.
  PROCESS may be a process, a buffer, the name of a process, or
  nil, indicating the current buffer's process.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-status (process))</pre></td></tr><tr><td class="docs"><p>For network process PROCESS set option OPTION to value VALUE.
  See `make-network-process' for a list of options and values.
  If optional fourth arg NO-ERROR is non-nil, don't signal an error if
  OPTION is not a supported option, return nil instead; otherwise return t.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-network-process-option (process option value &amp;optional no-error))</pre></td></tr><tr><td class="docs"><p>Return t if PROCESS has given the terminal to a child.
  If the operating system does not make it possible to find out,
  return t unconditionally.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-running-child-p (&amp;optional process))</pre></td></tr><tr><td class="docs"><p>Return the buffer PROCESS is associated with.
  Output from PROCESS is inserted in this buffer unless PROCESS has a filter.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-buffer (process))</pre></td></tr><tr><td class="docs"><p>Return the process named NAME, or nil if there is none.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-process (name))</pre></td></tr><tr><td class="docs"><p>Give PROCESS the filter function FILTER; nil means no filter.
  A value of t means stop accepting output from the process.</p>

<p>  When a process has a filter, its buffer is not used for output.
  Instead, each time it does output, the entire string of output is
  passed to the filter.</p>

<p>  The filter gets two arguments: the process and the string of output.
  The string argument is normally a multibyte string, except:
  - if the process' input coding system is no-conversion or raw-text,
    it is a unibyte string (the non-converted input), or else
  - if `default-enable-multibyte-characters' is nil, it is a unibyte
    string (the result of converting the decoded input multibyte
    string to unibyte with `string-make-unibyte').</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-process-filter (process filter))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a process.</p>
</td><td class="codes"><pre class="brush: clojure">(defun processp (object))</pre></td></tr><tr><td class="docs"><p>Return a list of numerical process IDs of all running processes.
  If this functionality is unsupported, return nil.</p>

<p>  See `process-attributes' for getting attributes of a process given its ID.</p>
</td><td class="codes"><pre class="brush: clojure">(defun list-system-processes ())</pre></td></tr><tr><td class="docs"><p>Determine whether buffer of PROCESS will inherit coding-system.
  If the second argument FLAG is non-nil, then the variable
  `buffer-file-coding-system' of the buffer associated with PROCESS
  will be bound to the value of the coding system used to decode
  the process output.</p>

<p>  This is useful when the coding system specified for the process buffer
  leaves either the character code conversion or the end-of-line conversion
  unspecified, or if the coding system used to decode the process output
  is more appropriate for saving the process buffer.</p>

<p>  Binding the variable `inherit-process-coding-system' to non-nil before
  starting the process is an alternative way of setting the inherit flag
  for the process which will run.</p>

<p>  This function returns FLAG.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-process-inherit-coding-system-flag (process flag))</pre></td></tr><tr><td class="docs"><p>Return a list of all processes.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-list ())</pre></td></tr><tr><td class="docs"><p>Return an alist of all network interfaces and their network address.
  Each element is a cons, the car of which is a string containing the
  interface name, and the cdr is the network address in internal
  format; see the description of ADDRESS in `make-network-process'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun network-interface-list ())</pre></td></tr><tr><td class="docs"><p>Return the plist of PROCESS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-plist (process))</pre></td></tr><tr><td class="docs"><p>Return the connection type of PROCESS.
  The value is either the symbol <code>real',</code>network', or `serial'.
  PROCESS may be a process, a buffer, the name of a process or buffer, or
  nil, indicating the current buffer's process.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-type (process))</pre></td></tr><tr><td class="docs"><p>Return the marker for the end of the last output from PROCESS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-mark (process))</pre></td></tr><tr><td class="docs"><p>Return the command that was executed to start PROCESS.
  This is a list of strings, the first string being the program executed
  and the rest of the strings being the arguments given to it.
  For a network or serial process, this is nil (process is running) or t
  (process is stopped).</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-command (process))</pre></td></tr><tr><td class="docs"><p>Kill process PROCESS.  May be process or name of one.
  See function `interrupt-process' for more details on usage.</p>
</td><td class="codes"><pre class="brush: clojure">(defun kill-process (&amp;optional process current-group))</pre></td></tr><tr><td class="docs"><p>Set coding systems of PROCESS to DECODING and ENCODING.
  DECODING will be used to decode subprocess output and ENCODING to
  encode subprocess input.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-process-coding-system (process &amp;optional decoding encoding))</pre></td></tr><tr><td class="docs"><p>Create and return a serial port process.</p>

<p>  In Emacs, serial port connections are represented by process objects,
  so input and output work as for subprocesses, and `delete-process'
  closes a serial port connection.  However, a serial process has no
  process id, it cannot be signaled, and the status codes are different
  from normal processes.</p>

<p>  `make-serial-process' creates a process and a buffer, on which you
  probably want to use `process-send-string'.  Try M-x serial-term for
  an interactive terminal.  See below for examples.</p>

<p>  Arguments are specified as keyword/argument pairs.  The following
  arguments are defined:</p>

<p>  :port PORT -- (mandatory) PORT is the path or name of the serial port.
  For example, this could be "/dev/ttyS0" on Unix.  On Windows, this
  could be "COM1", or "\.\COM10" for ports higher than COM9 (double
  the backslashes in strings).</p>

<p>  :speed SPEED -- (mandatory) is handled by `serial-process-configure',
  which this function calls.</p>

<p>  :name NAME -- NAME is the name of the process.  If NAME is not given,
  the value of PORT is used.</p>

<p>  :buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate
  with the process.  Process output goes at the end of that buffer,
  unless you specify an output stream or filter function to handle the
  output.  If BUFFER is not given, the value of NAME is used.</p>

<p>  :coding CODING -- If CODING is a symbol, it specifies the coding
  system used for both reading and writing for this process.  If CODING
  is a cons (DECODING . ENCODING), DECODING is used for reading, and
  ENCODING is used for writing.</p>

<p>  :noquery BOOL -- When exiting Emacs, query the user if BOOL is nil and
  the process is running.  If BOOL is not given, query before exiting.</p>

<p>  :stop BOOL -- Start process in the `stopped' state if BOOL is non-nil.
  In the stopped state, a serial process does not accept incoming data,
  but you can send outgoing data.  The stopped state is cleared by
  <code>continue-process' and set by</code>stop-process'.</p>

<p>  :filter FILTER -- Install FILTER as the process filter.</p>

<p>  :sentinel SENTINEL -- Install SENTINEL as the process sentinel.</p>

<p>  :plist PLIST -- Install PLIST as the initial plist of the process.</p>

<p>  :bytesize
  :parity
  :stopbits
  :flowcontrol
  -- This function calls `serial-process-configure' to handle these
  arguments.</p>

<p>  The original argument list, possibly modified by later configuration,
  is available via the function `process-contact'.</p>

<p>  Examples:</p>

<p>  (make-serial-process :port "/dev/ttyS0" :speed 9600)</p>

<p>  (make-serial-process :port "COM1" :speed 115200 :stopbits 2)</p>

<p>  (make-serial-process :port "\.\COM13" :speed 1200 :bytesize 7 :parity 'odd)</p>

<p>  (make-serial-process :port "/dev/tty.BlueConsole-SPP-1" :speed nil)</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-serial-process (&amp;rest args)
  &quot;Create and return a serial port process.
  In Emacs, serial port connections are represented by process objects,
  so input and output work as for subprocesses, and `delete-process'
  closes a serial port connection.  However, a serial process has no
  process id, it cannot be signaled, and the status codes are different
  from normal processes.
  `make-serial-process' creates a process and a buffer, on which you
  probably want to use `process-send-string'.  Try M-x serial-term for
  an interactive terminal.  See below for examples.
  Arguments are specified as keyword/argument pairs.  The following
  arguments are defined:
  :port PORT -- (mandatory) PORT is the path or name of the serial port.
  For example, this could be \&quot;/dev/ttyS0\&quot; on Unix.  On Windows, this
  could be \&quot;COM1\&quot;, or \&quot;\\\\.\\COM10\&quot; for ports higher than COM9 (double
  the backslashes in strings).
  :speed SPEED -- (mandatory) is handled by `serial-process-configure',
  which this function calls.
  :name NAME -- NAME is the name of the process.  If NAME is not given,
  the value of PORT is used.
  :buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate
  with the process.  Process output goes at the end of that buffer,
  unless you specify an output stream or filter function to handle the
  output.  If BUFFER is not given, the value of NAME is used.
  :coding CODING -- If CODING is a symbol, it specifies the coding
  system used for both reading and writing for this process.  If CODING
  is a cons (DECODING . ENCODING), DECODING is used for reading, and
  ENCODING is used for writing.
  :noquery BOOL -- When exiting Emacs, query the user if BOOL is nil and
  the process is running.  If BOOL is not given, query before exiting.
  :stop BOOL -- Start process in the `stopped' state if BOOL is non-nil.
  In the stopped state, a serial process does not accept incoming data,
  but you can send outgoing data.  The stopped state is cleared by
  `continue-process' and set by `stop-process'.
  :filter FILTER -- Install FILTER as the process filter.
  :sentinel SENTINEL -- Install SENTINEL as the process sentinel.
  :plist PLIST -- Install PLIST as the initial plist of the process.
  :bytesize
  :parity
  :stopbits
  :flowcontrol
  -- This function calls `serial-process-configure' to handle these
  arguments.
  The original argument list, possibly modified by later configuration,
  is available via the function `process-contact'.
  Examples:
  (make-serial-process :port \&quot;/dev/ttyS0\&quot; :speed 9600)
  (make-serial-process :port \&quot;COM1\&quot; :speed 115200 :stopbits 2)
  (make-serial-process :port \&quot;\\\\.\\COM13\&quot; :speed 1200 :bytesize 7 :parity 'odd)
  (make-serial-process :port \&quot;/dev/tty.BlueConsole-SPP-1\&quot; :speed nil)&quot;)</pre></td></tr><tr><td class="docs"><p>Configure speed, bytesize, etc. of a serial process.</p>

<p>  Arguments are specified as keyword/argument pairs.  Attributes that
  are not given are re-initialized from the process's current
  configuration (available via the function `process-contact') or set to
  reasonable default values.  The following arguments are defined:</p>

<p>  :process PROCESS
  :name NAME
  :buffer BUFFER
  :port PORT
  -- Any of these arguments can be given to identify the process that is
  to be configured.  If none of these arguments is given, the current
  buffer's process is used.</p>

<p>  :speed SPEED -- SPEED is the speed of the serial port in bits per
  second, also called baud rate.  Any value can be given for SPEED, but
  most serial ports work only at a few defined values between 1200 and
  115200, with 9600 being the most common value.  If SPEED is nil, the
  serial port is not configured any further, i.e., all other arguments
  are ignored.  This may be useful for special serial ports such as
  Bluetooth-to-serial converters which can only be configured through AT
  commands.  A value of nil for SPEED can be used only when passed
  through <code>make-serial-process' or</code>serial-term'.</p>

<p>  :bytesize BYTESIZE -- BYTESIZE is the number of bits per byte, which
  can be 7 or 8.  If BYTESIZE is not given or nil, a value of 8 is used.</p>

<p>  :parity PARITY -- PARITY can be nil (don't use parity), the symbol
  <code>odd' (use odd parity), or the symbol</code>even' (use even parity).  If
  PARITY is not given, no parity is used.</p>

<p>  :stopbits STOPBITS -- STOPBITS is the number of stopbits used to
  terminate a byte transmission.  STOPBITS can be 1 or 2.  If STOPBITS
  is not given or nil, 1 stopbit is used.</p>

<p>  :flowcontrol FLOWCONTROL -- FLOWCONTROL determines the type of
  flowcontrol to be used, which is either nil (don't use flowcontrol),
  the symbol <code>hw' (use RTS/CTS hardware flowcontrol), or the symbol</code>sw'
  (use XON/XOFF software flowcontrol).  If FLOWCONTROL is not given, no
  flowcontrol is used.</p>

<p>  <code>serial-process-configure' is called by</code>make-serial-process' for the
  initial configuration of the serial port.</p>

<p>  Examples:</p>

<p>  (serial-process-configure :process "/dev/ttyS0" :speed 1200)</p>

<p>  (serial-process-configure
      :buffer "COM1" :stopbits 1 :parity 'odd :flowcontrol 'hw)</p>

<p>  (serial-process-configure :port "\.\COM13" :bytesize 7)</p>
</td><td class="codes"><pre class="brush: clojure">(defun serial-process-configure (&amp;rest args)
  &quot;Configure speed, bytesize, etc. of a serial process.
  Arguments are specified as keyword/argument pairs.  Attributes that
  are not given are re-initialized from the process's current
  configuration (available via the function `process-contact') or set to
  reasonable default values.  The following arguments are defined:
  :process PROCESS
  :name NAME
  :buffer BUFFER
  :port PORT
  -- Any of these arguments can be given to identify the process that is
  to be configured.  If none of these arguments is given, the current
  buffer's process is used.
  :speed SPEED -- SPEED is the speed of the serial port in bits per
  second, also called baud rate.  Any value can be given for SPEED, but
  most serial ports work only at a few defined values between 1200 and
  115200, with 9600 being the most common value.  If SPEED is nil, the
  serial port is not configured any further, i.e., all other arguments
  are ignored.  This may be useful for special serial ports such as
  Bluetooth-to-serial converters which can only be configured through AT
  commands.  A value of nil for SPEED can be used only when passed
  through `make-serial-process' or `serial-term'.
  :bytesize BYTESIZE -- BYTESIZE is the number of bits per byte, which
  can be 7 or 8.  If BYTESIZE is not given or nil, a value of 8 is used.
  :parity PARITY -- PARITY can be nil (don't use parity), the symbol
  `odd' (use odd parity), or the symbol `even' (use even parity).  If
  PARITY is not given, no parity is used.
  :stopbits STOPBITS -- STOPBITS is the number of stopbits used to
  terminate a byte transmission.  STOPBITS can be 1 or 2.  If STOPBITS
  is not given or nil, 1 stopbit is used.
  :flowcontrol FLOWCONTROL -- FLOWCONTROL determines the type of
  flowcontrol to be used, which is either nil (don't use flowcontrol),
  the symbol `hw' (use RTS/CTS hardware flowcontrol), or the symbol `sw'
  (use XON/XOFF software flowcontrol).  If FLOWCONTROL is not given, no
  flowcontrol is used.
  `serial-process-configure' is called by `make-serial-process' for the
  initial configuration of the serial port.
  Examples:
  (serial-process-configure :process \&quot;/dev/ttyS0\&quot; :speed 1200)
  (serial-process-configure
      :buffer \&quot;COM1\&quot; :stopbits 1 :parity 'odd :flowcontrol 'hw)
  (serial-process-configure :port \&quot;\\\\.\\COM13\&quot; :bytesize 7)&quot;)</pre></td></tr><tr><td class="docs"><p>This function is obsolete since 23.1.</p>

<p>  Set multibyteness of the strings given to PROCESS's filter.
  If FLAG is non-nil, the filter is given multibyte strings.
  If FLAG is nil, the filter is given unibyte strings.  In this case,
  all character code conversion except for end-of-line conversion is
  suppressed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-process-filter-multibyte (process flag))</pre></td></tr><tr><td class="docs"><p>Make PROCESS see end-of-file in its input.
  EOF comes after any text already sent to it.
  PROCESS may be a process, a buffer, the name of a process or buffer, or
  nil, indicating the current buffer's process.
  If PROCESS is a network connection, or is a process communicating
  through a pipe (as opposed to a pty), then you cannot send any more
  text to PROCESS after you call this function.
  If PROCESS is a serial process, wait until all output written to the
  process has been transmitted to the serial port.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-send-eof (&amp;optional process))</pre></td></tr><tr><td class="docs"><p>Set the datagram address for PROCESS to ADDRESS.
  Returns nil upon error setting address, ADDRESS otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-process-datagram-address (process address))</pre></td></tr><tr><td class="docs"><p>Return the current value of query-on-exit flag for PROCESS.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-query-on-exit-flag (process))</pre></td></tr><tr><td class="docs"><p>Return the (or a) process associated with BUFFER.
  BUFFER may be a buffer or the name of one.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-buffer-process (buffer))</pre></td></tr><tr><td class="docs"><p>Return the process id of PROCESS.
  This is the pid of the external process which PROCESS uses or talks to.
  For a network connection, this value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun process-id (process))</pre></td></tr><tr><td class="docs"><p>Allow any pending output from subprocesses to be read by Emacs.
  It is read into the process' buffers or given to their filter functions.
  Non-nil arg PROCESS means do not return until some output has been received
  from PROCESS.</p>

<p>  Non-nil second arg SECONDS and third arg MILLISEC are number of seconds
  and milliseconds to wait; return after that much time whether or not
  there is any subprocess output.  If SECONDS is a floating point number,
  it specifies a fractional number of seconds to wait.
  The MILLISEC argument is obsolete and should be avoided.</p>

<p>  If optional fourth arg JUST-THIS-ONE is non-nil, only accept output
  from PROCESS, suspending reading output from other processes.
  If JUST-THIS-ONE is an integer, don't run any timers either.
  Return non-nil if we received any output before the timeout expired.</p>
</td><td class="codes"><pre class="brush: clojure">(defun accept-process-output (&amp;optional process seconds millisec just-this-one))</pre></td></tr><tr><td class="docs"><p>Start a program in a subprocess.  Return the process object for it.
  NAME is name for process.  It is modified if necessary to make it unique.
  BUFFER is the buffer (or buffer name) to associate with the process.</p>

<p>  Process output (both standard output and standard error streams) goes
  at end of BUFFER, unless you specify an output stream or filter
  function to handle the output.  BUFFER may also be nil, meaning that
  this process is not associated with any buffer.</p>

<p>  PROGRAM is the program file name.  It is searched for in `exec-path'
  (which see).  If nil, just associate a pty with the buffer.  Remaining
  arguments are strings to give program as arguments.</p>

<p>  If you want to separate standard output from standard error, invoke
  the command through a shell and redirect one of them using the shell
  syntax.</p>
</td><td class="codes"><pre class="brush: clojure">(defun start-process (name buffer program &amp;rest program-args)
  ;; Just fire and forget to let things like browse-url work, not supporting the entire Process sub-system.
  (let [command (cons program program-args)]
    (future (apply sh/sh command))))</pre></td></tr><tr><td class="docs"><p>Replace the plist of PROCESS with PLIST.  Returns PLIST.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-process-plist (process plist))</pre></td></tr><tr><td class="docs"><p>Interrupt process PROCESS.
  PROCESS may be a process, a buffer, or the name of a process or buffer.
  No arg or nil means current buffer's process.
  Second arg CURRENT-GROUP non-nil means send signal to
  the current process-group of the process's controlling terminal
  rather than to the process's own process group.
  If the process is a shell, this means interrupt current subjob
  rather than the shell.</p>

<p>  If CURRENT-GROUP is `lambda', and if the shell owns the terminal,
  don't send the signal.</p>
</td><td class="codes"><pre class="brush: clojure">(defun interrupt-process (&amp;optional process current-group))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.character" name="deuce.emacs.character"><h1 class="project-name">deuce.emacs.character</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.character
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>A char-table for characters which invoke auto-filling.
  Such characters have value t in this table.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-fill-chars nil)</pre></td></tr><tr><td class="docs"><p>A char-table for each printable character.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar printable-chars nil)</pre></td></tr><tr><td class="docs"><p>Char table of Unicode's "General Category".
  All Unicode characters have one of the following values (symbol):
    Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No, Pc, Pd, Ps, Pe, Pi, Pf, Po,
    Sm, Sc, Sk, So, Zs, Zl, Zp, Cc, Cf, Cs, Co, Cn
  See The Unicode Standard for the meaning of those values.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar unicode-category-table nil)</pre></td></tr><tr><td class="docs"><p>A char-table for width (columns) of each character.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar char-width-table nil)</pre></td></tr><tr><td class="docs"><p>Char table of script symbols.
  It has one extra slot whose value is a list of script symbols.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar char-script-table nil)</pre></td></tr><tr><td class="docs"><p>Vector recording all translation tables ever defined.
  Each element is a pair (SYMBOL . TABLE) relating the table to the
  symbol naming it.  The ID of a translation table is an index into this vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar translation-table-vector nil)</pre></td></tr><tr><td class="docs"><p>Alist of scripts vs the representative characters.
  Each element is a cons (SCRIPT . CHARS).
  SCRIPT is a symbol representing a script or a subgroup of a script.
  CHARS is a list or a vector of characters.
  If it is a list, all characters in the list are necessary for supporting SCRIPT.
  If it is a vector, one of the characters in the vector is necessary.
  This variable is used to find a font for a specific script.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar script-representative-chars nil)</pre></td></tr><tr><td class="docs"><p>Convert the byte CH to multibyte character.</p>
</td><td class="codes"><pre class="brush: clojure">(defun unibyte-char-to-multibyte (ch))</pre></td></tr><tr><td class="docs"><p>Convert the multibyte character CH to a byte.
  If the multibyte character does not represent a byte, return -1.</p>
</td><td class="codes"><pre class="brush: clojure">(defun multibyte-char-to-unibyte (ch))</pre></td></tr><tr><td class="docs"><p>Resolve modifiers in the character CHAR.
  The value is a character with modifiers resolved into the character
  code.  Unresolved modifiers are kept in the value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-resolve-modifiers (char))</pre></td></tr><tr><td class="docs"><p>Return width of STRING when displayed in the current buffer.
  Width is measured by how many columns it occupies on the screen.
  When calculating width of a multibyte character in STRING,
  only the base leading-code is considered; the validity of
  the following bytes is not checked.  Tabs in STRING are always
  taken to occupy `tab-width' columns.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-width (string)
  (count (.getBytes (str string))))</pre></td></tr><tr><td class="docs"><p>Return width of CHAR when displayed in the current buffer.
  The width is measured by how many columns it occupies on the screen.
  Tab is taken to occupy `tab-width' columns.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-width (char))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare max-char)</pre></td></tr><tr><td class="docs"><p>Return non-nil if OBJECT is a character.</p>
</td><td class="codes"><pre class="brush: clojure">(defun characterp (object)
  (and ((some-fn integer? char?) object) (pos? (int object)) (&lt;= (int object) (max-char))))</pre></td></tr><tr><td class="docs"><p>Concatenate all the argument bytes and make the result a unibyte string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun unibyte-string (&amp;rest bytes)
  (String. (byte-array (map byte bytes)) &quot;US-ASCII&quot;))</pre></td></tr><tr><td class="docs"><p>Return a byte value of a character at point.
  Optional 1st arg POSITION, if non-nil, is a position of a character to get
  a byte value.
  Optional 2nd arg STRING, if non-nil, is a string of which first
  character is a target to get a byte value.  In this case, POSITION, if
  non-nil, is an index of a target character in the string.</p>

<p>  If the current buffer (or STRING) is multibyte, and the target
  character is not ASCII nor 8-bit character, an error is signaled.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-byte (&amp;optional position string))</pre></td></tr><tr><td class="docs"><p>Return the character of the maximum code.</p>
</td><td class="codes"><pre class="brush: clojure">(defun max-char ()
  ;;0x3FFFFF in Emacs.
  (int Character/MAX_VALUE))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.xdisp" name="deuce.emacs.xdisp"><h1 class="project-name">deuce.emacs.xdisp</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.xdisp
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns]
            [deuce.emacs.eval :as eval]
            [deuce.emacs.fileio :as fileio]
            [deuce.emacs.fns :as fns]
            [deuce.emacs.frame :as frame]
            [deuce.emacs.keyboard :as keyboard]
            [deuce.emacs.window :as window])
  (:import [deuce.emacs.data Buffer BufferText Frame])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>*The number of lines to try scrolling a window by when point moves out.
  If that fails to bring point back on frame, point is centered instead.
  If this is zero, point is always centered after it moves off frame.
  If you want scrolling to always be a line at a time, you should set
  `scroll-conservatively' to a large value rather than set this to 1.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar scroll-step nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means show an hourglass pointer, when Emacs is busy.
  This feature only works when on a window system that can change
  cursor shapes.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar display-hourglass nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means don't actually do any redisplay.
  This is used for internal purposes.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-redisplay nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means don't eval Lisp during redisplay.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-eval-during-redisplay nil)</pre></td></tr><tr><td class="docs"><p>Prefix prepended to all continuation lines at display time.
  The value may be a string, an image, or a stretch-glyph; it is
  interpreted in the same way as the value of a `display' text property.</p>

<p>  This variable is overridden by any `wrap-prefix' text or overlay
  property.</p>

<p>  To add a prefix to non-continuation lines, use `line-prefix'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar wrap-prefix nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means highlight trailing whitespace.
  The face used for trailing whitespace is `trailing-whitespace'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar show-trailing-whitespace nil)</pre></td></tr><tr><td class="docs"><p>*The pointer shape to show in void text areas.
  A value of nil means to show the text pointer.  Other options are `arrow',
  <code>text',</code>hand', <code>vdrag',</code>hdrag', <code>modeline', and</code>hourglass'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar void-text-area-pointer nil)</pre></td></tr><tr><td class="docs"><p>Alist specifying how to blink the cursor off.
  Each element has the form (ON-STATE . OFF-STATE).  Whenever the
  `cursor-type' frame-parameter or variable equals ON-STATE,
  comparing using `equal', Emacs uses OFF-STATE to specify
  how to blink it off.  ON-STATE and OFF-STATE are values for
  the `cursor-type' frame parameter.</p>

<p>  If a frame's ON-STATE has no entry in this list,
  the frame's other specifications determine how to blink the cursor off.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar blink-cursor-alist nil)</pre></td></tr><tr><td class="docs"><p>Allow or disallow automatic horizontal scrolling of windows.
  If non-nil, windows are automatically scrolled horizontally to make
  point visible.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-hscroll-mode nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means don't free realized faces.  Internal use only.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-free-realized-faces nil)</pre></td></tr><tr><td class="docs"><p>*Maximum buffer size for which line number should be displayed.
  If the buffer is bigger than this, the line number does not appear
  in the mode line.  A value of nil means no limit.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar line-number-display-limit nil)</pre></td></tr><tr><td class="docs"><p>Normal hook run to update the menu bar definitions.
  Redisplay runs this hook before it redisplays the menu bar.
  This is used to update submenus such as Buffers,
  whose contents depend on various data.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar menu-bar-update-hook nil)</pre></td></tr><tr><td class="docs"><p>Functions to call in redisplay when text in the window might change.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar window-text-change-functions nil)</pre></td></tr><tr><td class="docs"><p>*Number of lines of margin at the top and bottom of a window.
  Recenter the window whenever point gets within this many lines
  of the top or bottom of the window.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar scroll-margin nil)</pre></td></tr><tr><td class="docs"><p>Maximum number of lines to keep in the message log buffer.
  If nil, disable message logging.  If t, log messages but don't truncate
  the buffer when it becomes large.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar message-log-max nil)</pre></td></tr><tr><td class="docs"><p>*Border below tool-bar in pixels.
  If an integer, use it as the height of the border.
  If it is one of <code>internal-border-width' or</code>border-width', use the
  value of the corresponding frame parameter.
  Otherwise, no border is added below the tool-bar.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar tool-bar-border nil)</pre></td></tr><tr><td class="docs"><p>*How many columns away from the window edge point is allowed to get
  before automatic hscrolling will horizontally scroll the window.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar hscroll-margin nil)</pre></td></tr><tr><td class="docs"><p>*Scroll up to this many lines, to bring point back on screen.
  If point moves off-screen, redisplay will scroll by up to
  `scroll-conservatively' lines in order to bring point just barely
  onto the screen again.  If that cannot be done, then redisplay
  recenters point as usual.</p>

<p>  If the value is greater than 100, redisplay will never recenter point,
  but will always scroll just enough text to bring point into view, even
  if you move far away.</p>

<p>  A value of zero means always recenter point if it moves off screen.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar scroll-conservatively nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means display unibyte text according to language environment.
  Specifically, this means that raw bytes in the range 160-255 decimal
  are displayed by converting them to the equivalent multibyte characters
  according to the current language environment.  As a result, they are
  displayed according to the current fontset.</p>

<p>  Note that this variable affects only how these bytes are displayed,
  but does not change the fact they are interpreted as raw bytes.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar unibyte-display-via-language-environment nil)</pre></td></tr><tr><td class="docs"><p>*Relief thickness of tool-bar buttons.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar tool-bar-button-relief nil)</pre></td></tr><tr><td class="docs"><p>*Margin around tool-bar buttons in pixels.
  If an integer, use that for both horizontal and vertical margins.
  Otherwise, value should be a pair of integers `(HORZ . VERT)' with
  HORZ specifying the horizontal margin, and VERT specifying the
  vertical margin.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar tool-bar-button-margin nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, messages are truncated instead of resizing the echo area.
  Bind this around calls to `message' to let it take effect.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar message-truncate-lines nil)</pre></td></tr><tr><td class="docs"><p>*Maximum number of characters a label can have to be shown.
  The tool bar style must also show labels for this to have any effect, see
  `tool-bar-style'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar tool-bar-max-label-size nil)</pre></td></tr><tr><td class="docs"><p>Prefix prepended to all non-continuation lines at display time.
  The value may be a string, an image, or a stretch-glyph; it is
  interpreted in the same way as the value of a `display' text property.</p>

<p>  This variable is overridden by any `line-prefix' text or overlay
  property.</p>

<p>  To add a prefix to continuation lines, use `wrap-prefix'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar line-prefix nil)</pre></td></tr><tr><td class="docs"><p>Functions called when redisplay of a window reaches the end trigger.
  Each function is called with two arguments, the window and the end trigger value.
  See `set-window-redisplay-end-trigger'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar redisplay-end-trigger-functions nil)</pre></td></tr><tr><td class="docs"><p>*Maximum height for resizing mini-windows (the minibuffer and the echo area).
  If a float, it specifies a fraction of the mini-window frame's height.
  If an integer, it specifies a number of lines.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar max-mini-window-height nil)</pre></td></tr><tr><td class="docs"><p>Marker for where to display an arrow on top of the buffer text.
  This must be the beginning of a line in order to work.
  See also `overlay-arrow-string'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar overlay-arrow-position nil)</pre></td></tr><tr><td class="docs"><p>Template for displaying the title bar of an iconified frame.
  (Assuming the window manager supports this feature.)
  This variable has the same structure as `mode-line-format' (which see),
  and is used only on frames for which no explicit name has been set
  (see `modify-frame-parameters').</p>
</td><td class="codes"><pre class="brush: clojure">(defvar icon-title-format nil)</pre></td></tr><tr><td class="docs"><p>List of variables (symbols) which hold markers for overlay arrows.
  The symbols on this list are examined during redisplay to determine
  where to display overlay arrows.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar overlay-arrow-variable-list nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means truncate lines in windows narrower than the frame.
  For an integer value, truncate lines in each window narrower than the
  full frame width, provided the window width is less than that integer;
  otherwise, respect the value of `truncate-lines'.</p>

<p>  For any other non-nil value, truncate lines in all windows that do
  not span the full frame width.</p>

<p>  A value of nil means to respect the value of `truncate-lines'.</p>

<p>  If `word-wrap' is enabled, you might want to reduce this.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar truncate-partial-width-windows nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means to scroll (recenter) cursor line if it is not fully visible.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar make-cursor-line-fully-visible nil)</pre></td></tr><tr><td class="docs"><p>*Seconds to wait before displaying an hourglass pointer when Emacs is busy.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar hourglass-delay nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means don't update menu bars.  Internal use only.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-menubar-update nil)</pre></td></tr><tr><td class="docs"><p>Pixels per inch value for non-window system displays.
  Value is a number or a cons (WIDTH-DPI . HEIGHT-DPI).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar display-pixels-per-inch nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means raise tool-bar buttons when the mouse moves over them.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-raise-tool-bar-buttons nil)</pre></td></tr><tr><td class="docs"><p>Control highlighting of non-ASCII space and hyphen chars.
  If the value is t, Emacs highlights non-ASCII chars which have the
  same appearance as an ASCII space or hyphen, using the `nobreak-space'
  or `escape-glyph' face respectively.</p>

<p>  U+00A0 (no-break space), U+00AD (soft hyphen), U+2010 (hyphen), and
  U+2011 (non-breaking hyphen) are affected.</p>

<p>  Any other non-nil value means to display these characters as a escape
  glyph followed by an ordinary space or hyphen.</p>

<p>  A value of nil means no special handling of these characters.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar nobreak-char-display nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means automatically resize tool-bars.
  This dynamically changes the tool-bar's height to the minimum height
  that is needed to make all tool-bar items visible.
  If value is `grow-only', the tool-bar's height is only increased
  automatically; to decrease the tool-bar height, use M-x recenter.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar auto-resize-tool-bars nil)</pre></td></tr><tr><td class="docs"><p>List of functions to call to fontify regions of text.
  Each function is called with one argument POS.  Functions must
  fontify a region starting at POS in the current buffer, and give
  fontified regions the property `fontified'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar fontification-functions nil)</pre></td></tr><tr><td class="docs"><p>*How many columns to scroll the window when point gets too close to the edge.
  When point is less than `hscroll-margin' columns from the window
  edge, automatic hscrolling will scroll the window by the amount of columns
  determined by this variable.  If its value is a positive integer, scroll that
  many columns.  If it's a positive floating-point number, it specifies the
  fraction of the window's width to scroll.  If it's nil or zero, point will be
  centered horizontally after the scroll.  Any other value, including negative
  numbers, are treated as if the value were zero.</p>

<p>  Automatic hscrolling always moves point outside the scroll margin, so if
  point was more than scroll step columns inside the margin, the window will
  scroll more than the value given by the scroll step.</p>

<p>  Note that the lower bound for automatic hscrolling specified by `scroll-left'
  and `scroll-right' overrides this variable's effect.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar hscroll-step nil)</pre></td></tr><tr><td class="docs"><p>String to display as an arrow in non-window frames.
  See also `overlay-arrow-position'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar overlay-arrow-string nil)</pre></td></tr><tr><td class="docs"><p>List of functions to call before redisplaying a window with scrolling.
  Each function is called with two arguments, the window and its new
  display-start position.  Note that these functions are also called by
  <code>set-window-buffer'.  Also note that the value of</code>window-end' is not
  valid when these functions are called.</p>

<p>  Warning: Do not use this feature to alter the way the window
  is scrolled.  It is not designed for that, and such use probably won't
  work.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar window-scroll-functions nil)</pre></td></tr><tr><td class="docs"><p>Template for displaying the title bar of visible frames.
  (Assuming the window manager supports this feature.)</p>

<p>  This variable has the same structure as `mode-line-format', except that
  the %c and %l constructs are ignored.  It is used only on frames for
  which no explicit name has been set (see `modify-frame-parameters').</p>
</td><td class="codes"><pre class="brush: clojure">(defvar frame-title-format nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means autoselect window with mouse pointer.
  If nil, do not autoselect windows.
  A positive number means delay autoselection by that many seconds: a
  window is autoselected only after the mouse has remained in that
  window for the duration of the delay.
  A negative number has a similar effect, but causes windows to be
  autoselected only after the mouse has stopped moving.  (Because of
  the way Emacs compares mouse events, you will occasionally wait twice
  that time before the window gets selected.)
  Any other value means to autoselect window instantaneously when the
  mouse pointer enters it.</p>

<p>  Autoselection selects the minibuffer only if it is active, and never
  unselects the minibuffer if it is active.</p>

<p>  When customizing this variable make sure that the actual value of
  `focus-follows-mouse' matches the behavior of your window manager.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar mouse-autoselect-window nil)</pre></td></tr><tr><td class="docs"><p>Functions called before redisplay, if window sizes have changed.
  The value should be a list of functions that take one argument.
  Just before redisplay, for each frame, if any of its windows have changed
  size since the last redisplay, or have been split or deleted,
  all the functions in the list are called, with the frame as argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar window-size-change-functions nil)</pre></td></tr><tr><td class="docs"><p>Frame for which we are updating a menu.
  The enable predicate for a menu binding should check this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar menu-updating-frame nil)</pre></td></tr><tr><td class="docs"><p>Non-nil if more than one frame is visible on this display.
  Minibuffer-only frames don't count, but iconified frames do.
  This variable is not guaranteed to be accurate except while processing
  <code>frame-title-format' and</code>icon-title-format'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar multiple-frames nil)</pre></td></tr><tr><td class="docs"><p>When nil, display the mode-line/header-line/menu-bar in the default face.
  Any other value means to use the appropriate face, `mode-line',
  <code>header-line', or</code>menu' respectively.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar mode-line-inverse-video nil)</pre></td></tr><tr><td class="docs"><p>Tool bar style to use.
  It can be one of
   image            - show images only
   text             - show text only
   both             - show both, text below image
   both-horiz       - show text to the right of the image
   text-image-horiz - show text to the left of the image
   any other        - use system default or image if no system default.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar tool-bar-style nil)</pre></td></tr><tr><td class="docs"><p>How to resize mini-windows (the minibuffer and the echo area).
  A value of nil means don't automatically resize mini-windows.
  A value of t means resize them to fit the text displayed in them.
  A value of `grow-only', the default, means let mini-windows grow only;
  they return to their normal size when the minibuffer is closed, or the
  echo area becomes empty.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar resize-mini-windows nil)</pre></td></tr><tr><td class="docs"><p>String (or mode line construct) included (normally) in `mode-line-format'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar global-mode-string nil)</pre></td></tr><tr><td class="docs"><p>*Maximum line width (in characters) for line number display.
  If the average length of the lines near point is bigger than this, then the
  line number may be omitted from the mode line.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar line-number-display-limit-width nil)</pre></td></tr><tr><td class="docs"><p>Minimum distance between baseline and underline.
  This can improve legibility of underlined text at small font sizes,
  particularly when using variable `x-use-underline-position-properties'
  with fonts that specify an UNDERLINE_POSITION relatively close to the
  baseline.  The default value is 1.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar underline-minimum-offset nil)</pre></td></tr><tr><td class="docs"><p>Char-table defining glyphless characters.
  Each element, if non-nil, should be one of the following:
    an ASCII acronym string: display this string in a box
    `hex-code':   display the hexadecimal code of a character in a box
    `empty-box':  display as an empty box
    `thin-space': display as 1-pixel width space
    `zero-width': don't display
  An element may also be a cons cell (GRAPHICAL . TEXT), which specifies the
  display method for graphical terminals and text terminals respectively.
  GRAPHICAL and TEXT should each have one of the values listed above.</p>

<p>  The char-table has one extra slot to control the display of a character for
  which no font is found.  This slot only takes effect on graphical terminals.
  Its value should be an ASCII acronym string, <code>hex-code',</code>empty-box', or
  <code>thin-space'.  The default is</code>empty-box'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar glyphless-char-display nil)</pre></td></tr><tr><td class="docs"><p>*Space between overline and text, in pixels.
  The default value is 2: the height of the overline (1 pixel) plus 1 pixel
  margin to the character height.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar overline-margin nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means highlight region even in nonselected windows.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar highlight-nonselected-windows nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fns/put 'glyphless-char-display 'char-table-extra-slots 0)</pre></td></tr><tr><td class="docs"><p>Return paragraph direction at point in BUFFER.
  Value is either <code>left-to-right' or</code>right-to-left'.
  If BUFFER is omitted or nil, it defaults to the current buffer.</p>

<p>  Paragraph direction determines how the text in the paragraph is displayed.
  In left-to-right paragraphs, text begins at the left margin of the window
  and the reading direction is generally left to right.  In right-to-left
  paragraphs, text begins at the right margin and is read from right to left.</p>

<p>  See also `bidi-paragraph-direction'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-bidi-paragraph-direction (&amp;optional buffer)
  'left-to-right)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private point-coords-for-buffer [buffer]
  (let [[px py] ((ns-resolve 'deuce.emacs.cmds 'point-coords) buffer)]
    [px (inc py)]))</pre></td></tr><tr><td class="docs"><p>Format a string out of a mode line format specification.
  First arg FORMAT specifies the mode line format (see `mode-line-format'
  for details) to use.</p>

<p>  By default, the format is evaluated for the currently selected window.</p>

<p>  Optional second arg FACE specifies the face property to put on all
  characters for which no face is specified.  The value nil means the
  default face.  The value t means whatever face the window's mode line
  currently uses (either <code>mode-line' or</code>mode-line-inactive',
  depending on whether the window is the selected window or not).
  An integer value means the value string has no text
  properties.</p>

<p>  Optional third and fourth args WINDOW and BUFFER specify the window
  and buffer to use as the context for the formatting (defaults
  are the selected window and the WINDOW's buffer).</p>
</td><td class="codes"><pre class="brush: clojure">(defun format-mode-line (format &amp;optional face window buffer)
  (let [window (el/check-type 'windowp (or window (window/selected-window)))
        buffer (el/check-type 'bufferp (or buffer (window/window-buffer window)))
        window-width (max (window/window-total-width window)
                          (data/symbol-value 'fill-column)) ;; Hack for stdout
        window-height (max (window/window-total-height window) 10)
        lines (count (filter #{\newline} (str (.beg ^BufferText (.text ^Buffer buffer)))))
        [column line] (point-coords-for-buffer buffer)
        all-visible? (&gt; window-height lines)
        modified? (buffer/buffer-modified-p buffer)
        read-only? (buffer/buffer-local-value 'buffer-read-only buffer)
        recursion-depth (keyboard/recursion-depth)
        coding-system-mnemonic &quot;1&quot; ;; &quot;1&quot; is ISO-Latin-1, U&quot; is UTF-8, &quot;-&quot; is ASCII. See interntional/mule-conf
        eol-type-mnemnonic ((el/fun 'coding-system-eol-type-mnemonic) nil)
        % (fn [x] (re-pattern (str &quot;%(-?\\d*)&quot; x)))
        humanize (fn [x]
                   (some identity (reverse
                          (map-indexed (fn [idx suffix]
                                         (let [size (Math/pow 1024 idx)]
                                           (when (&gt; x size)
                                             (str (long (/ x size)) suffix))) )
                                       [&quot;&quot; &quot;k&quot; &quot;M&quot; &quot;G&quot;]))))
        pad (fn padder
              ([value] (partial padder value))
              ([value [_ pad]]
                 (let [s (str value)
                       pad (when (seq pad) (Integer/parseInt pad))]
                   (c/format (str &quot;%&quot; (if (or (not pad) (neg? pad)) &quot;&quot;
                                          (if (and (pos? pad) (number? value)) pad (- pad))) &quot;s&quot;)
                             (if (and pad (neg? pad))
                               (subs s 0 (min (count s) (- pad)))
                               s)))))
        formatter (fn formatter [f] ;; Vastly incomplete and wrong.
                    (condp some [f]
                      string? (let [%% (str (gensym &quot;PERCENT&quot;))]
                                (-&gt; ;; Deal with %% last.
                                 (reduce #(s/replace %1 (key %2) (val %2)) (s/replace f &quot;%%&quot; %%)
                                         {(% &quot;e&quot;) (if (data/symbol-value 'memory-full) &quot;!MEM FULL! &quot; &quot;&quot;)
                                          (% &quot;n&quot;) &quot;&quot; ;; &quot;Narrow&quot;
                                          (% &quot;z&quot;) coding-system-mnemonic
                                          (% &quot;Z&quot;) (str coding-system-mnemonic eol-type-mnemnonic)
                                          (% &quot;\\[&quot;) (if (&lt; 5 recursion-depth)
                                                      &quot;[[[... &quot;
                                                      (s/join (repeat (keyboard/recursion-depth) &quot;[&quot; )))
                                          (% &quot;\\]&quot;) (if (&lt; 5 recursion-depth)
                                                      &quot; ...]]]&quot;
                                                      (s/join (repeat (keyboard/recursion-depth) &quot;]&quot; )))
                                          (% &quot;@&quot;)  &quot;-&quot; ;; files/file-remote-p
                                          (% &quot;\\+&quot;) (cond
                                                     modified? &quot;*&quot;
                                                     read-only? &quot;%&quot;
                                                     :else &quot;-&quot;)
                                          (% &quot;\\*&quot;) (cond
                                                     read-only? &quot;%&quot;
                                                     modified? &quot;*&quot;
                                                     :else &quot;-&quot;)
                                          (% &quot;&amp;&quot;) (if modified? &quot;*&quot; &quot;-&quot;)
                                          (% &quot;l&quot;) (str line)
                                          (% &quot;c&quot;) (str column)
                                          (% &quot;i&quot;) (pad (editfns/buffer-size buffer)) ;; Should take narrowing in account.
                                          (% &quot;I&quot;) (pad (humanize (editfns/buffer-size buffer)))
                                          (% &quot;p&quot;) (pad (if all-visible?
                                                         &quot;All&quot;
                                                         (let [percent (long (* 100 (/ @(.pt ^Buffer buffer)
                                                                                       (inc (editfns/buffer-size buffer)))))]
                                                           (case percent
                                                             0 &quot;Top&quot;
                                                             100 &quot;Bottom&quot;
                                                             (str percent &quot;%&quot;)))))
                                          ;; (% &quot;P&quot;) ;; The reverse of the above
                                          (% &quot;m&quot;) (pad (buffer/buffer-local-value 'mode-name buffer))
                                          (% &quot;M&quot;) (pad (data/symbol-value 'global-mode-string))
                                          (% &quot;b&quot;) (pad (buffer/buffer-name buffer))
                                          (% &quot;f&quot;) (pad (buffer/buffer-file-name buffer))
                                          (% &quot;F&quot;) (pad (.name ^Frame (frame/selected-frame)))})
                                 (s/replace %% &quot;%&quot;)))
                      symbol? (formatter (data/symbol-value f))
                      seq? (let [fst (first f)]
                             (condp some [fst]
                               integer? (pad (formatter (rest f)) [:ignored (str fst)])
                               #{:eval} (formatter (eval/eval (second f)))
                               #{:propertize} (formatter (second f)) ;; Properties are used for tooltips, fonts etc.
                               symbol? (if (and (data/boundp fst) (data/symbol-value fst))
                                         (formatter (second f))
                                         (formatter (nth f 2 nil)))
                               (s/join (map formatter f))))
                      (str f)))]
    (let [mode-line (formatter format)]
      (s/replace mode-line #&quot;%-$&quot;
                 (s/join (repeat (+ (- window-width (count mode-line)) (count &quot;%-&quot;)) &quot;-&quot;))))))</pre></td></tr><tr><td class="docs"><p>Non-nil if the property makes the text invisible.
  POS-OR-PROP can be a marker or number, in which case it is taken to be
  a position in the current buffer and the value of the `invisible' property
  is checked; or it can be some other value, which is then presumed to be the
  value of the `invisible' property of the text of interest.
  The non-nil value returned can be t for truly invisible text or something
  else if the text is replaced by an ellipsis.</p>
</td><td class="codes"><pre class="brush: clojure">(defun invisible-p (pos-or-prop))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.eval" name="deuce.emacs.eval"><h1 class="project-name">deuce.emacs.eval</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.eval
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.data :as data]
            [deuce.emacs-lisp.cons :as cons]
            [deuce.emacs-lisp :as el])
  (:import [clojure.lang Var])
  (:refer-clojure :exclude [apply eval macroexpand]))</pre></td></tr><tr><td class="docs"><p>Function to call to invoke debugger.
  If due to frame exit, args are `exit' and the value being returned;
   this function's value will be returned instead of that.
  If due to error, args are <code>error' and a list of the args to</code>signal'.
  If due to <code>apply' or</code>funcall' entry, one arg, `lambda'.
  If due to `eval' entry, one arg, t.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar debugger nil)</pre></td></tr><tr><td class="docs"><p>Non-nil inhibits C-g quitting from happening immediately.
  Note that `quit-flag' will still be set by typing C-g,
  so a quit will be signaled as soon as `inhibit-quit' is nil.
  To prevent this happening, set `quit-flag' to nil
  before making `inhibit-quit' nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-quit nil)</pre></td></tr><tr><td class="docs"><p>*Limit on depth in <code>eval',</code>apply' and `funcall' before error.</p>

<p>  This limit serves to catch infinite recursions for you before they cause
  actual stack overflow in C, which would be fatal for Emacs.
  You can safely make it considerably larger than its default value,
  if that proves inconveniently small.  However, if you increase it too far,
  Emacs could overflow the real C stack, and crash.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar max-lisp-eval-depth nil)</pre></td></tr><tr><td class="docs"><p>Function to process declarations in a macro definition.
  The function will be called with two args MACRO and DECL.
  MACRO is the name of the macro being defined.
  DECL is a list `(declare ...)' containing the declarations.
  The value the function returns is not used.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar macro-declaration-function nil)</pre></td></tr><tr><td class="docs"><p>Non-nil causes <code>eval' to abort, unless</code>inhibit-quit' is non-nil.
  If the value is t, that means do an ordinary quit.
  If the value equals `throw-on-input', that means quit by throwing
  to the tag specified in <code>throw-on-input'; it's for handling</code>while-no-input'.
  Typing C-g sets <code>quit-flag' to t, regardless of</code>inhibit-quit',
  but `inhibit-quit' non-nil prevents anything from taking notice of that.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar quit-flag nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means call the debugger regardless of condition handlers.
  Note that <code>debug-on-error',</code>debug-on-quit' and friends
  still determine whether to handle the particular condition.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar debug-on-signal nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, this is a function for `signal' to call.
  It receives the same arguments that `signal' was given.
  The Edebug package uses this to regain control.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar signal-hook-function nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means enter debugger before next <code>eval',</code>apply' or `funcall'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar debug-on-next-call nil)</pre></td></tr><tr><td class="docs"><p>*List of errors for which the debugger should not be called.
  Each element may be a condition-name or a regexp that matches error messages.
  If any element applies to a given error, that error skips the debugger
  and just returns to top level.
  This overrides the variable `debug-on-error'.
  It does not apply to errors handled by `condition-case'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar debug-ignored-errors nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means enter debugger if quit is signaled (C-g, for example).
  Does not apply if quit is handled by a `condition-case'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar debug-on-quit nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means enter debugger if an error is signaled.
  Does not apply to errors handled by `condition-case' or those
  matched by `debug-ignored-errors'.
  If the value is a list, an error only means to enter the debugger
  if one of its condition symbols appears in the list.
  When you evaluate an expression interactively, this variable
  is temporarily non-nil if `eval-expression-debug-on-error' is non-nil.
  The command `toggle-debug-on-error' toggles this.
  See also the variable `debug-on-quit'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar debug-on-error nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means debugger may continue execution.
  This is nil when the debugger is called under circumstances where it
  might not be safe to continue.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar debugger-may-continue nil)</pre></td></tr><tr><td class="docs"><p>*Limit on number of Lisp variable bindings and `unwind-protect's.
  If Lisp code tries to increase the total number past this amount,
  an error is signaled.
  You can safely use a value considerably larger than the default value,
  if that proves inconveniently small.  However, if you increase it too far,
  Emacs could run out of memory trying to make the stack bigger.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar max-specpdl-size nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare apply eval funcall)</pre></td></tr><tr><td class="docs"><p>Return t if VARIABLE is intended to be set and modified by users.
  (The alternative is a variable used internally in a Lisp program.)</p>

<p>  This function returns t if (i) the first character of its
  documentation is `*', or (ii) it is customizable (its property list
  contains a non-nil value of <code>standard-value' or</code>custom-autoload'), or
  (iii) it is an alias for a user variable.</p>

<p>  But condition (i) is considered obsolete, so for most purposes this is
  equivalent to `custom-variable-p'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun user-variable-p (variable))</pre></td></tr><tr><td class="docs"><p>Return non-nil if SYMBOL's global binding has been declared special.
  A special variable is one that will be bound dynamically, even in a
  context where binding is lexical by default.</p>
</td><td class="codes"><pre class="brush: clojure">(defun special-variable-p (symbol))</pre></td></tr><tr><td class="docs"><p>Non-nil if OBJECT is a function.</p>
</td><td class="codes"><pre class="brush: clojure">(defun functionp (object)
  (when (or (fn? object)
            (and (symbol? object) (el/fun object))
            (and (seq? object) (= 'lambda (first object))))
    true))</pre></td></tr><tr><td class="docs"><p>Define FUNCTION to autoload from FILE.
  FUNCTION is a symbol; FILE is a file name string to pass to `load'.
  Third arg DOCSTRING is documentation for the function.
  Fourth arg INTERACTIVE if non-nil says function can be called interactively.
  Fifth arg TYPE indicates the type of the object:
     nil or omitted says FUNCTION is a function,
     `keymap' says FUNCTION is really a keymap, and
     `macro' or t says FUNCTION is really a macro.
  Third through fifth args give info about the real definition.
  They default to nil.
  If FUNCTION is already defined other than as an autoload,
  this does nothing and returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun autoload (function file &amp;optional docstring interactive type)
  (when (or (not (el/fun function)) (-&gt; (el/fun function) meta :autoload))
    (let [macro? (= 'macro type)
          autoload-symbol (fn autoload-symbol [function]
                            (let [f (el/fun function)]
                              (when (-&gt; f meta :autoload)
                                (ns-unmap 'deuce.emacs (el/sym function))
                                ((el/fun 'load) (-&gt; f meta :file) nil true))))
          definition  (if macro?
                        (fn autoload-macro [&amp;form &amp;env &amp; args] ;; Note implicit macro args, see defalias
                          (do
                            (autoload-symbol function)
                            `(el/progn (~(el/sym function) ~@args))))
                        (fn autoload [&amp; args]
                          (autoload-symbol function)
                          (c/apply (el/fun function) args)))] ;; el-&gt;clj?
      (ns-unmap 'deuce.emacs function)
      (el/defvar-helper* 'deuce.emacs function definition docstring)
      (alter-meta! (el/fun function) merge {:autoload true :file file} (when interactive {:interactive nil}))
      (when macro? (.setMacro ^Var (el/fun function))))
    function))</pre></td></tr><tr><td class="docs"><p>If byte-compiled OBJECT is lazy-loaded, fetch it now.</p>
</td><td class="codes"><pre class="brush: clojure">(defun fetch-bytecode (object))</pre></td></tr><tr><td class="docs"><p>Signal an error.  Args are ERROR-SYMBOL and associated DATA.
  This function does not return.</p>

<p>  An error symbol is a symbol with an `error-conditions' property
  that is a list of condition names.
  A handler for any of those names will get to handle this signal.
  The symbol `error' should normally be one of them.</p>

<p>  DATA should be a list.  Its elements are printed as part of the error message.
  See Info anchor `(elisp)Definition of signal' for some details on how this
  error message is constructed.
  If the signal is handled, DATA is made available to the handler.
  See also the function `condition-case'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun signal (error-symbol data)
  (el/throw error-symbol data))</pre></td></tr><tr><td class="docs"><p>Return t if the containing function was called by `call-interactively'.
  If KIND is `interactive', then only return t if the call was made
  interactively by the user, i.e. not in `noninteractive' mode nor
  when `executing-kbd-macro'.
  If KIND is `any', on the other hand, it will return t for any kind of
  interactive call, including being called as the binding of a key, or
  from a keyboard macro, or in `noninteractive' mode.</p>

<p>  The only known proper use of `interactive' for KIND is in deciding
  whether to display a helpful message, or how to display it.  If you're
  thinking of using it for any other purpose, it is quite likely that
  you're making a mistake.  Think: what do you want to do when the
  command is called from a keyboard macro?</p>

<p>  Instead of using this function, it is sometimes cleaner to give your
  function an extra optional argument whose `interactive' spec specifies
  non-nil unconditionally ("p" is a good way to do this), or via
  (not (or executing-kbd-macro noninteractive)).</p>
</td><td class="codes"><pre class="brush: clojure">(defun called-interactively-p (kind)
  nil)</pre></td></tr><tr><td class="docs"><p>Run HOOK with the specified arguments ARGS.
  HOOK should be a symbol, a hook variable.  If HOOK has a non-nil
  value, that value may be a function or a list of functions to be
  called to run the hook.  If the value is a function, it is called with
  the given arguments and its return value is returned.  If it is a list
  of functions, those functions are called, in order,
  with the given arguments ARGS.
  It is best not to depend on the value returned by `run-hook-with-args',
  as that may change.</p>

<p>  Do not use `make-local-variable' to make a hook variable buffer-local.
  Instead, use `add-hook' and specify t for the LOCAL argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defun run-hook-with-args (hook &amp;rest args)
  (when-let [hook (el/global hook)]
    (let [hook @hook]
      (doall (map #(c/apply funcall % args) (if (fn? hook) [hook] hook))))))</pre></td></tr><tr><td class="docs"><p>Call first argument as a function, passing remaining arguments to it.
  Return the value that function returns.
  Thus, (funcall 'cons 'x 'y) returns (x . y).</p>
</td><td class="codes"><pre class="brush: clojure">(defun funcall (function &amp;rest arguments)
  (apply function arguments))</pre></td></tr><tr><td class="docs"><p>Run HOOK, passing each function through WRAP-FUNCTION.
  I.e. instead of calling each function FUN directly with arguments ARGS,
  it calls WRAP-FUNCTION with arguments FUN and ARGS.
  As soon as a call to WRAP-FUNCTION returns non-nil, `run-hook-wrapped'
  aborts and returns that value.</p>
</td><td class="codes"><pre class="brush: clojure">(defun run-hook-wrapped (hook wrap-function &amp;rest args))</pre></td></tr><tr><td class="docs"><p>This function is obsolete since 23.2;
  use `called-interactively-p' instead.</p>

<p>  Return t if the containing function was run directly by user input.
  This means that the function was called with `call-interactively'
  (which includes being called as the binding of a key)
  and input is currently coming from the keyboard (not a keyboard macro),
  and Emacs is not running in batch mode (`noninteractive' is nil).</p>

<p>  The only known proper use of `interactive-p' is in deciding whether to
  display a helpful message, or how to display it.  If you're thinking
  of using it for any other purpose, it is quite likely that you're
  making a mistake.  Think: what do you want to do when the command is
  called from a keyboard macro?</p>

<p>  To test whether your function was called with `call-interactively',
  either (i) add an extra optional argument and give it an `interactive'
  spec that specifies non-nil unconditionally (such as "p"); or (ii)
  use `called-interactively-p'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun interactive-p ())</pre></td></tr><tr><td class="docs"><p>Make NEW-ALIAS a variable alias for symbol BASE-VARIABLE.
  Aliased variables always have the same value; setting one sets the other.
  Third arg DOCSTRING, if non-nil, is documentation for NEW-ALIAS.  If it is
  omitted or nil, NEW-ALIAS gets the documentation string of BASE-VARIABLE,
  or of the variable at the end of the chain of aliases, if BASE-VARIABLE is
  itself an alias.  If NEW-ALIAS is bound, and BASE-VARIABLE is not,
  then the value of BASE-VARIABLE is set to that of NEW-ALIAS.
  The return value is BASE-VARIABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun defvaralias (new-alias base-variable &amp;optional docstring)
  (if-let [base (el/global base-variable)]
    (el/defvar-helper* 'deuce.emacs-lisp.globals new-alias
      @base (or docstring (-&gt; base meta :doc)))
    (when-let [new (el/global new-alias)]
      (el/defvar-helper* 'deuce.emacs-lisp.globals base-variable
        @new (or docstring (-&gt; new meta :doc)))))
  base-variable)</pre></td></tr><tr><td class="docs"><p>Run HOOK with the specified arguments ARGS.
  HOOK should be a symbol, a hook variable.  If HOOK has a non-nil
  value, that value may be a function or a list of functions to be
  called to run the hook.  If the value is a function, it is called with
  the given arguments and its return value is returned.
  If it is a list of functions, those functions are called, in order,
  with the given arguments ARGS, until one of them
  returns a non-nil value.  Then we return that value.
  However, if they all return nil, we return nil.</p>

<p>  Do not use `make-local-variable' to make a hook variable buffer-local.
  Instead, use `add-hook' and specify t for the LOCAL argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defun run-hook-with-args-until-success (hook &amp;rest args)
  (some identity (apply run-hook-with-args hook args)))</pre></td></tr><tr><td class="docs"><p>Print a trace of Lisp function calls currently active.
  Output stream used is value of `standard-output'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun backtrace ()
  (interactive))</pre></td></tr><tr><td class="docs"><p>Run HOOK with the specified arguments ARGS.
  HOOK should be a symbol, a hook variable.  If HOOK has a non-nil
  value, that value may be a function or a list of functions to be
  called to run the hook.  If the value is a function, it is called with
  the given arguments and its return value is returned.
  If it is a list of functions, those functions are called, in order,
  with the given arguments ARGS, until one of them returns nil.
  Then we return nil.  However, if they all return non-nil, we return non-nil.</p>

<p>  Do not use `make-local-variable' to make a hook variable buffer-local.
  Instead, use `add-hook' and specify t for the LOCAL argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defun run-hook-with-args-until-failure (hook &amp;rest args)
  (or (some (complement identity) (apply run-hook-with-args hook args))
      true))</pre></td></tr><tr><td class="docs"><p>Call FUNCTION with our remaining args, using our last arg as list of args.
  Then return the value FUNCTION returns.
  Thus, (apply '+ 1 2 '(3 4)) returns 10.</p>
</td><td class="codes"><pre class="brush: clojure">(defun apply (function &amp;rest arguments)
  (let [rest (last arguments)]
    (el/check-type 'listp rest)
    (c/apply (cond (symbol? function) (data/symbol-function function)
                   (data/listp function) (eval function)
                   :else function) (c/apply alloc/list (concat (butlast arguments) rest)))))</pre></td></tr><tr><td class="docs"><p>Run each hook in HOOKS.
  Each argument should be a symbol, a hook variable.
  These symbols are processed in the order specified.
  If a hook symbol has a non-nil value, that value may be a function
  or a list of functions to be called to run the hook.
  If the value is a function, it is called with no arguments.
  If it is a list, the elements are called, in order, with no arguments.</p>

<p>  Major modes should not use this function directly to run their mode
  hook; they should use `run-mode-hooks' instead.</p>

<p>  Do not use `make-local-variable' to make a hook variable buffer-local.
  Instead, use `add-hook' and specify t for the LOCAL argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defun run-hooks (&amp;rest hooks)
  (doseq [hook hooks]
    (run-hook-with-args hook)))</pre></td></tr><tr><td class="docs"><p>Evaluate FORM and return its value.
  If LEXICAL is t, evaluate using lexical scoping.</p>
</td><td class="codes"><pre class="brush: clojure">(defun eval (form &amp;optional lexical)
  (el/eval form lexical))</pre></td></tr><tr><td class="docs"><p>Set the debug-on-exit flag of eval frame LEVEL levels down to FLAG.
  The debugger is entered when that frame exits, if the flag is non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun backtrace-debug (level flag))</pre></td></tr><tr><td class="docs"><p>Return the function and arguments NFRAMES up from current execution point.
  If that frame has not evaluated the arguments yet (or is a special form),
  the value is (nil FUNCTION ARG-FORMS...).
  If that frame has evaluated its arguments and called its function already,
  the value is (t FUNCTION ARG-VALUES...).
  A &amp;rest arg is represented as the tail of the list ARG-VALUES.
  FUNCTION is whatever was supplied as car of evaluated list,
  or a lambda expression for macro calls.
  If NFRAMES is more than the number of frames, the value is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun backtrace-frame (nframes))</pre></td></tr><tr><td class="docs"><p>Non-nil if FUNCTION makes provisions for interactive calling.
  This means it contains a description for how to read arguments to give it.
  The value is nil for an invalid function or a symbol with no function
  definition.</p>

<p>  Interactively callable functions include strings and vectors (treated
  as keyboard macros), lambda-expressions that contain a top-level call
  to <code>interactive', autoload definitions made by</code>autoload' with non-nil
  fourth argument, and some of the built-in functions of Lisp.</p>

<p>  Also, a symbol satisfies `commandp' if its function definition does so.</p>

<p>  If the optional argument FOR-CALL-INTERACTIVELY is non-nil,
  then strings and vectors are not accepted.</p>
</td><td class="codes"><pre class="brush: clojure">(defun commandp (function &amp;optional for-call-interactively)
  (if (or (data/stringp function) (data/vectorp function))
    (when-not for-call-interactively true)
    (when-let [f (el/fun function)]
      (when (contains? (meta f) :interactive)
        true))))</pre></td></tr><tr><td class="docs"><p>Return result of expanding macros at top level of FORM.
  If FORM is not a macro call, it is returned unchanged.
  Otherwise, the macro is expanded and the expansion is considered
  in place of FORM.  When a non-macro-call results, it is returned.</p>

<p>  The second optional arg ENVIRONMENT specifies an environment of macro
  definitions to shadow the loaded ones for use in file byte-compilation.</p>
</td><td class="codes"><pre class="brush: clojure">(defun macroexpand (form &amp;optional environment)
  ;; Not sure how this is supposed to work even after reading eval.c, attempts to mimic observed behavior.
  ;; It is used in conjunction with cl-macroexpand-all, and should not expand into &quot;raw&quot; Clojure.
  (let [shadow (into {} (map #(vector (data/car %) (data/cdr %)) environment))
        shadow #(shadow % (shadow (str %)))
        unshadowed-form ((fn shadow-walker [form]
                           (if-let [expander (shadow form)]
                             (if (= '(true) (data/cdr-safe expander))
                               (cons (first (data/car expander))
                                     (map #(list 'quote %) (rest (data/car expander))))
                               (expander form))
                             (if (and (seq? form)
                                      (not= 'quote (first form)))
                               (cons/maybe-seq (map shadow-walker form))
                               form))) form)
        expansion (if-let [m  (and (seq? form) (-&gt; (el/fun (first form)) meta))]
                    (if (and (:macro m) (= (the-ns 'deuce.emacs-lisp) (:ns m)))
                      unshadowed-form
                      (macroexpand-1 unshadowed-form))
                    unshadowed-form)]
    ;; Protect against eq check in cl-macroexpand-all
    (if (= form expansion)
      form
      expansion)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.cmds" name="deuce.emacs.cmds"><h1 class="project-name">deuce.emacs.cmds</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.cmds
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns]
            [deuce.emacs.eval :as eval]
            [deuce.emacs.indent :as indent])
  (:import [java.util Arrays]
           [deuce.emacs.data Buffer BufferText])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Hook run at the end of `self-insert-command'.
  This is run after inserting the character.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar post-self-insert-hook nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private line-indexes [s]
  (loop [idx 0 acc [0]]
    (let [idx (.indexOf (str s) (int \newline) idx)]
      (if (&gt;= idx 0)
        (recur (inc idx) (conj acc (inc idx)))
        (int-array acc)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private pos-to-line [line-indexes pos]
  (let [pos (Arrays/binarySearch ^ints line-indexes (int pos))]
    (if (neg? pos) (- (- pos) 2) pos)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private point-coords
  ([^Buffer buffer] (point-coords (line-indexes (str (.beg ^BufferText (.text buffer)))) (dec @(.pt buffer))))
  ([line-indexes offset]
      (let [pos-to-line (partial pos-to-line line-indexes)
            line (max (pos-to-line offset) 0)
            col (- offset (aget ^ints line-indexes line))]
        [col line])))</pre></td></tr><tr><td class="docs"><p>Now I've seen some convoluted Clojure in my days...
Emacs "remembers" how long the line you started from and tries to "regain" that column when moving around.
With some luck this is taken care of by some Emacs Lisp somewhere (right..).</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private move-lines [s offset lines]
  (let [line-indexes (line-indexes s)
        [col line] (point-coords line-indexes offset)
        offset-of-line #(cond
                         (&gt;= % (count line-indexes)) (count s)
                         (neg? %) 0
                         :else (aget ^ints line-indexes %))
        new-line (+ line lines)
        line-offset (offset-of-line new-line)
        empty-line? (zero? (- (offset-of-line (inc new-line)) line-offset))
        new-offset (cond
                    (neg? new-line) 0
                    empty-line? (inc line-offset)
                    :else (min (+ line-offset col)
                               (dec (offset-of-line (inc new-line)))))]
    (editfns/goto-char (inc new-offset))
    (cond
     (&lt; (count line-indexes) new-line) (- new-line (count line-indexes))
     (neg? new-line) new-line
     :else 0)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare forward-char)</pre></td></tr><tr><td class="docs"><p>Move N lines forward (backward if N is negative).
  Precisely, if point is on line I, move to the start of line I + N
  ("start of line" in the logical order).
  If there isn't room, go as far as possible (no error).
  Returns the count of lines left to move.  If moving forward,
  that is N - number of lines moved; if backward, N + number moved.
  With positive N, a non-empty line at the end counts as one line
  successfully moved (for the return value).</p>
</td><td class="codes"><pre class="brush: clojure">(defun forward-line (&amp;optional n)
  (interactive &quot;^p&quot;)
  (move-lines (editfns/buffer-string) (dec (editfns/point))
              (el/check-type 'integerp (or n 1))))</pre></td></tr><tr><td class="docs"><p>Move point N characters forward (backward if N is negative).
  On reaching end or beginning of buffer, stop and signal error.</p>

<p>  Depending on the bidirectional context, the movement may be to the
  right or to the left on the screen.  This is in contrast with
  <right>, which see.</p>
</td><td class="codes"><pre class="brush: clojure">(defun forward-char (&amp;optional n)
  (interactive &quot;^p&quot;)
  (editfns/goto-char (+ (editfns/point) (el/check-type 'integerp (or n 1)))))</pre></td></tr><tr><td class="docs"><p>This function is obsolete since 23.1;
  use (+ (point) N) instead.</p>

<p>  Return buffer position N characters after (before if N negative) point.</p>
</td><td class="codes"><pre class="brush: clojure">(defun forward-point (n)
  (+ (editfns/point) n))</pre></td></tr><tr><td class="docs"><p>Insert the character you type.
  Whichever character you type to run this command is inserted.
  Before insertion, `expand-abbrev' is executed if the inserted character does
  not have word syntax and the previous character in the buffer does.
  After insertion, the value of `auto-fill-function' is called if the
  `auto-fill-chars' table has a non-nil value for the inserted character.
  At the end, it runs `post-self-insert-hook'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun self-insert-command (n)
  (interactive &quot;p&quot;)
  (editfns/insert (apply str (repeat n (char (data/symbol-value 'last-command-event)))))
  (eval/run-hooks 'post-self-insert-hook))</pre></td></tr><tr><td class="docs"><p>Move point N characters backward (forward if N is negative).
  On attempt to pass beginning or end of buffer, stop and signal error.</p>

<p>  Depending on the bidirectional context, the movement may be to the
  right or to the left on the screen.  This is in contrast with
  <left>, which see.</p>
</td><td class="codes"><pre class="brush: clojure">(defun backward-char (&amp;optional n)
  (interactive &quot;^p&quot;)
  (editfns/goto-char (- (editfns/point) (el/check-type 'integerp (or n 1)))))</pre></td></tr><tr><td class="docs"><p>Move point to beginning of current line (in the logical order).
  With argument N not nil or 1, move forward N - 1 lines first.
  If point reaches the beginning or end of buffer, it stops there.</p>

<p>  This function constrains point to the current field unless this moves
  point to a different line than the original, unconstrained result.
  If N is nil or 1, and a front-sticky field starts at point, the point
  does not move.  To ignore field boundaries bind
  <code>inhibit-field-text-motion' to t, or use the</code>forward-line' function
  instead.  For instance, `(forward-line 0)' does the same thing as
  `(beginning-of-line)', except that it ignores field boundaries.</p>
</td><td class="codes"><pre class="brush: clojure">(defun beginning-of-line (&amp;optional n)
  (interactive &quot;^p&quot;)
  (when-not (contains? #{nil 1} n)
    (forward-line n))
  (let [bol (.lastIndexOf (str (editfns/buffer-substring 1 (editfns/point))) (int \newline))]
    (if (= -1 bol)
      (editfns/goto-char 1)
      (editfns/goto-char (+ bol 2)))))</pre></td></tr><tr><td class="docs"><p>Delete the following N characters (previous if N is negative).
  Optional second arg KILLFLAG non-nil means kill instead (save in kill ring).
  Interactively, N is the prefix arg, and KILLFLAG is set if
  N was explicitly specified.</p>

<p>  The command `delete-forward-char' is preferable for interactive use.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-char (n &amp;optional killflag)
  (interactive &quot;p\nP&quot;)
  (apply editfns/delete-region (sort [(editfns/point) (min (+ (editfns/point) n) 1)])))</pre></td></tr><tr><td class="docs"><p>Move point to end of current line (in the logical order).
  With argument N not nil or 1, move forward N - 1 lines first.
  If point reaches the beginning or end of buffer, it stops there.
  To ignore intangibility, bind `inhibit-point-motion-hooks' to t.</p>

<p>  This function constrains point to the current field unless this moves
  point to a different line than the original, unconstrained result.  If
  N is nil or 1, and a rear-sticky field ends at point, the point does
  not move.  To ignore field boundaries bind `inhibit-field-text-motion'
  to t.</p>
</td><td class="codes"><pre class="brush: clojure">(defun end-of-line (&amp;optional n)
  (interactive &quot;^p&quot;)
  (when-not (contains? #{nil 1} n)
    (forward-line n))
  (let [eol (.indexOf (str (editfns/buffer-string)) (int \newline) (int (dec (editfns/point))))]
    (if (= -1 eol)
      (editfns/goto-char (editfns/point-max))
      (editfns/goto-char (inc eol)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.dispnew" name="deuce.emacs.dispnew"><h1 class="project-name">deuce.emacs.dispnew</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.dispnew
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [deuce.emacs.frame :as frame]
            [deuce.emacs-lisp.parser :as parser])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Non-nil means no need to redraw entire frame after suspending.
  A non-nil value is useful if the terminal can automatically preserve
  Emacs's frame display when you reenter Emacs.
  It is up to you to set this variable if your terminal can do that.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar no-redraw-on-reenter nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means put cursor in minibuffer, at end of any message there.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar cursor-in-echo-area nil)</pre></td></tr><tr><td class="docs"><p>Display table to use for buffers that specify none.
  See `buffer-display-table' for more information.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar standard-display-table nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means try to flash the frame to represent a bell.</p>

<p>  See also `ring-bell-function'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar visible-bell nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means display update isn't paused when input is detected.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar redisplay-dont-pause nil)</pre></td></tr><tr><td class="docs"><p>Period in seconds between checking for input during redisplay.
  This has an effect only if `redisplay-dont-pause' is nil; in that
  case, arriving input preempts redisplay until the input is processed.
  If the value is nil, redisplay is never preempted.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar redisplay-preemption-period nil)</pre></td></tr><tr><td class="docs"><p>The version number of the window system in use.
  For X windows, this is 11.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar window-system-version nil)</pre></td></tr><tr><td class="docs"><p>Name of the window system that Emacs uses for the first frame.
  The value is a symbol:
   nil for a termcap frame (a character-only terminal),
   'x' for an Emacs frame that is really an X window,
   'w32' for an Emacs frame that is a window on MS-Windows display,
   'ns' for an Emacs frame on a GNUstep or Macintosh Cocoa display,
   'pc' for a direct-write MS-DOS frame.</p>

<p>  Use of this variable as a boolean is deprecated.  Instead,
  use <code>display-graphic-p' or any of the other</code>display-*-p'
  predicates which report frame's specific UI-related capabilities.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar initial-window-system nil)</pre></td></tr><tr><td class="docs"><p>The output baud rate of the terminal.
  On most systems, changing this value will affect the amount of padding
  and the other strategic decisions made during redisplay.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar baud-rate nil)</pre></td></tr><tr><td class="docs"><p>Table defining how to output a glyph code to the frame.
  If not nil, this is a vector indexed by glyph code to define the glyph.
  Each element can be:
   integer: a glyph code which this glyph is an alias for.
   string: output this glyph using that string (not impl. in X windows).
   nil: this glyph mod 524288 is the code of a character to output,
      and this glyph / 524288 is the face number (see `face-id') to use
      while outputting it.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar glyph-table nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means invert the entire frame display.
  This means everything is in inverse video which otherwise would not be.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inverse-video nil)</pre></td></tr><tr><td class="docs"><p>Start writing all terminal output to FILE as well as the terminal.
  FILE = nil means just close any termscript file currently open.</p>
</td><td class="codes"><pre class="brush: clojure">(defun open-termscript (file)
  (interactive &quot;FOpen termscript file: &quot;))</pre></td></tr><tr><td class="docs"><p>Beep, or flash the screen.
  Also, unless an argument is given,
  terminate any keyboard macro currently executing.</p>
</td><td class="codes"><pre class="brush: clojure">(defun ding (&amp;optional arg))</pre></td></tr><tr><td class="docs"><p>Set the cursor-visibility flag of WINDOW to SHOW.
  WINDOW nil means use the selected window.  SHOW non-nil means
  show a cursor in WINDOW in the next redisplay.  SHOW nil means
  don't show a cursor.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-show-cursor (window show))</pre></td></tr><tr><td class="docs"><p>Clear frame FRAME and output again what is supposed to appear on it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun redraw-frame (frame))</pre></td></tr><tr><td class="docs"><p>Return non-nil if the frame and buffer state appears to have changed.
  VARIABLE is a variable name whose value is either nil or a state vector
  that will be updated to contain all frames and buffers,
  aside from buffers whose names start with space,
  along with the buffers' read-only and modified flags.  This allows a fast
  check to see whether buffer menus might need to be recomputed.
  If this function returns non-nil, it updates the internal vector to reflect
  the current state.</p>

<p>  If VARIABLE is nil, an internal variable is used.  Users should not
  pass nil for VARIABLE.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-or-buffer-changed-p (&amp;optional variable))</pre></td></tr><tr><td class="docs"><p>Perform redisplay.
  Optional arg FORCE, if non-nil, prevents redisplay from being
  preempted by arriving input, even if `redisplay-dont-pause' is nil.
  If `redisplay-dont-pause' is non-nil (the default), redisplay is never
  preempted by arriving input, so FORCE does nothing.</p>

<p>  Return t if redisplay was performed, nil if redisplay was preempted
  immediately by pending input.</p>
</td><td class="codes"><pre class="brush: clojure">(defun redisplay (&amp;optional force))</pre></td></tr><tr><td class="docs"><p>Value is non-nil if next redisplay will display a cursor in WINDOW.
  WINDOW nil or omitted means report on the selected window.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-show-cursor-p (&amp;optional window))</pre></td></tr><tr><td class="docs"><p>Value is last nonminibuffer frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun last-nonminibuffer-frame ()
  (frame/selected-frame))</pre></td></tr><tr><td class="docs"><p>Send STRING to the terminal without alteration.
  Control characters in STRING will have terminal-dependent effects.</p>

<p>  Optional parameter TERMINAL specifies the tty terminal device to use.
  It may be a terminal object, a frame, or nil for the terminal used by
  the currently selected frame.  In batch mode, STRING is sent to stdout
  when TERMINAL is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun send-string-to-terminal (string &amp;optional terminal)
  (.print System/out (parser/resolve-control-chars string))
  (.flush System/out))</pre></td></tr><tr><td class="docs"><p>Clear and redisplay all visible frames.</p>
</td><td class="codes"><pre class="brush: clojure">(defun redraw-display ()
  (interactive))</pre></td></tr><tr><td class="docs"><p>Pause, without updating display, for SECONDS seconds.
  SECONDS may be a floating-point value, meaning that you can wait for a
  fraction of a second.  Optional second arg MILLISECONDS specifies an
  additional wait period, in milliseconds; this may be useful if your
  Emacs was built without floating point support.
  (Not all operating systems support waiting for a fraction of a second.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun sleep-for (seconds &amp;optional milliseconds)
  (Thread/sleep (+ (* 1000 seconds) (or milliseconds) 0)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.keymap" name="deuce.emacs.keymap"><h1 class="project-name">deuce.emacs.keymap</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.keymap
  (:use [deuce.emacs-lisp :only (defun defvar setq) :as el])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [clojure.walk :as w]
            [deuce.emacs-lisp.cons :as cons]
            [deuce.emacs-lisp.globals :as globals]
            [deuce.emacs-lisp.parser :as parser]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.chartab :as chartab]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns]
            [deuce.emacs.fns :as fns]
            [deuce.emacs.textprop :as textprop])
  (:import [deuce.emacs.data CharTable])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>List of keymap alists to use for emulations modes.
  It is intended for modes or packages using multiple minor-mode keymaps.
  Each element is a keymap alist just like `minor-mode-map-alist', or a
  symbol with a variable binding which is a keymap alist, and it is used
  the same way.  The "active" keymaps in each alist are used before
  <code>minor-mode-map-alist' and</code>minor-mode-overriding-map-alist'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar emulation-mode-map-alists nil)</pre></td></tr><tr><td class="docs"><p>Local keymap for the minibuffer when spaces are not allowed.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-local-ns-map nil)</pre></td></tr><tr><td class="docs"><p>Preferred modifier key to use for `where-is'.
  When a single binding is requested, `where-is' will return one that
  uses this modifier key if possible.  If nil, or if no such binding
  exists, bindings using keys without modifiers (or only with meta) will
  be preferred.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar where-is-preferred-modifier nil)</pre></td></tr><tr><td class="docs"><p>Alist of keymaps to use for minor modes, in current major mode.
  This variable is an alist just like `minor-mode-map-alist', and it is
  used the same way (and before `minor-mode-map-alist'); however,
  it is provided for major modes to bind locally.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minor-mode-overriding-map-alist nil)</pre></td></tr><tr><td class="docs"><p>Alist of keymaps to use for minor modes.
  Each element looks like (VARIABLE . KEYMAP); KEYMAP is used to read
  key sequences and look up bindings if VARIABLE's value is non-nil.
  If two active keymaps bind the same key, the keymap appearing earlier
  in the list takes precedence.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minor-mode-map-alist nil)</pre></td></tr><tr><td class="docs"><p>List of commands given new key bindings recently.
  This is used for internal purposes during Emacs startup;
  don't alter it yourself.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar define-key-rebound-commands true)</pre></td></tr><tr><td class="docs"><p>Default keymap to use when reading from the minibuffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar minibuffer-local-map nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fns/put 'key-map 'char-table-extra-slots 0)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ^:dynamic *current-global-map* (atom nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare current-global-map current-minor-mode-maps keymapp keymap-parent set-keymap-parent lookup-key)</pre></td></tr><tr><td class="docs"><p>Construct and return a new sparse keymap.
  Its car is `keymap' and its cdr is an alist of (CHAR . DEFINITION),
  which binds the character CHAR to DEFINITION, or (SYMBOL . DEFINITION),
  which binds the function key or mouse event SYMBOL to DEFINITION.
  Initially the alist is nil.</p>

<p>  The optional arg STRING supplies a menu name for the keymap
  in case you use it as a menu with `x-popup-menu'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-sparse-keymap (&amp;optional string)
  (if string
    (alloc/list 'keymap string)
    (alloc/list 'keymap)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private binding-this-map [keymap key]
  (let [char-table (second keymap)
        alist (if (data/char-table-p char-table) (fns/nthcdr 2 keymap) (data/cdr keymap))]
    (if (and (data/char-table-p (second keymap))
             (data/numberp key)
             (&lt; (int key) (fns/length (second keymap))))
      (data/aref char-table key)
      (data/cdr (fns/assoc key alist)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private define-key-this-map [keymap key def]
  (let [char-table (second keymap)
        alist (if (data/char-table-p char-table) (fns/nthcdr 2 keymap) (data/cdr keymap))]
    (if (and (data/char-table-p char-table)
             (data/numberp key)
             (&lt; (int key) (fns/length char-table)))
      (data/aset char-table key def)
      (if-let [existing (fns/assoc key alist)]
        (data/setcdr existing def)
        (data/setcdr (if (data/char-table-p char-table) (data/cdr keymap) keymap)
                     (alloc/cons (alloc/cons key def) alist))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private resolve-def [def]
  (cond (data/symbolp def)
   (try
     (let [maybe-keymap (data/symbol-function def)]
       (if (keymapp maybe-keymap)
         maybe-keymap
         def))
     (catch RuntimeException _
       def))
   (and (data/consp def)
        (string? (first def)))
   (data/cdr def)
   (and (data/consp def)
        (keymapp (first def)))
   (lookup-key (data/car def) (data/cdr def))
   :else def))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private binding-map [keymap key]
  (let [submap-or-binding (resolve-def (binding-this-map keymap (first key)))]
    (if-let [key (next key)]
      (if (keymapp submap-or-binding)
        (recur submap-or-binding key)
        (count key))
      submap-or-binding)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private define-key-internal [keymap key def]
  (let [submap-or-binding (resolve-def (binding-this-map keymap (first key)))
        submap-or-binding (if-not submap-or-binding
                            (let [def (if (next key) (make-sparse-keymap) def)]
                              (define-key-this-map keymap
                                (first key) def)
                              def)
                            submap-or-binding)]
    (if-let [key (next key)]
      (if (keymapp submap-or-binding)
        (recur submap-or-binding key def)
        (throw (IllegalArgumentException.)))
      (define-key-this-map keymap (first key) def))))</pre></td></tr><tr><td class="docs"><p>In KEYMAP, define key sequence KEY as DEF.
  KEYMAP is a keymap.</p>

<p>  KEY is a string or a vector of symbols and characters, representing a
  sequence of keystrokes and events.  Non-ASCII characters with codes
  above 127 (such as ISO Latin-1) can be represented by vectors.
  Two types of vector have special meanings:
   [remap COMMAND] remaps any key binding for COMMAND.
   [t] creates a default definition, which applies to any event with no
      other definition in KEYMAP.</p>

<p>  DEF is anything that can be a key's definition:
   nil (means key is undefined in this keymap),
   a command (a Lisp function suitable for interactive calling),
   a string (treated as a keyboard macro),
   a keymap (to define a prefix key),
   a symbol (when the key is looked up, the symbol will stand for its
      function definition, which should at that time be one of the above,
      or another symbol whose function definition is used, etc.),
   a cons (STRING . DEFN), meaning that DEFN is the definition
      (DEFN should be a valid definition in its own right),
   or a cons (MAP . CHAR), meaning use definition of CHAR in keymap MAP,
   or an extended menu item definition.
   (See info node `(elisp)Extended Menu Items'.)</p>

<p>  If KEYMAP is a sparse keymap with a binding for KEY, the existing
  binding is altered.  If there is no binding for KEY, the new pair
  binding KEY to DEF is added at the front of KEYMAP.</p>
</td><td class="codes"><pre class="brush: clojure">(defun define-key (keymap key def)
  (let [real-key key
        key (if (string? key)
              (parser/parse-characters key (data/symbol-value 'meta-prefix-char))
              (el/check-type 'arrayp key))
        keymap (if (data/symbolp keymap) (data/symbol-value keymap) keymap)]
    (try
      (define-key-internal keymap key def)
      (catch IllegalArgumentException e
        (el/throw* 'error (format &quot;Key sequence %s starts with non-prefix key %s&quot;
                                  (s/join &quot; &quot; key) (s/join &quot; &quot; (butlast key))))))
    def))</pre></td></tr><tr><td class="docs"><p>Return a copy of the keymap KEYMAP.
  The copy starts out with the same definitions of KEYMAP,
  but changing either the copy or KEYMAP does not affect the other.
  Any key definitions that are subkeymaps are recursively copied.
  However, a key definition which is a symbol whose definition is a keymap
  is not copied.</p>
</td><td class="codes"><pre class="brush: clojure">(defun copy-keymap (keymap)
  (el/check-type 'keymapp keymap)
  (letfn [(copy [x]
            (condp some [x]
              keymapp (copy-keymap x)
              seq? (cons/maybe-seq (map copy x))
              data/char-table-p (let [x ^CharTable x]
                                  (CharTable. (.defalt x)
                                              (atom @(.parent x))
                                              (.purpose x)
                                              (let [contents (object-array (count (.contents x)))]
                                                (System/arraycopy (.contents x) 0  contents 0 (count (.contents x)))
                                                contents)
                                              (object-array (.extras x))))
              x))]
    (let [parent (keymap-parent keymap)
          keymap (apply alloc/list keymap)]
      (set-keymap-parent keymap nil)
      (doto (cons/maybe-seq (map copy keymap))
        (set-keymap-parent parent)))))</pre></td></tr><tr><td class="docs"><p>Call FUNCTION once for each event binding in KEYMAP.
  FUNCTION is called with two arguments: the event that is bound, and
  the definition it is bound to.  The event may be a character range.
  If KEYMAP has a parent, this function returns it without processing it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun map-keymap-internal (function keymap))</pre></td></tr><tr><td class="docs"><p>Return current buffer's local keymap, or nil if it has none.
  Normally the local keymap is set by the major mode with `use-local-map'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-local-map ()
  (when (data/boundp 'keymap)
    (buffer/buffer-local-value 'keymap (buffer/current-buffer))))</pre></td></tr><tr><td class="docs"><p>Return list of keys that invoke DEFINITION.
  If KEYMAP is a keymap, search only KEYMAP and the global keymap.
  If KEYMAP is nil, search all the currently active keymaps, except
   for `overriding-local-map' (which is ignored).
  If KEYMAP is a list of keymaps, search only those keymaps.</p>

<p>  If optional 3rd arg FIRSTONLY is non-nil, return the first key sequence found,
  rather than a list of all possible key sequences.
  If FIRSTONLY is the symbol `non-ascii', return the first binding found,
  no matter what it is.
  If FIRSTONLY has another non-nil value, prefer bindings
  that use the modifier key specified in `where-is-preferred-modifier'
  (or their meta variants) and entirely reject menu bindings.</p>

<p>  If optional 4th arg NOINDIRECT is non-nil, don't follow indirections
  to other keymaps or slots.  This makes it possible to search for an
  indirect definition itself.</p>

<p>  The optional 5th arg NO-REMAP alters how command remapping is handled:</p>

<ul>
<li><p>If another command OTHER-COMMAND is remapped to DEFINITION, normally
search for the bindings of OTHER-COMMAND and include them in the
returned list.  But if NO-REMAP is non-nil, include the vector
[remap OTHER-COMMAND] in the returned list instead, without
searching for those other bindings.</p></li>
<li><p>If DEFINITION is remapped to OTHER-COMMAND, normally return the
bindings for OTHER-COMMAND.  But if NO-REMAP is non-nil, return the
bindings for DEFINITION instead, ignoring its remapping.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defun where-is-internal (definition &amp;optional keymap firstonly noindirect no-remap))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a keymap.</p>

<p>  A keymap is a list (keymap . ALIST),
  or a symbol whose function definition is itself a keymap.
  ALIST elements look like (CHAR . DEFN) or (SYMBOL . DEFN);
  a vector of densely packed bindings for small character codes
  is also allowed as an element.</p>
</td><td class="codes"><pre class="brush: clojure">(defun keymapp (object)
  (and (data/consp object) (= 'keymap (data/car object))))</pre></td></tr><tr><td class="docs"><p>Return a pretty description of file-character CHARACTER.
  Control characters turn into "^char", etc.  This differs from
  `single-key-description' which turns them into "C-char".
  Also, this function recognizes the 2**7 bit as the Meta character,
  whereas `single-key-description' uses the 2**27 bit for Meta.
  See Info node `(elisp)Describing Characters' for examples.</p>
</td><td class="codes"><pre class="brush: clojure">(defun text-char-description (character))</pre></td></tr><tr><td class="docs"><p>Return a list of the currently active keymaps.
  OLP if non-nil indicates that we should obey `overriding-local-map' and
  `overriding-terminal-local-map'.  POSITION can specify a click position
  like in the respective argument of `key-binding'.</p>

<p>http://www.gnu.org/software/emacs/manual/html_node/elisp/Searching-Keymaps.html
"Here is a pseudo-Lisp description of the order and conditions for searching them:"
(or (cond
     (overriding-terminal-local-map
      (find-in overriding-terminal-local-map))
     (overriding-local-map
      (find-in overriding-local-map))
     ((or (find-in (get-char-property (point) 'keymap))
          (find-in temp-map)
          (find-in-any emulation-mode-map-alists)
          (find-in-any minor-mode-overriding-map-alist)
          (find-in-any minor-mode-map-alist)
          (if (get-text-property (point) 'local-map)
              (find-in (get-char-property (point) 'local-map))
            (find-in (current-local-map))))))
    (find-in (current-global-map)))
"The function finally found might also be remapped. See Remapping Commands."</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-active-maps (&amp;optional olp position)
  (cons/maybe-seq (remove nil? (concat (when olp [(or (data/symbol-value 'overriding-terminal-local-map)
                                                      (data/symbol-value 'overriding-local-map))])
                                       (current-minor-mode-maps)
                                       [(textprop/get-char-property (or position (editfns/point)) 'local-map)
                                        (current-local-map)
                                        (current-global-map)]))))</pre></td></tr><tr><td class="docs"><p>Return the binding for command KEY in current keymaps.
  KEY is a string or vector, a sequence of keystrokes.
  The binding is probably a symbol with a function definition.</p>

<p>  Normally, `key-binding' ignores bindings for t, which act as default
  bindings, used when nothing else in the keymap applies; this makes it
  usable as a general function for probing keymaps.  However, if the
  optional second argument ACCEPT-DEFAULT is non-nil, `key-binding' does
  recognize the default bindings, just as `read-key-sequence' does.</p>

<p>  Like the normal command loop, `key-binding' will remap the command
  resulting from looking up KEY by looking up the command in the
  current keymaps.  However, if the optional third argument NO-REMAP
  is non-nil, `key-binding' returns the unmapped command.</p>

<p>  If KEY is a key sequence initiated with the mouse, the used keymaps
  will depend on the clicked mouse position with regard to the buffer
  and possible local keymaps on strings.</p>

<p>  If the optional argument POSITION is non-nil, it specifies a mouse
  position as returned by <code>event-start' and</code>event-end', and the lookup
  occurs in the keymaps associated with it instead of KEY.  It can also
  be a number or marker, in which case the keymap properties at the
  specified buffer position instead of point are used.</p>
</td><td class="codes"><pre class="brush: clojure">(defun key-binding (key &amp;optional accept-default no-remap position)
  (some identity (remove number? (map #(lookup-key % key accept-default) (current-active-maps nil position)))))</pre></td></tr><tr><td class="docs"><p>Call FUNCTION once for each event binding in KEYMAP.
  FUNCTION is called with two arguments: the event that is bound, and
  the definition it is bound to.  The event may be a character range.</p>

<p>  If KEYMAP has a parent, the parent's bindings are included as well.
  This works recursively: if the parent has itself a parent, then the
  grandparent's bindings are also included and so on.</p>
</td><td class="codes"><pre class="brush: clojure">(defun map-keymap (function keymap)
  (el/check-type 'keymapp keymap)
  (apply alloc/list
         (map (fn [x] ((el/fun function) (data/car x) (data/cdr x)))
              (filter data/consp (data/cdr keymap)))))</pre></td></tr><tr><td class="docs"><p>Return the prompt-string of a keymap MAP.
  If non-nil, the prompt is shown in the echo-area
  when reading a key-sequence to be looked-up in this keymap.</p>
</td><td class="codes"><pre class="brush: clojure">(defun keymap-prompt (map)
  (first (filter string? (take-while (complement '#{keymap}) (next map)))))</pre></td></tr><tr><td class="docs"><p>Show all symbols whose names contain match for REGEXP.
  If optional 2nd arg PREDICATE is non-nil, (funcall PREDICATE SYMBOL) is done
  for each symbol and a symbol is mentioned only if that returns non-nil.
  Return list of symbols found.</p>
</td><td class="codes"><pre class="brush: clojure">(defun apropos-internal (regexp &amp;optional predicate))</pre></td></tr><tr><td class="docs"><p>Modify KEYMAP to set its parent map to PARENT.
  Return PARENT.  PARENT should be nil or another keymap.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-keymap-parent (keymap parent)
  (el/check-type 'keymapp keymap)
  (when parent (el/check-type 'keymapp parent))
  (loop [x keymap]
    (when x
      (if (keymapp (data/cdr x))
        (data/setcdr x nil)
        (recur (data/cdr x)))))
  (fns/nconc keymap parent)
  parent)</pre></td></tr><tr><td class="docs"><p>Return a list of keymaps for the minor modes of the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-minor-mode-maps ()
  (cons/maybe-seq (map data/cdr (filter (comp data/symbol-value data/car)
                                        (concat (data/symbol-value 'emulation-mode-map-alists)
                                                (data/symbol-value 'minor-mode-overriding-map-alist)
                                                (data/symbol-value 'minor-mode-map-alist))))))</pre></td></tr><tr><td class="docs"><p>Construct and return a new keymap, of the form (keymap CHARTABLE . ALIST).
  CHARTABLE is a char-table that holds the bindings for all characters
  without modifiers.  All entries in it are initially nil, meaning
  "command undefined".  ALIST is an assoc-list which holds bindings for
  function keys, mouse events, and any other things that appear in the
  input stream.  Initially, ALIST is nil.</p>

<p>  The optional arg STRING supplies a menu name for the keymap
  in case you use it as a menu with `x-popup-menu'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-keymap (&amp;optional string)
  (fns/nconc (alloc/list 'keymap (chartab/make-char-table 'keymap))
             (when string (alloc/list string))))</pre></td></tr><tr><td class="docs"><p>Insert the list of all defined keys and their definitions.
  The list is inserted in the current buffer, while the bindings are
  looked up in BUFFER.
  The optional argument PREFIX, if non-nil, should be a key sequence;
  then we display only bindings that start with that prefix.
  The optional argument MENUS, if non-nil, says to mention menu bindings.
  (Ordinarily these are omitted from the output.)</p>
</td><td class="codes"><pre class="brush: clojure">(defun describe-buffer-bindings (buffer &amp;optional prefix menus))</pre></td></tr><tr><td class="docs"><p>Find all keymaps accessible via prefix characters from KEYMAP.
  Returns a list of elements of the form (KEYS . MAP), where the sequence
  KEYS starting from KEYMAP gets you to MAP.  These elements are ordered
  so that the KEYS increase in length.  The first element is ([] . KEYMAP).
  An optional argument PREFIX, if non-nil, should be a key sequence;
  then the value includes only maps for prefixes that start with PREFIX.</p>
</td><td class="codes"><pre class="brush: clojure">(defun accessible-keymaps (keymap &amp;optional prefix))</pre></td></tr><tr><td class="docs"><p>In keymap KEYMAP, look up key sequence KEY.  Return the definition.
  A value of nil means undefined.  See doc of `define-key'
  for kinds of definitions.</p>

<p>  A number as value means KEY is "too long";
  that is, characters or symbols in it except for the last one
  fail to be a valid sequence of prefix characters in KEYMAP.
  The number is how many characters at the front of KEY
  it takes to reach a non-prefix key.</p>

<p>  Normally, `lookup-key' ignores bindings for t, which act as default
  bindings, used when nothing else in the keymap applies; this makes it
  usable as a general function for probing keymaps.  However, if the
  third optional argument ACCEPT-DEFAULT is non-nil, `lookup-key' will
  recognize the default bindings, just as `read-key-sequence' does.</p>
</td><td class="codes"><pre class="brush: clojure">(defun lookup-key (keymap key &amp;optional accept-default)
  (let [key (if (string? key)
              (parser/parse-characters key (data/symbol-value 'meta-prefix-char))
              (el/check-type 'arrayp key))
        keymap (if (data/symbolp keymap) (data/symbol-value keymap) keymap)]
    (if-let [def (binding-map keymap key)]
      def
      (if-let [default (and accept-default (binding-map keymap #el/vec [t]))]
        default
        (when-let [parent (keymap-parent keymap)]
          (recur parent key accept-default))))))</pre></td></tr><tr><td class="docs"><p>Return a pretty description of key-sequence KEYS.
  Optional arg PREFIX is the sequence of keys leading up to KEYS.
  For example, [?C-x ?l] is converted into the string "C-x l".</p>

<p>  The `kbd' macro is an approximate inverse of this.</p>
</td><td class="codes"><pre class="brush: clojure">(defun key-description (keys &amp;optional prefix))</pre></td></tr><tr><td class="docs"><p>Return a pretty description of command character KEY.
  Control characters turn into C-whatever, etc.
  Optional argument NO-ANGLES non-nil means don't put angle brackets
  around function keys and event symbols.</p>
</td><td class="codes"><pre class="brush: clojure">(defun single-key-description (key &amp;optional no-angles))</pre></td></tr><tr><td class="docs"><p>Select KEYMAP as the local keymap.
  If KEYMAP is nil, that means no local keymap.</p>
</td><td class="codes"><pre class="brush: clojure">(defun use-local-map (keymap)
  ;; This is not strictly correct, as these are some form of private buffer locals in Emacs.
  (el/check-type 'keymapp keymap)
  (data/make-local-variable 'keymap)
  (data/set 'keymap keymap))</pre></td></tr><tr><td class="docs"><p>Return the binding for command KEYS in current local keymap only.
  KEYS is a string or vector, a sequence of keystrokes.
  The binding is probably a symbol with a function definition.</p>

<p>  If optional argument ACCEPT-DEFAULT is non-nil, recognize default
  bindings; see the description of `lookup-key' for more details about this.</p>
</td><td class="codes"><pre class="brush: clojure">(defun local-key-binding (keys &amp;optional accept-default)
  (when (current-local-map)
    (lookup-key (current-local-map) keys accept-default)))</pre></td></tr><tr><td class="docs"><p>Define COMMAND as a prefix command.  COMMAND should be a symbol.
  A new sparse keymap is stored as COMMAND's function definition and its value.
  If a second optional argument MAPVAR is given, the map is stored as
  its value instead of as COMMAND's value; but COMMAND is still defined
  as a function.
  The third optional argument NAME, if given, supplies a menu name
  string for the map.  This is required to use the keymap as a menu.
  This function returns COMMAND.</p>
</td><td class="codes"><pre class="brush: clojure">(defun define-prefix-command (command &amp;optional mapvar name)
  (let [keymap (make-sparse-keymap name)]
    (data/fset command keymap)
    (data/set (or mapvar command) keymap)
    command))</pre></td></tr><tr><td class="docs"><p>Return the parent keymap of KEYMAP.
  If KEYMAP has no parent, return nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun keymap-parent (keymap)
  (loop [x (data/cdr keymap)]
    (when x
      (if (keymapp x)
        x
        (recur (data/cdr x))))))</pre></td></tr><tr><td class="docs"><p>Return the binding for command KEYS in current global keymap only.
  KEYS is a string or vector, a sequence of keystrokes.
  The binding is probably a symbol with a function definition.
  This function's return values are the same as those of `lookup-key'
  (which see).</p>

<p>  If optional argument ACCEPT-DEFAULT is non-nil, recognize default
  bindings; see the description of `lookup-key' for more details about this.</p>
</td><td class="codes"><pre class="brush: clojure">(defun global-key-binding (keys &amp;optional accept-default)
  (when (current-global-map)
    (lookup-key (current-global-map) keys accept-default)))</pre></td></tr><tr><td class="docs"><p>Return the current global keymap.</p>
</td><td class="codes"><pre class="brush: clojure">(defun current-global-map ()
  @*current-global-map*)</pre></td></tr><tr><td class="docs"><p>Return the remapping for command COMMAND.
  Returns nil if COMMAND is not remapped (or not a symbol).</p>

<p>  If the optional argument POSITION is non-nil, it specifies a mouse
  position as returned by <code>event-start' and</code>event-end', and the
  remapping occurs in the keymaps associated with it.  It can also be a
  number or marker, in which case the keymap properties at the specified
  buffer position instead of point are used.  The KEYMAPS argument is
  ignored if POSITION is non-nil.</p>

<p>  If the optional argument KEYMAPS is non-nil, it should be a list of
  keymaps to search for command remapping.  Otherwise, search for the
  remapping in all currently active keymaps.</p>
</td><td class="codes"><pre class="brush: clojure">(defun command-remapping (command &amp;optional position keymaps))</pre></td></tr><tr><td class="docs"><p>Find the visible minor mode bindings of KEY.
  Return an alist of pairs (MODENAME . BINDING), where MODENAME is
  the symbol which names the minor mode binding KEY, and BINDING is
  KEY's definition in that mode.  In particular, if KEY has no
  minor-mode bindings, return nil.  If the first binding is a
  non-prefix, all subsequent bindings will be omitted, since they would
  be ignored.  Similarly, the list doesn't include non-prefix bindings
  that come after prefix bindings.</p>

<p>  If optional argument ACCEPT-DEFAULT is non-nil, recognize default
  bindings; see the description of `lookup-key' for more details about this.</p>
</td><td class="codes"><pre class="brush: clojure">(defun minor-mode-key-binding (key &amp;optional accept-default)
  (some #(lookup-key % accept-default) (current-minor-mode-maps)))</pre></td></tr><tr><td class="docs"><p>Insert a description of contents of VECTOR.
  This is text showing the elements of vector matched against indices.
  DESCRIBER is the output function used; nil means use `princ'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun describe-vector (vector &amp;optional describer))</pre></td></tr><tr><td class="docs"><p>Select KEYMAP as the global keymap.</p>
</td><td class="codes"><pre class="brush: clojure">(defun use-global-map (keymap)
  (el/check-type 'keymapp keymap)
  (reset! *current-global-map* keymap)
  nil)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.xml" name="deuce.emacs.xml"><h1 class="project-name">deuce.emacs.xml</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.xml
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Parse the region as an HTML document and return the parse tree.
  If BASE-URL is non-nil, it is used to expand relative URLs.</p>
</td><td class="codes"><pre class="brush: clojure">(defun libxml-parse-html-region (start end &amp;optional base-url))</pre></td></tr><tr><td class="docs"><p>Parse the region as an XML document and return the parse tree.
  If BASE-URL is non-nil, it is used to expand relative URLs.</p>
</td><td class="codes"><pre class="brush: clojure">(defun libxml-parse-xml-region (start end &amp;optional base-url))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.terminal" name="deuce.emacs.terminal"><h1 class="project-name">deuce.emacs.terminal</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.terminal
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [lanterna.screen :as s]
            [deuce.emacs.eval :as eval]
            [deuce.emacs.frame :as frame]
            [deuce.emacs-lisp.cons :as cons]
            [deuce.emacs-lisp.globals :as globals])
  (:import [deuce.emacs.data Frame])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Special hook run when a terminal is deleted.
  Each function is called with argument, the terminal.
  This may be called just before actually deleting the terminal,
  or some time later.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar delete-terminal-functions nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means call this function to ring the bell.
  The function should accept no arguments.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar ring-bell-function nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private init-initial-terminal []
  (let [terminal (s/get-screen :text)]
    (reset! (.terminal ^Frame globals/terminal-frame) terminal)
    (s/start terminal)))</pre></td></tr><tr><td class="docs"><p>Return a list of all terminal devices.</p>
</td><td class="codes"><pre class="brush: clojure">(defun terminal-list ()
  (cons/maybe-seq (remove nil? (map #(deref (.terminal ^Frame %)) (frame/frame-list)))))</pre></td></tr><tr><td class="docs"><p>Return TERMINAL's value for parameter PARAMETER.
  TERMINAL can be a terminal object, a frame, or nil (meaning the
  selected frame's terminal).</p>
</td><td class="codes"><pre class="brush: clojure">(defun terminal-parameter (terminal parameter))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare frame-terminal)</pre></td></tr><tr><td class="docs"><p>Return non-nil if OBJECT is a terminal which has not been deleted.
  Value is nil if OBJECT is not a live display terminal.
  If object is a live display terminal, the return value indicates what
  sort of output terminal it uses.  See the documentation of `framep' for
  possible return values.</p>
</td><td class="codes"><pre class="brush: clojure">(defun terminal-live-p (object)
  (when (frame-terminal)
    true))</pre></td></tr><tr><td class="docs"><p>Return the terminal that FRAME is displayed on.
  If FRAME is nil, the selected frame is used.</p>

<p>  The terminal device is represented by its integer identifier.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-terminal (&amp;optional frame)
  (let [^Frame frame (or frame (frame/selected-frame))]
    @(.terminal frame)))</pre></td></tr><tr><td class="docs"><p>Delete TERMINAL by deleting all frames on it and closing the terminal.
  TERMINAL may be a terminal object, a frame, or nil (meaning the
  selected frame's terminal).</p>

<p>  Normally, you may not delete a display if all other displays are suspended,
  but if the second argument FORCE is non-nil, you may do so.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-terminal (&amp;optional terminal force)
  (when-let [terminal (or terminal (frame-terminal))]
    (eval/run-hook-with-args 'delete-terminal-functions terminal)
    ((ns-resolve 'deuce.main 'stop-ui))
    (s/stop terminal)
    (when (= terminal (frame-terminal))
      (reset! (.terminal ^Frame globals/terminal-frame) nil))))</pre></td></tr><tr><td class="docs"><p>Set TERMINAL's value for parameter PARAMETER to VALUE.
  Return the previous value of PARAMETER.</p>

<p>  TERMINAL can be a terminal object, a frame or nil (meaning the
  selected frame's terminal).</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-terminal-parameter (terminal parameter value))</pre></td></tr><tr><td class="docs"><p>Return the parameter-alist of terminal TERMINAL.
  The value is a list of elements of the form (PARM . VALUE), where PARM
  is a symbol.</p>

<p>  TERMINAL can be a terminal object, a frame, or nil (meaning the
  selected frame's terminal).</p>
</td><td class="codes"><pre class="brush: clojure">(defun terminal-parameters (&amp;optional terminal))</pre></td></tr><tr><td class="docs"><p>Return the name of the terminal device TERMINAL.
  It is not guaranteed that the returned value is unique among opened devices.</p>

<p>  TERMINAL may be a terminal object, a frame, or nil (meaning the
  selected frame's terminal).</p>
</td><td class="codes"><pre class="brush: clojure">(defun terminal-name (&amp;optional terminal))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.syntax" name="deuce.emacs.syntax"><h1 class="project-name">deuce.emacs.syntax</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.syntax
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [deuce.emacs.cmds :as cmds]
            [deuce.emacs.fns :as fns]
            [deuce.emacs.editfns :as editfns]
            [deuce.emacs.search :as search]
            [deuce.emacs-lisp :as el]
            [taoensso.timbre :as timbre])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Non-nil means `forward-word', etc., should treat escape chars part of words.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar words-include-escapes nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means <code>forward-sexp', etc., obey</code>syntax-table' property.
  Otherwise, that text property is simply ignored.
  See the info node `(elisp)Syntax Properties' for a description of the
  `syntax-table' property.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar parse-sexp-lookup-properties nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means `scan-sexps' treats all multibyte characters as symbol.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar multibyte-syntax-as-symbol nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means `forward-sexp', etc., should treat comments as whitespace.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar parse-sexp-ignore-comments nil)</pre></td></tr><tr><td class="docs"><p>Char table of functions to search for the word boundary.
  Each function is called with two arguments; POS and LIMIT.
  POS and LIMIT are character positions in the current buffer.</p>

<p>  If POS is less than LIMIT, POS is at the first character of a word,
  and the return value of a function is a position after the last
  character of that word.</p>

<p>  If POS is not less than LIMIT, POS is at the last character of a word,
  and the return value of a function is a position at the first
  character of that word.</p>

<p>  In both cases, LIMIT bounds the search.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar find-word-boundary-function-table nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means an open paren in column 0 denotes the start of a defun.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar open-paren-in-column-0-is-defun-start nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fns/put 'syntax-table 'char-table-extra-slots 0)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare skip-chars-forward skip-chars-backward)</pre></td></tr><tr><td class="docs"><p>Return the standard syntax table.
  This is the one used for new buffers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun standard-syntax-table ())</pre></td></tr><tr><td class="docs"><p>Parse Lisp syntax starting at FROM until TO; return status of parse at TO.
  Parsing stops at TO or when certain criteria are met;
   point is set to where parsing stops.
  If fifth arg OLDSTATE is omitted or nil,
   parsing assumes that FROM is the beginning of a function.
  Value is a list of elements describing final state of parsing:
   0. depth in parens.
   1. character address of start of innermost containing list; nil if none.
   2. character address of start of last complete sexp terminated.
   3. non-nil if inside a string.
      (it is the character that will terminate the string,
       or t if the string should be terminated by a generic string delimiter.)
   4. nil if outside a comment, t if inside a non-nestable comment,
      else an integer (the current comment nesting).
   5. t if following a quote character.
   6. the minimum paren-depth encountered during this scan.
   7. style of comment, if any.
   8. character address of start of comment or string; nil if not in one.
   9. Intermediate data for continuation of parsing (subject to change).
  If third arg TARGETDEPTH is non-nil, parsing stops if the depth
  in parentheses becomes equal to TARGETDEPTH.
  Fourth arg STOPBEFORE non-nil means stop when come to
   any character that starts a sexp.
  Fifth arg OLDSTATE is a list like what this function returns.
   It is used to initialize the state of the parse.  Elements number 1, 2, 6
   and 8 are ignored.
  Sixth arg COMMENTSTOP non-nil means stop at the start of a comment.
   If it is symbol `syntax-table', stop after the start of a comment or a
   string, or after end of a comment or a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun parse-partial-sexp (from to &amp;optional targetdepth stopbefore oldstate commentstop))</pre></td></tr><tr><td class="docs"><p>Scan from character number FROM by COUNT balanced expressions.
  If COUNT is negative, scan backwards.
  Returns the character number of the position thus found.</p>

<p>  Comments are ignored if `parse-sexp-ignore-comments' is non-nil.</p>

<p>  If the beginning or end of (the accessible part of) the buffer is reached
  in the middle of a parenthetical grouping, an error is signaled.
  If the beginning or end is reached between groupings
  but before count is used up, nil is returned.</p>
</td><td class="codes"><pre class="brush: clojure">(defun scan-sexps (from count))</pre></td></tr><tr><td class="docs"><p>Return t if OBJECT is a syntax table.
  Currently, any char-table counts as a syntax table.</p>
</td><td class="codes"><pre class="brush: clojure">(defun syntax-table-p (object))</pre></td></tr><tr><td class="docs"><p>Move point forward ARG words (backward if ARG is negative).
  Normally returns t.
  If an edge of the buffer or a field boundary is reached, point is left there
  and the function returns nil.  Field boundaries are not noticed if
  `inhibit-field-text-motion' is non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun forward-word (&amp;optional arg)
  (interactive &quot;^p&quot;)
  (let [arg (el/check-type 'numberp (or arg 1))]
    (if (pos? arg)
      (do
        (dotimes [_ arg]
          (skip-chars-forward &quot;\\W&quot;)
          (skip-chars-forward &quot;\\w&quot;))
        (when-not (editfns/eobp) true))
      (do
        (dotimes [_ (- arg)]
          (skip-chars-backward &quot;\\W&quot;)
          (skip-chars-backward &quot;\\w&quot;))
        (when-not (editfns/bobp) true)))))</pre></td></tr><tr><td class="docs"><p>Scan from character number FROM by COUNT lists.
  Scan forward if COUNT is positive, backward if COUNT is negative.
  Return the character number of the position thus found.</p>

<p>  A "list", in this context, refers to a balanced parenthetical
  grouping, as determined by the syntax table.</p>

<p>  If DEPTH is nonzero, treat that as the nesting depth of the starting
  point (i.e. the starting point is DEPTH parentheses deep).  This
  function scans over parentheses until the depth goes to zero COUNT
  times.  Hence, positive DEPTH moves out that number of levels of
  parentheses, while negative DEPTH moves to a deeper level.</p>

<p>  Comments are ignored if `parse-sexp-ignore-comments' is non-nil.</p>

<p>  If we reach the beginning or end of the accessible part of the buffer
  before we have scanned over COUNT lists, return nil if the depth at
  that point is zero, and signal a error if the depth is nonzero.</p>
</td><td class="codes"><pre class="brush: clojure">(defun scan-lists (from count depth))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private skip-pattern [s]
  (re-pattern (str &quot;[&quot; (el/check-type 'stringp s) &quot;]&quot;)))</pre></td></tr><tr><td class="docs"><p>Move point backward, stopping after a char not in STRING, or at pos LIM.
  See `skip-chars-forward' for details.
  Returns the distance traveled, either zero or negative.</p>
</td><td class="codes"><pre class="brush: clojure">(defun skip-chars-backward (string &amp;optional lim)
  (let [lim (el/check-type 'numberp (or lim (editfns/point-min)))]
    (while (and (not= lim (editfns/point))
                (re-find (skip-pattern string)
                         (str (editfns/char-before))))
      (cmds/backward-char))))</pre></td></tr><tr><td class="docs"><p>Move point backward over any number of chars with prefix syntax.
  This includes chars with "quote" or "prefix" syntax (' or p).</p>
</td><td class="codes"><pre class="brush: clojure">(defun backward-prefix-chars ())</pre></td></tr><tr><td class="docs"><p>Construct a new syntax table and return it.
  It is a copy of the TABLE, which defaults to the standard syntax table.</p>
</td><td class="codes"><pre class="brush: clojure">(defun copy-syntax-table (&amp;optional table))</pre></td></tr><tr><td class="docs"><p>Return the current syntax table.
  This is the one specified by the current buffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun syntax-table ())</pre></td></tr><tr><td class="docs"><p>Move point backward across chars in specified syntax classes.
  SYNTAX is a string of syntax code characters.
  Stop on reaching a char whose syntax is not in SYNTAX, or at position LIM.
  If SYNTAX starts with ^, skip characters whose syntax is NOT in SYNTAX.
  This function returns the distance traveled, either zero or negative.</p>
</td><td class="codes"><pre class="brush: clojure">(defun skip-syntax-backward (syntax &amp;optional lim))</pre></td></tr><tr><td class="docs"><p>Move forward across up to COUNT comments.  If COUNT is negative, move backward.
  Stop scanning if we find something other than a comment or whitespace.
  Set point to where scanning stops.
  If COUNT comments are found as expected, with nothing except whitespace
  between them, return t; otherwise return nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun forward-comment (count))</pre></td></tr><tr><td class="docs"><p>Move point forward across chars in specified syntax classes.
  SYNTAX is a string of syntax code characters.
  Stop before a char whose syntax is not in SYNTAX, or at position LIM.
  If SYNTAX starts with ^, skip characters whose syntax is NOT in SYNTAX.
  This function returns the distance traveled, either zero or positive.</p>
</td><td class="codes"><pre class="brush: clojure">(defun skip-syntax-forward (syntax &amp;optional lim))</pre></td></tr><tr><td class="docs"><p>Select a new syntax table for the current buffer.
  One argument, a syntax table.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-syntax-table (table))</pre></td></tr><tr><td class="docs"><p>Set syntax for character CHAR according to string NEWENTRY.
  The syntax is changed only for table SYNTAX-TABLE, which defaults to
   the current buffer's syntax table.
  CHAR may be a cons (MIN . MAX), in which case, syntaxes of all characters
  in the range MIN to MAX are changed.
  The first character of NEWENTRY should be one of the following:
    Space or -  whitespace syntax.    w   word constituent.
    _           symbol constituent.   .   punctuation.
    (           open-parenthesis.     )   close-parenthesis.
    "           string quote.         \   escape.
    $           paired delimiter.     '   expression quote or prefix operator.
    &lt;           comment starter.      >   comment ender.
    /           character-quote.      @   inherit from `standard-syntax-table'.
    |           generic string fence. !   generic comment fence.</p>

<p>  Only single-character comment start and end sequences are represented thus.
  Two-character sequences are represented as described below.
  The second character of NEWENTRY is the matching parenthesis,
   used only if the first character is <code>(' or</code>)'.
  Any additional characters are flags.
  Defined flags are the characters 1, 2, 3, 4, b, p, and n.
   1 means CHAR is the start of a two-char comment start sequence.
   2 means CHAR is the second character of such a sequence.
   3 means CHAR is the start of a two-char comment end sequence.
   4 means CHAR is the second character of such a sequence.</p>

<p>  There can be several orthogonal comment sequences.  This is to support
  language modes such as C++.  By default, all comment sequences are of style
  a, but you can set the comment sequence style to b (on the second character
  of a comment-start, and the first character of a comment-end sequence) and/or
  c (on any of its chars) using this flag:
   b means CHAR is part of comment sequence b.
   c means CHAR is part of comment sequence c.
   n means CHAR is part of a nestable comment sequence.</p>

<p>   p means CHAR is a prefix character for `backward-prefix-chars';
     such characters are treated as whitespace when they occur
     between expressions.</p>
</td><td class="codes"><pre class="brush: clojure">(defun modify-syntax-entry (char newentry &amp;optional syntax-table)
  &quot;Set syntax for character CHAR according to string NEWENTRY.
  The syntax is changed only for table SYNTAX-TABLE, which defaults to
   the current buffer's syntax table.
  CHAR may be a cons (MIN . MAX), in which case, syntaxes of all characters
  in the range MIN to MAX are changed.
  The first character of NEWENTRY should be one of the following:
    Space or -  whitespace syntax.    w   word constituent.
    _           symbol constituent.   .   punctuation.
    (           open-parenthesis.     )   close-parenthesis.
    \&quot;           string quote.         \\   escape.
    $           paired delimiter.     '   expression quote or prefix operator.
    &lt;           comment starter.      &gt;   comment ender.
    /           character-quote.      @   inherit from `standard-syntax-table'.
    |           generic string fence. !   generic comment fence.
  Only single-character comment start and end sequences are represented thus.
  Two-character sequences are represented as described below.
  The second character of NEWENTRY is the matching parenthesis,
   used only if the first character is `(' or `)'.
  Any additional characters are flags.
  Defined flags are the characters 1, 2, 3, 4, b, p, and n.
   1 means CHAR is the start of a two-char comment start sequence.
   2 means CHAR is the second character of such a sequence.
   3 means CHAR is the start of a two-char comment end sequence.
   4 means CHAR is the second character of such a sequence.
  There can be several orthogonal comment sequences.  This is to support
  language modes such as C++.  By default, all comment sequences are of style
  a, but you can set the comment sequence style to b (on the second character
  of a comment-start, and the first character of a comment-end sequence) and/or
  c (on any of its chars) using this flag:
   b means CHAR is part of comment sequence b.
   c means CHAR is part of comment sequence c.
   n means CHAR is part of a nestable comment sequence.
   p means CHAR is a prefix character for `backward-prefix-chars';
     such characters are treated as whitespace when they occur
     between expressions.&quot;
  (interactive &quot;cSet syntax for character: \nsSet syntax for %s to: &quot;))</pre></td></tr><tr><td class="docs"><p>Return the matching parenthesis of CHARACTER, or nil if none.</p>
</td><td class="codes"><pre class="brush: clojure">(defun matching-paren (character))</pre></td></tr><tr><td class="docs"><p>Move point forward, stopping before a char not in STRING, or at pos LIM.
  STRING is like the inside of a `[...]' in a regular expression
  except that <code>]' is never special and</code>\' quotes <code>^',</code>-' or `\'
   (but not at the end of a range; quoting is never needed there).
  Thus, with arg "a-zA-Z", this skips letters stopping before first nonletter.
  With arg "^a-zA-Z", skips nonletters stopping before first letter.
  Char classes, e.g. `[:alpha:]', are supported.</p>

<p>  Returns the distance traveled, either zero or positive.</p>
</td><td class="codes"><pre class="brush: clojure">(defun skip-chars-forward (string &amp;optional lim)
  &quot;Move point forward, stopping before a char not in STRING, or at pos LIM.
  STRING is like the inside of a `[...]' in a regular expression
  except that `]' is never special and `\\' quotes `^', `-' or `\\'
   (but not at the end of a range; quoting is never needed there).
  Thus, with arg \&quot;a-zA-Z\&quot;, this skips letters stopping before first nonletter.
  With arg \&quot;^a-zA-Z\&quot;, skips nonletters stopping before first letter.
  Char classes, e.g. `[:alpha:]', are supported.
  Returns the distance traveled, either zero or positive.&quot;
  (let [lim (el/check-type 'numberp (or lim (editfns/point-max)))]
    (while  (and (not= lim (editfns/point))
                 (re-find (skip-pattern string)
                          (str (editfns/char-after))))
      (cmds/forward-char))))</pre></td></tr><tr><td class="docs"><p>Return the syntax code of CHARACTER, described by a character.
  For example, if CHARACTER is a word constituent, the
  character `w' (119) is returned.
  The characters that correspond to various syntax codes
  are listed in the documentation of `modify-syntax-entry'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun char-syntax (character))</pre></td></tr><tr><td class="docs"><p>Convert a syntax specification STRING into syntax cell form.
  STRING should be a string as it is allowed as argument of
  `modify-syntax-entry'.  Value is the equivalent cons cell
  (CODE . MATCHING-CHAR) that can be used as value of a `syntax-table'
  text property.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-to-syntax (string))</pre></td></tr><tr><td class="docs"><p>Insert a description of the internal syntax description SYNTAX at point.</p>
</td><td class="codes"><pre class="brush: clojure">(defun internal-describe-syntax-value (syntax))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.search" name="deuce.emacs.search"><h1 class="project-name">deuce.emacs.search</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.search
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns]
            [deuce.emacs-lisp.cons :as cons]
            [taoensso.timbre :as timbre])
  (:refer-clojure :exclude [])
  (:import [java.util.regex Pattern PatternSyntaxException]))</pre></td></tr><tr><td class="docs"><p>Internal use only.
  If non-nil, the primitive searching and matching functions
  such as <code>looking-at',</code>string-match', `re-search-forward', etc.,
  do not set the match data.  The proper way to use this variable
  is to bind it with `let' around a small expression.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-changing-match-data nil)</pre></td></tr><tr><td class="docs"><p>Regexp to substitute for bunches of spaces in regexp search.
  Some commands use this for user-specified regexps.
  Spaces that occur inside character classes or repetition operators
  or other such regexp constructs are not replaced with this.
  A value of nil (which is the normal value) means treat spaces literally.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar search-spaces-regexp nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare string-match re-search-forward regexp-quote
         match-beginning match-end match-data set-match-data)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private current-match-data (atom nil))</pre></td></tr><tr><td class="docs"><p>Return a regexp which matches words, ignoring punctuation.
  Given STRING, a string of words separated by word delimiters,
  compute a regexp that matches those exact words separated by
  arbitrary punctuation.  If LAX is non-nil, the end of the string
  need not match a word boundary unless it ends in whitespace.</p>

<p>  Used in <code>word-search-forward',</code>word-search-backward',
  <code>word-search-forward-lax',</code>word-search-backward-lax'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun word-search-regexp (string &amp;optional lax)
  (str &quot;\\b&quot; (s/replace (s/trim string) #&quot;\W+&quot; &quot;\\\\W\\\\W*&quot;)
       (when (or (not lax) (re-find #&quot;\s$&quot; string)) &quot;\\b&quot;)))</pre></td></tr><tr><td class="docs"><p>Search forward from point for STRING.
  Set point to the end of the occurrence found, and return point.
  An optional second argument bounds the search; it is a buffer position.
  The match found must not extend after that position.  A value of nil is
    equivalent to (point-max).
  Optional third argument, if t, means if fail just return nil (no error).
    If not nil and not t, move to limit of search and return nil.
  Optional fourth argument COUNT, if non-nil, means to search for COUNT
   successive occurrences.  If COUNT is negative, search backward,
   instead of forward, for -COUNT occurrences.</p>

<p>  Search case-sensitivity is determined by the value of the variable
  `case-fold-search', which see.</p>

<p>  See also the functions <code>match-beginning',</code>match-end' and `replace-match'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun search-forward (string &amp;optional bound noerror count)
  (interactive &quot;MSearch: &quot;)
  (re-search-forward (regexp-quote string) bound noerror count))</pre></td></tr><tr><td class="docs"><p>Search backward from point for match for regular expression REGEXP.
  Set point to the beginning of the match, and return point.
  The match found is the one starting last in the buffer
  and yet ending before the origin of the search.
  An optional second argument bounds the search; it is a buffer position.
  The match found must start at or after that position.
  Optional third argument, if t, means if fail just return nil (no error).
    If not nil and not t, move to limit of search and return nil.
  Optional fourth argument is repeat count--search for successive occurrences.</p>

<p>  Search case-sensitivity is determined by the value of the variable
  `case-fold-search', which see.</p>

<p>  See also the functions <code>match-beginning',</code>match-end', `match-string',
  and `replace-match'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun re-search-backward (regexp &amp;optional bound noerror count)
  (interactive &quot;sRE search backward: &quot;)
  (let [point (editfns/point)
        count (el/check-type 'integerp (or count 1))]
    (cond
     (zero? count) point
     (neg? count) (re-search-forward regexp bound noerror (- count))
     :else
     (let [bound (el/check-type 'integerp (or bound 1))]
       (loop [offset (editfns/goto-char bound)
              matches []]
         (if (string-match (el/check-type 'stringp regexp)
                           (subs (editfns/buffer-string) 0 (dec point))
                           (dec offset))
           (when (&lt; (editfns/goto-char (match-end 0)) point)
             (recur (editfns/point) (conj matches (match-data))))
           (if-let [match (nth (reverse matches) (dec count) nil)]
             (do (set-match-data match)
                 (editfns/goto-char (inc (first match))))
             (do (editfns/goto-char (if-not (contains? #{nil true} noerror)
                                      bound
                                      point))
                 (when-not noerror
                   (el/throw* 'search-failed (format &quot;Search failed: %s&quot; regexp)))))))))))</pre></td></tr><tr><td class="docs"><p>Set internal data on last search match from elements of LIST.
  LIST should have been created by calling `match-data' previously.</p>

<p>  If optional arg RESEAT is non-nil, make markers on LIST point nowhere.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-match-data (list &amp;optional reseat)
  (reset! current-match-data list))</pre></td></tr><tr><td class="docs"><p>Search forward from point for STRING, ignoring differences in punctuation.
  Set point to the end of the occurrence found, and return point.</p>

<p>  Unlike `word-search-forward', the end of STRING need not match a word
  boundary, unless STRING ends in whitespace.</p>

<p>  An optional second argument bounds the search; it is a buffer position.
  The match found must not extend after that position.
  Optional third argument, if t, means if fail just return nil (no error).
    If not nil and not t, move to limit of search and return nil.
  Optional fourth argument is repeat count--search for successive occurrences.</p>

<p>  Relies on the function `word-search-regexp' to convert a sequence
  of words in STRING to a regexp used to search words without regard
  to punctuation.</p>
</td><td class="codes"><pre class="brush: clojure">(defun word-search-forward-lax (string &amp;optional bound noerror count)
  (interactive &quot;sWord search: &quot;)
  (re-search-forward (word-search-regexp string true) bound noerror count))</pre></td></tr><tr><td class="docs"><p>Search backward from point for STRING, ignoring differences in punctuation.
  Set point to the beginning of the occurrence found, and return point.
  An optional second argument bounds the search; it is a buffer position.
  The match found must not extend before that position.
  Optional third argument, if t, means if fail just return nil (no error).
    If not nil and not t, move to limit of search and return nil.
  Optional fourth argument is repeat count--search for successive occurrences.</p>

<p>  Relies on the function `word-search-regexp' to convert a sequence
  of words in STRING to a regexp used to search words without regard
  to punctuation.</p>
</td><td class="codes"><pre class="brush: clojure">(defun word-search-backward (string &amp;optional bound noerror count)
  (interactive &quot;sWord search backward: &quot;)
  (re-search-backward (word-search-regexp string) bound noerror count))</pre></td></tr><tr><td class="docs"><p>Search forward from point for regular expression REGEXP.
  Find the longest match in accord with Posix regular expression rules.
  Set point to the end of the occurrence found, and return point.
  An optional second argument bounds the search; it is a buffer position.
  The match found must not extend after that position.
  Optional third argument, if t, means if fail just return nil (no error).
    If not nil and not t, move to limit of search and return nil.
  Optional fourth argument is repeat count--search for successive occurrences.</p>

<p>  Search case-sensitivity is determined by the value of the variable
  `case-fold-search', which see.</p>

<p>  See also the functions <code>match-beginning',</code>match-end', `match-string',
  and `replace-match'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun posix-search-forward (regexp &amp;optional bound noerror count)
  (interactive &quot;sPosix search: &quot;)
  (search-forward regexp bound noerror count))</pre></td></tr><tr><td class="docs"><p>Search forward from point for STRING, ignoring differences in punctuation.
  Set point to the end of the occurrence found, and return point.
  An optional second argument bounds the search; it is a buffer position.
  The match found must not extend after that position.
  Optional third argument, if t, means if fail just return nil (no error).
    If not nil and not t, move to limit of search and return nil.
  Optional fourth argument is repeat count--search for successive occurrences.</p>

<p>  Relies on the function `word-search-regexp' to convert a sequence
  of words in STRING to a regexp used to search words without regard
  to punctuation.</p>
</td><td class="codes"><pre class="brush: clojure">(defun word-search-forward (string &amp;optional bound noerror count)
  (interactive &quot;sWord search: &quot;)
  (re-search-forward (word-search-regexp string) bound noerror count))</pre></td></tr><tr><td class="docs"><p>Search backward from point for STRING, ignoring differences in punctuation.
  Set point to the beginning of the occurrence found, and return point.</p>

<p>  Unlike `word-search-backward', the end of STRING need not match a word
  boundary, unless STRING ends in whitespace.</p>

<p>  An optional second argument bounds the search; it is a buffer position.
  The match found must not extend before that position.
  Optional third argument, if t, means if fail just return nil (no error).
    If not nil and not t, move to limit of search and return nil.
  Optional fourth argument is repeat count--search for successive occurrences.</p>

<p>  Relies on the function `word-search-regexp' to convert a sequence
  of words in STRING to a regexp used to search words without regard
  to punctuation.</p>
</td><td class="codes"><pre class="brush: clojure">(defun word-search-backward-lax (string &amp;optional bound noerror count)
  (interactive &quot;sWord search backward: &quot;)
  (re-search-backward (word-search-regexp string true) bound noerror count))</pre></td></tr><tr><td class="docs"><p>Return t if text after point matches regular expression REGEXP.
  This function modifies the match data that `match-beginning',
  <code>match-end' and</code>match-data' access; save and restore the match
  data if you want to preserve them.</p>
</td><td class="codes"><pre class="brush: clojure">(defun looking-at (regexp)
  (when (string-match (str &quot;^&quot; (el/check-type 'stringp regexp))
                      (editfns/buffer-string)
                      (dec (editfns/point)))
    true))</pre></td></tr><tr><td class="docs"><p>Search forward from point for regular expression REGEXP.
  Set point to the end of the occurrence found, and return point.
  An optional second argument bounds the search; it is a buffer position.
  The match found must not extend after that position.
  Optional third argument, if t, means if fail just return nil (no error).
    If not nil and not t, move to limit of search and return nil.
  Optional fourth argument is repeat count--search for successive occurrences.</p>

<p>  Search case-sensitivity is determined by the value of the variable
  `case-fold-search', which see.</p>

<p>  See also the functions <code>match-beginning',</code>match-end', `match-string',
  and `replace-match'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun re-search-forward (regexp &amp;optional bound noerror count)
  (interactive &quot;sRE search: &quot;)
  (let [point (editfns/point)
        count (el/check-type 'integerp (or count 1))]
    (cond
     (zero? count) point
     (neg? count) (re-search-backward regexp bound noerror (- count))
     :else
     (let [bound (el/check-type 'integerp (or bound (inc (editfns/buffer-size))))]
       (loop [count (dec count)]
         (if (string-match (el/check-type 'stringp regexp)
                           (subs (editfns/buffer-string) 0 (dec bound))
                           (dec (editfns/point)))
           (do (editfns/goto-char (inc (match-end 0)))
               (if (zero? count)
                 (editfns/point)
                 (recur (dec count))))
           (do (editfns/goto-char (if-not (contains? #{nil true} noerror)
                                    bound
                                    point))
               (when-not noerror
                 (el/throw* 'search-failed (format &quot;Search failed: %s&quot; regexp))))))))))</pre></td></tr><tr><td class="docs"><p>Return index of start of first match for REGEXP in STRING, or nil.
  Find the longest match, in accord with Posix regular expression rules.
  Case is ignored if `case-fold-search' is non-nil in the current buffer.
  If third arg START is non-nil, start search at that index in STRING.
  For index of first char beyond the match, do (match-end 0).
  <code>match-end' and</code>match-beginning' also give indices of substrings
  matched by parenthesis constructs in the pattern.</p>
</td><td class="codes"><pre class="brush: clojure">(defun posix-string-match (regexp string &amp;optional start)
  (string-match regexp string start))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private emacs-regex-to-java [regexp]
  (-&gt; regexp
      (s/replace #&quot;^\\\`&quot; &quot;^&quot;)
      (s/replace #&quot;\\\|&quot; &quot;|&quot;)
      (s/replace #&quot;\[(]?.*?)]&quot;
                 (fn [x]
                   (str &quot;[&quot; (s/replace
                             (s/replace (x 1) &quot;\\&quot; &quot;\\\\&quot;)
                             &quot;[&quot; &quot;\\[&quot;)
                        &quot;]&quot;)))
      (s/replace &quot;\\(&quot; &quot;(&quot;)
      (s/replace &quot;\\)&quot; &quot;)&quot;)))</pre></td></tr><tr><td class="docs"><p>Return index of start of first match for REGEXP in STRING, or nil.
  Matching ignores case if `case-fold-search' is non-nil.
  If third arg START is non-nil, start search at that index in STRING.
  For index of first char beyond the match, do (match-end 0).
  <code>match-end' and</code>match-beginning' also give indices of substrings
  matched by parenthesis constructs in the pattern.</p>

<p>  You can use the function `match-string' to extract the substrings
  matched by the parenthesis constructions in REGEXP.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string-match (regexp string &amp;optional start)
  ;; http://www.gnu.org/software/emacs/manual/html_node/elisp/Regexp-Special.html
  (el/check-type 'stringp regexp)
  (el/check-type 'stringp string)
  (let [pattern (emacs-regex-to-java regexp)]
    (let [offset (el/check-type 'integerp (or start 0))
          ignore-case? (data/symbol-value 'case-fold-search)
          m (re-matcher (re-pattern (str (if ignore-case? &quot;(?iu)&quot; &quot;&quot;) pattern))
                        (subs string offset))
          inhibit? (data/symbol-value 'inhibit-changing-match-data)]
      (if (re-find m)
        (let [m (cons/maybe-seq
                 (map (partial + offset)
                      (mapcat #(vector (.start m (int %)) (.end m (int %)))
                              (range (inc (.groupCount m))))))]
          (when-not inhibit?
            (reset! current-match-data m))
          (first m))
        (when-not inhibit?
          (reset! current-match-data nil))))))</pre></td></tr><tr><td class="docs"><p>Return t if text after point matches regular expression REGEXP.
  Find the longest match, in accord with Posix regular expression rules.
  This function modifies the match data that `match-beginning',
  <code>match-end' and</code>match-data' access; save and restore the match
  data if you want to preserve them.</p>
</td><td class="codes"><pre class="brush: clojure">(defun posix-looking-at (regexp)
  (looking-at regexp))</pre></td></tr><tr><td class="docs"><p>Return a list containing all info on what the last search matched.
  Element 2N is <code>(match-beginning N)'; element 2N + 1 is</code>(match-end N)'.
  All the elements are markers or nil (nil if the Nth pair didn't match)
  if the last match was on a buffer; integers or nil if a string was matched.
  Use `set-match-data' to reinstate the data in this list.</p>

<p>  If INTEGERS (the optional first argument) is non-nil, always use
  integers (rather than markers) to represent buffer positions.  In
  this case, and if the last match was in a buffer, the buffer will get
  stored as one additional element at the end of the list.</p>

<p>  If REUSE is a list, reuse it as part of the value.  If REUSE is long
  enough to hold all the values, and if INTEGERS is non-nil, no consing
  is done.</p>

<p>  If optional third arg RESEAT is non-nil, any previous markers on the
  REUSE list will be modified to point to nowhere.</p>

<p>  Return value is undefined if the last search failed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun match-data (&amp;optional integers reuse reseat)
  @current-match-data)</pre></td></tr><tr><td class="docs"><p>Replace text matched by last search with NEWTEXT.
  Leave point at the end of the replacement text.</p>

<p>  If second arg FIXEDCASE is non-nil, do not alter case of replacement text.
  Otherwise maybe capitalize the whole text, or maybe just word initials,
  based on the replaced text.
  If the replaced text has only capital letters
  and has at least one multiletter word, convert NEWTEXT to all caps.
  Otherwise if all words are capitalized in the replaced text,
  capitalize each word in NEWTEXT.</p>

<p>  If third arg LITERAL is non-nil, insert NEWTEXT literally.
  Otherwise treat `\' as special:
    `\&amp;' in NEWTEXT means substitute original matched text.
    <code>\N' means substitute what matched the Nth</code>(...)'.
         If Nth parens didn't match, substitute nothing.
    <code>\\' means insert one</code>\'.
  Case conversion does not apply to these substitutions.</p>

<p>  FIXEDCASE and LITERAL are optional arguments.</p>

<p>  The optional fourth argument STRING can be a string to modify.
  This is meaningful when the previous match was done against STRING,
  using <code>string-match'.  When used this way,</code>replace-match'
  creates and returns a new string made by copying STRING and replacing
  the part of STRING that was matched.</p>

<p>  The optional fifth argument SUBEXP specifies a subexpression;
  it says to replace just that subexpression with NEWTEXT,
  rather than replacing the entire matched text.
  This is, in a vague sense, the inverse of using `\N' in NEWTEXT;
  `\N' copies subexp N into NEWTEXT, but using N as SUBEXP puts
  NEWTEXT in place of subexp N.
  This is useful only after a regular expression search or match,
  since only regular expressions have distinguished subexpressions.</p>
</td><td class="codes"><pre class="brush: clojure">(defun replace-match (newtext &amp;optional fixedcase literal string subexp)
  &quot;Replace text matched by last search with NEWTEXT.
  Leave point at the end of the replacement text.
  If second arg FIXEDCASE is non-nil, do not alter case of replacement text.
  Otherwise maybe capitalize the whole text, or maybe just word initials,
  based on the replaced text.
  If the replaced text has only capital letters
  and has at least one multiletter word, convert NEWTEXT to all caps.
  Otherwise if all words are capitalized in the replaced text,
  capitalize each word in NEWTEXT.
  If third arg LITERAL is non-nil, insert NEWTEXT literally.
  Otherwise treat `\\' as special:
    `\\&amp;' in NEWTEXT means substitute original matched text.
    `\\N' means substitute what matched the Nth `\\(...\\)'.
         If Nth parens didn't match, substitute nothing.
    `\\\\' means insert one `\\'.
  Case conversion does not apply to these substitutions.
  FIXEDCASE and LITERAL are optional arguments.
  The optional fourth argument STRING can be a string to modify.
  This is meaningful when the previous match was done against STRING,
  using `string-match'.  When used this way, `replace-match'
  creates and returns a new string made by copying STRING and replacing
  the part of STRING that was matched.
  The optional fifth argument SUBEXP specifies a subexpression;
  it says to replace just that subexpression with NEWTEXT,
  rather than replacing the entire matched text.
  This is, in a vague sense, the inverse of using `\\N' in NEWTEXT;
  `\\N' copies subexp N into NEWTEXT, but using N as SUBEXP puts
  NEWTEXT in place of subexp N.
  This is useful only after a regular expression search or match,
  since only regular expressions have distinguished subexpressions.&quot;
  (let [group (el/check-type 'integerp (or subexp 0))]
    (editfns/goto-char (inc (match-beginning group)))
    (editfns/delete-region (inc (match-beginning group)) (inc (match-end group)))
    (editfns/insert newtext)))</pre></td></tr><tr><td class="docs"><p>Return position of start of text matched by last search.
  SUBEXP, a number, specifies which parenthesized expression in the last
    regexp.
  Value is nil if SUBEXPth pair didn't match, or there were less than
    SUBEXP pairs.
  Zero means the entire text matched by the whole regexp or whole string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun match-beginning (subexp)
  (when @current-match-data
    (nth @current-match-data (* subexp 2) nil)))</pre></td></tr><tr><td class="docs"><p>Search backward from point for STRING.
  Set point to the beginning of the occurrence found, and return point.
  An optional second argument bounds the search; it is a buffer position.
  The match found must not extend before that position.
  Optional third argument, if t, means if fail just return nil (no error).
   If not nil and not t, position at limit of search and return nil.
  Optional fourth argument COUNT, if non-nil, means to search for COUNT
   successive occurrences.  If COUNT is negative, search forward,
   instead of backward, for -COUNT occurrences.</p>

<p>  Search case-sensitivity is determined by the value of the variable
  `case-fold-search', which see.</p>

<p>  See also the functions <code>match-beginning',</code>match-end' and `replace-match'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun search-backward (string &amp;optional bound noerror count)
  (interactive &quot;MSearch backward: &quot;)
  (re-search-backward (regexp-quote string) bound noerror count))</pre></td></tr><tr><td class="docs"><p>Return position of end of text matched by last search.
  SUBEXP, a number, specifies which parenthesized expression in the last
    regexp.
  Value is nil if SUBEXPth pair didn't match, or there were less than
    SUBEXP pairs.
  Zero means the entire text matched by the whole regexp or whole string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun match-end (subexp)
  (when @current-match-data
    (nth @current-match-data (inc (* subexp 2)) nil)))</pre></td></tr><tr><td class="docs"><p>Search backward from point for match for regular expression REGEXP.
  Find the longest match in accord with Posix regular expression rules.
  Set point to the beginning of the match, and return point.
  The match found is the one starting last in the buffer
  and yet ending before the origin of the search.
  An optional second argument bounds the search; it is a buffer position.
  The match found must start at or after that position.
  Optional third argument, if t, means if fail just return nil (no error).
    If not nil and not t, move to limit of search and return nil.
  Optional fourth argument is repeat count--search for successive occurrences.</p>

<p>  Search case-sensitivity is determined by the value of the variable
  `case-fold-search', which see.</p>

<p>  See also the functions <code>match-beginning',</code>match-end', `match-string',
  and `replace-match'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun posix-search-backward (regexp &amp;optional bound noerror count)
  (interactive &quot;sPosix search backward: &quot;)
  (search-backward regexp bound noerror count))</pre></td></tr><tr><td class="docs"><p>Return a regexp string which matches exactly STRING and nothing else.</p>
</td><td class="codes"><pre class="brush: clojure">(defun regexp-quote (string)
  (let [slash (str (gensym &quot;SLASH&quot;))]
    (s/replace
     (reduce #(s/replace %1 (str %2) (str &quot;\\&quot; %2)) (s/replace (el/check-type 'stringp string) &quot;\\&quot; slash)
             &quot;[*.?+^$&quot;)
     slash &quot;\\\\&quot;)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.callint" name="deuce.emacs.callint"><h1 class="project-name">deuce.emacs.callint</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.callint
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [clojure.string :as s]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs.editfns :as editfns]
            [deuce.emacs.eval :as eval]
            [deuce.emacs.lread :as lread]
            [deuce.emacs.marker :as marker]
            [taoensso.timbre :as timbre])
  (::refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>The value of the prefix argument for the next editing command.
  It may be a number, or the symbol `-' for just a minus sign as arg,
  or a list whose car is a number for just one or more C-u's
  or nil if no argument has been specified.</p>

<p>  You cannot examine this variable to find the argument for this command
  since it has been set to nil by the time you can look.
  Instead, you should use the variable `current-prefix-arg', although
  normally commands can get this prefix argument with (interactive "P").</p>
</td><td class="codes"><pre class="brush: clojure">(defvar prefix-arg nil)</pre></td></tr><tr><td class="docs"><p>List of recent commands that read arguments from terminal.
  Each command is represented as a form to evaluate.</p>

<p>  Maximum length of the history list is determined by the value
  of `history-length', which see.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar command-history nil)</pre></td></tr><tr><td class="docs"><p>The value of the prefix argument for the previous editing command.
  See `prefix-arg' for the meaning of the value.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar last-prefix-arg nil)</pre></td></tr><tr><td class="docs"><p>Debugging status of current interactive command.
  Bound each time `call-interactively' is called;
  may be set by the debugger as a reminder for itself.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar command-debug-status nil)</pre></td></tr><tr><td class="docs"><p>The value of the prefix argument for this editing command.
  It may be a number, or the symbol `-' for just a minus sign as arg,
  or a list whose car is a number for just one or more C-u's
  or nil if no argument has been specified.
  This is what `(interactive "P")' returns.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar current-prefix-arg nil)</pre></td></tr><tr><td class="docs"><p>*Non-nil means you can use the mark even when inactive.
  This option makes a difference in Transient Mark mode.
  When the option is non-nil, deactivation of the mark
  turns off region highlighting, but commands that use the mark
  behave as if the mark were still active.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar mark-even-if-inactive nil)</pre></td></tr><tr><td class="docs"><p>Hook to run when about to switch windows with a mouse command.
  Its purpose is to give temporary modes such as Isearch mode
  a way to turn themselves off when a mouse command switches windows.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar mouse-leave-buffer-hook nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare prefix-numeric-value)</pre></td></tr><tr><td class="docs"><p>See callint.c for the full set, many enter recursive edit and read the arguments from the minibuffer.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private parse-interactive [arg]
  (let [[[_ mods [code &amp; prompt]]] (re-seq #&quot;([@*^]*)(.+)&quot; arg)
        prompt (apply str prompt)]
    (doseq [m (distinct mods)]
      (case m
        \* (buffer/barf-if-buffer-read-only)
        \^ (timbre/warn &quot;should handle shift translation for &quot; arg &quot;shift-select-mode:&quot;
                        (data/symbol-value 'shift-select-mode))
        \@ (timbre/debug &quot;should select window if mouse event for &quot; arg)))
    (case code
      \b [(buffer/buffer-name)]
      \m [(marker/marker-position (editfns/mark-marker))]
      \r [(editfns/region-beginning) (editfns/region-end)]
      \P [(data/symbol-value 'current-prefix-arg)]
      \p [(prefix-numeric-value (data/symbol-value 'current-prefix-arg))])))</pre></td></tr><tr><td class="docs"><p>Call FUNCTION, providing args according to its interactive calling specs.
  Return the value FUNCTION returns.
  The function contains a specification of how to do the argument reading.
  In the case of user-defined functions, this is specified by placing a call
  to the function `interactive' at the top level of the function body.
  See `interactive'.</p>

<p>  Optional second arg RECORD-FLAG non-nil
  means unconditionally put this command in the command-history.
  Otherwise, this is done only if an arg is read using the minibuffer.</p>

<p>  Optional third arg KEYS, if given, specifies the sequence of events to
  supply, as a vector, if the command inquires which events were used to
  invoke it.  If KEYS is omitted or nil, the return value of
  `this-command-keys-vector' is used.</p>
</td><td class="codes"><pre class="brush: clojure">(defun call-interactively (function &amp;optional record-flag keys)
  (el/check-type 'commandp function)
  (let [keys (or keys (eval/funcall 'this-command-keys-vector))
        f (data/symbol-function function)
        interactive (:interactive (meta f))
        args (condp some [interactive]
              (comp #{\)} first) (eval/eval (lread/read interactive))
              seq? (eval/eval interactive)
              nil? nil
              (mapcat parse-interactive (s/split interactive #&quot;\n&quot;)))]
    (when record-flag
      (el/setq command-history (alloc/cons (alloc/cons f args) (data/symbol-value 'command-history))))
    (apply eval/funcall f args)))</pre></td></tr><tr><td class="docs"><p>Return numeric meaning of raw prefix argument RAW.
  A raw prefix argument is what you get from `(interactive "P")'.
  Its numeric meaning is what you would get from `(interactive "p")'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun prefix-numeric-value (raw)
  (if (data/numberp raw)
    (int raw)
    1))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.alloc" name="deuce.emacs.alloc"><h1 class="project-name">deuce.emacs.alloc</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.alloc
  (:use [deuce.emacs-lisp :only (defun defvar) :as el]
        [taoensso.timbre :as timbre
         :only (trace debug info warn error fatal spy)])
  (:require [clojure.core :as c]
            [clojure.walk :as w]
            [deuce.emacs-lisp.cons :as cons])
  (:refer-clojure :exclude [vector cons list])
  (:import [java.util Arrays]
           [java.lang.management ManagementFactory MemoryNotificationInfo MemoryType MemoryPoolMXBean]
           [javax.management NotificationListener NotificationEmitter Notification]))</pre></td></tr><tr><td class="docs"><p>Non-nil means loading Lisp code in order to dump an executable.
  This means that certain objects should be allocated in shared (pure) space.
  It can also be set to a hash-table, in which case this table is used to
  do hash-consing of the objects allocated to pure space.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar purify-flag nil)</pre></td></tr><tr><td class="docs"><p>Number of cons cells that have been consed so far.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar cons-cells-consed nil)</pre></td></tr><tr><td class="docs"><p>Number of symbols that have been consed so far.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar symbols-consed nil)</pre></td></tr><tr><td class="docs"><p>Hook run after garbage collection has finished.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar post-gc-hook nil)</pre></td></tr><tr><td class="docs"><p>*Portion of the heap used for allocation.
  Garbage collection can happen automatically once this portion of the heap
  has been allocated since the last garbage collection.
  If this portion is smaller than `gc-cons-threshold', this is ignored.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar gc-cons-percentage nil)</pre></td></tr><tr><td class="docs"><p>Accumulated number of garbage collections done.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar gcs-done nil)</pre></td></tr><tr><td class="docs"><p>Accumulated time elapsed in garbage collections.
  The time is in seconds as a floating point value.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar gc-elapsed nil)</pre></td></tr><tr><td class="docs"><p>*Number of bytes of consing between garbage collections.
  Garbage collection can happen automatically once this many bytes have been
  allocated since the last garbage collection.  All data types count.</p>

<p>  Garbage collection happens automatically only when `eval' is called.</p>

<p>  By binding this temporarily to a large number, you can effectively
  prevent garbage collection during a part of the program.
  See also `gc-cons-percentage'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar gc-cons-threshold nil)</pre></td></tr><tr><td class="docs"><p>Precomputed `signal' argument for memory-full error.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar memory-signal-data nil)</pre></td></tr><tr><td class="docs"><p>Number of string characters that have been consed so far.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar string-chars-consed nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means Emacs cannot get much more Lisp memory.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar memory-full nil)</pre></td></tr><tr><td class="docs"><p>Number of vector cells that have been consed so far.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar vector-cells-consed nil)</pre></td></tr><tr><td class="docs"><p>Number of miscellaneous objects that have been consed so far.
  These include markers and overlays, plus certain objects not visible
  to users.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar misc-objects-consed nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means display messages at start and end of garbage collection.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar garbage-collection-messages nil)</pre></td></tr><tr><td class="docs"><p>Number of bytes of shareable Lisp data allocated so far.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar pure-bytes-used nil)</pre></td></tr><tr><td class="docs"><p>Number of intervals that have been consed so far.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar intervals-consed nil)</pre></td></tr><tr><td class="docs"><p>Number of strings that have been consed so far.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar strings-consed nil)</pre></td></tr><tr><td class="docs"><p>Number of floats that have been consed so far.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar floats-consed nil)</pre></td></tr><tr><td class="docs"><p>From http://www.javaspecialists.eu/archive/Issue092.html</p>
</td><td class="codes"><pre class="brush: clojure">(let [^MemoryPoolMXBean tenured-gen-pool (-&gt;&gt; (ManagementFactory/getMemoryPoolMXBeans)
                                              (filter (fn [^MemoryPoolMXBean mb]
                                                        (and (= (.getType mb) MemoryType/HEAP) (.isUsageThresholdSupported mb))))
                                              first)
      warning-level 0.8]
  (.setUsageThreshold tenured-gen-pool
                      (long (* warning-level (.getMax (.getUsage tenured-gen-pool)))))
  (.addNotificationListener ^NotificationEmitter (ManagementFactory/getMemoryMXBean)
                            (proxy [NotificationListener] []
                              (handleNotification [^Notification n hb]
                                (when (= (.getType n) MemoryNotificationInfo/MEMORY_THRESHOLD_EXCEEDED)
                                  (el/setq memory-full true)))) nil nil))</pre></td></tr><tr><td class="docs"><p>Return a new bool-vector of length LENGTH, using INIT for each element.
  LENGTH must be a number.  INIT matters only in whether it is t or nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-bool-vector (length init))</pre></td></tr><tr><td class="docs"><p>Create a byte-code object with specified arguments as elements.
  The arguments should be the ARGLIST, bytecode-string BYTE-CODE, constant
  vector CONSTANTS, maximum stack size DEPTH, (optional) DOCSTRING,
  and (optional) INTERACTIVE-SPEC.
  The first four arguments are required; at most six have any
  significance.
  The ARGLIST can be either like the one of `lambda', in which case the arguments
  will be dynamically bound before executing the byte code, or it can be an
  integer of the form NNNNNNNRMMMMMMM where the 7bit MMMMMMM specifies the
  minimum number of arguments, the 7-bit NNNNNNN specifies the maximum number
  of arguments (ignoring &amp;rest) and the R bit specifies whether there is a &amp;rest
  argument to catch the left-over arguments.  If such an integer is used, the
  arguments will not be dynamically bound but will be instead pushed on the
  stack before executing the byte-code.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-byte-code (arglist byte-code constants depth &amp;optional docstring interactive-spec &amp;rest elements))</pre></td></tr><tr><td class="docs"><p>Return a list of counters that measure how much consing there has been.
  Each of these counters increments for a certain kind of object.
  The counters wrap around from the largest positive integer to zero.
  Garbage collection does not decrease them.
  The elements of the value are as follows:
    (CONSES FLOATS VECTOR-CELLS SYMBOLS STRING-CHARS MISCS INTERVALS STRINGS)
  All are in units of 1 = one object consed
  except for VECTOR-CELLS and STRING-CHARS, which count the total length of
  objects consed.
  MISCS include overlays, markers, and some internal types.
  Frames, windows, buffers, and subprocesses count as vectors
    (but the contents of a buffer's text do not count here).</p>
</td><td class="codes"><pre class="brush: clojure">(defun memory-use-counts ())</pre></td></tr><tr><td class="docs"><p>Return a newly created vector with specified arguments as elements.
  Any number of arguments, even zero arguments, are allowed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun vector (&amp;rest objects)
  (object-array objects))</pre></td></tr><tr><td class="docs"><p>Concatenate all the argument characters and make the result a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defun string (&amp;rest characters)
  ;; Guard against interning as we allow modifications of String.value for now.
  (apply str characters))</pre></td></tr><tr><td class="docs"><p>Return a newly allocated marker which does not point at any place.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-marker ()
  ((ns-resolve 'deuce.emacs.buffer 'allocate-marker) nil nil nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare list)</pre></td></tr><tr><td class="docs"><p>Reclaim storage for Lisp objects no longer needed.
  Garbage collection happens automatically if you cons more than
  `gc-cons-threshold' bytes of Lisp data since previous garbage collection.
  `garbage-collect' normally returns a list with info on amount of space in use:
   ((USED-CONSES . FREE-CONSES) (USED-SYMS . FREE-SYMS)
    (USED-MISCS . FREE-MISCS) USED-STRING-CHARS USED-VECTOR-SLOTS
    (USED-FLOATS . FREE-FLOATS) (USED-INTERVALS . FREE-INTERVALS)
    (USED-STRINGS . FREE-STRINGS))
  However, if there was overflow in pure space, `garbage-collect'
  returns nil, because real GC can't be done.
  See Info node `(elisp)Garbage Collection'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun garbage-collect ()
  (interactive)
  (System/gc)
  '(()))</pre></td></tr><tr><td class="docs"><p>Create a new cons, give it CAR and CDR as components, and return it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun cons (car cdr)
  (cons/pair (cons/maybe-seq car) (cons/maybe-seq cdr)))</pre></td></tr><tr><td class="docs"><p>Return t if first arg is not equal to second arg.  Both must be numbers or markers.</p>
</td><td class="codes"><pre class="brush: clojure">(defun #el/sym &quot;/=&quot; (num1 num2)
  (not ((ns-resolve 'deuce.emacs.data '=) num1 num2)))</pre></td></tr><tr><td class="docs"><p>Return a newly allocated uninterned symbol whose name is NAME.
  Its value and function definition are void, and its property list is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-symbol (name)
  (symbol name))</pre></td></tr><tr><td class="docs"><p>Make a copy of object OBJ in pure storage.
  Recursively copies contents of vectors and cons cells.
  Does not copy symbols.  Copies strings without text properties.</p>
</td><td class="codes"><pre class="brush: clojure">(defun purecopy (obj)
  (cons/maybe-seq obj))</pre></td></tr><tr><td class="docs"><p>Return the address of the last byte Emacs has allocated, divided by 1024.
  This may be helpful in debugging Emacs's memory usage.
  We divide the value by 1024 to make sure it fits in a Lisp integer.</p>
</td><td class="codes"><pre class="brush: clojure">(defun memory-limit ()
  (/ (.maxMemory (Runtime/getRuntime)) 1024))</pre></td></tr><tr><td class="docs"><p>Return a newly created vector of length LENGTH, with each element being INIT.
  See also the function `vector'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-vector (length init)
  (doto (object-array length)
    (Arrays/fill init)))</pre></td></tr><tr><td class="docs"><p>Return a newly created string of length LENGTH, with INIT in each element.
  LENGTH must be an integer.
  INIT must be an integer that represents a character.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-string (length init)
  (apply str (repeat length (char init))))</pre></td></tr><tr><td class="docs"><p>Return a newly created list of length LENGTH, with each element being INIT.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-list (length init)
  (apply list (repeat length init)))</pre></td></tr><tr><td class="docs"><p>Return a newly created list with specified arguments as elements.
  Any number of arguments, even zero arguments, are allowed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun list (&amp;rest objects)
  (apply cons/list objects))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.term" name="deuce.emacs.term"><h1 class="project-name">deuce.emacs.term</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.term
  (:use [deuce.emacs-lisp :only (defun defvar)])
  (:require [clojure.core :as c]
            [lanterna.screen :as s]
            [deuce.emacs.data :as data]
            [deuce.emacs.eval :as eval]
            [deuce.emacs.terminal :as terminal])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Functions to be run after suspending a tty.
  The functions are run with one argument, the terminal object to be suspended.
  See `suspend-tty'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar suspend-tty-functions nil)</pre></td></tr><tr><td class="docs"><p>Functions to be run after resuming a tty.
  The functions are run with one argument, the terminal object that was revived.
  See `resume-tty'.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar resume-tty-functions nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means to make the cursor very visible.
  This only has an effect when running in a text terminal.
  What means "very visible" is up to your terminal.  It may make the cursor
  bigger, or it may make it blink, or it may do nothing at all.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar visible-cursor nil)</pre></td></tr><tr><td class="docs"><p>Non-nil means the system uses terminfo rather than termcap.
  This variable can be used by terminal emulator packages.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar system-uses-terminfo nil)</pre></td></tr><tr><td class="docs"><p>Return non-nil if TERMINAL is the controlling tty of the Emacs process.</p>

<p>  TERMINAL can be a terminal object, a frame, or nil (meaning the
  selected frame's terminal).  This function always returns nil if
  TERMINAL is not on a tty device.</p>
</td><td class="codes"><pre class="brush: clojure">(defun controlling-tty-p (&amp;optional terminal)
  true)</pre></td></tr><tr><td class="docs"><p>Return non-nil if the tty device TERMINAL can display colors.</p>

<p>  TERMINAL can be a terminal object, a frame, or nil (meaning the
  selected frame's terminal).  This function always returns nil if
  TERMINAL does not refer to a text-only terminal.</p>
</td><td class="codes"><pre class="brush: clojure">(defun tty-display-color-p (&amp;optional terminal)
  true)</pre></td></tr><tr><td class="docs"><p>Declare that the tty used by TERMINAL does not handle underlining.
  This is used to override the terminfo data, for certain terminals that
  do not really do underlining, but say that they do.  This function has
  no effect if used on a non-tty terminal.</p>

<p>  TERMINAL can be a terminal object, a frame or nil (meaning the
  selected frame's terminal).  This function always returns nil if
  TERMINAL does not refer to a text-only terminal.</p>
</td><td class="codes"><pre class="brush: clojure">(defun tty-no-underline (&amp;optional terminal))</pre></td></tr><tr><td class="docs"><p>Return the type of the tty device that TERMINAL uses.
  Returns nil if TERMINAL is not on a tty device.</p>

<p>  TERMINAL can be a terminal object, a frame, or nil (meaning the
  selected frame's terminal).</p>
</td><td class="codes"><pre class="brush: clojure">(defun tty-type (&amp;optional terminal)
  &quot;lanterna&quot;)</pre></td></tr><tr><td class="docs"><p>Return the number of colors supported by the tty device TERMINAL.</p>

<p>  TERMINAL can be a terminal object, a frame, or nil (meaning the
  selected frame's terminal).  This function always returns 0 if
  TERMINAL does not refer to a text-only terminal.</p>
</td><td class="codes"><pre class="brush: clojure">(defun tty-display-color-cells (&amp;optional terminal)
  ({&quot;xterm-256color&quot; 256} (System/getenv &quot;TERM&quot;) 16))</pre></td></tr><tr><td class="docs"><p>Resume the previously suspended terminal device TTY.
  The terminal is opened and reinitialized.  Frames that are on the
  suspended terminal are revived.</p>

<p>  It is an error to resume a terminal while another terminal is active
  on the same device.</p>

<p>  This function runs `resume-tty-functions' after resuming the terminal.
  The functions are run with one arg, the id of the resumed terminal
  device.</p>

<p>  `resume-tty' does nothing if it is called on a device that is not
  suspended.</p>

<p>  TTY may be a terminal object, a frame, or nil (meaning the selected
  frame's terminal).</p>
</td><td class="codes"><pre class="brush: clojure">(defun resume-tty (&amp;optional tty)
  (when-let [terminal (terminal/frame-terminal)]
    (s/start terminal)
    ((ns-resolve 'deuce.main 'start-ui))
    (eval/run-hook-with-args 'resume-tty-functions terminal)))</pre></td></tr><tr><td class="docs"><p>Suspend the terminal device TTY.</p>

<p>  The device is restored to its default state, and Emacs ceases all
  access to the tty device.  Frames that use the device are not deleted,
  but input is not read from them and if they change, their display is
  not updated.</p>

<p>  TTY may be a terminal object, a frame, or nil for the terminal device
  of the currently selected frame.</p>

<p>  This function runs `suspend-tty-functions' after suspending the
  device.  The functions are run with one arg, the id of the suspended
  terminal device.</p>

<p>  `suspend-tty' does nothing if it is called on a device that is already
  suspended.</p>

<p>  A suspended tty may be resumed by calling `resume-tty' on it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun suspend-tty (&amp;optional tty)
  (when-let [terminal (terminal/frame-terminal)]
    ((ns-resolve 'deuce.main 'stop-ui))
    (s/stop terminal)
    (eval/run-hook-with-args 'suspend-tty-functions terminal)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.emacs" name="deuce.emacs.emacs"><h1 class="project-name">deuce.emacs.emacs</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.emacs
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.fns :as fns]
            [deuce.emacs.terminal :as terminal]
            [deuce.emacs-lisp.globals :as globals])
  (:import [java.io File])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Version numbers of this version of Emacs.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar emacs-version &quot;24.2&quot;)</pre></td></tr><tr><td class="docs"><p>Non-nil means Emacs is running without interactive terminal.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar noninteractive nil)</pre></td></tr><tr><td class="docs"><p>A directory within which to look for the <code>lib-src' and</code>etc' directories.
  In an installed Emacs, this is normally nil.  It is non-nil if
  both <code>lib-src' (on MS-DOS,</code>info') and `etc' directories are found
  within the variable `invocation-directory' or its parent.  For example,
  this is the case when running an uninstalled Emacs executable from its
  build directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar installation-directory nil)</pre></td></tr><tr><td class="docs"><p>The directory in which the Emacs executable was found, to run it.
  The value is nil if that directory's name is not known.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar invocation-directory nil)</pre></td></tr><tr><td class="docs"><p>Most recently used system locale for messages.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar previous-system-messages-locale nil)</pre></td></tr><tr><td class="docs"><p>The value is a symbol indicating the type of operating system you are using.
  Special values:
    `gnu'          compiled for a GNU Hurd system.
    `gnu/linux'    compiled for a GNU/Linux system.
    `gnu/kfreebsd' compiled for a GNU system with a FreeBSD kernel.
    `darwin'       compiled for Darwin (GNU-Darwin, Mac OS X, ...).
    `ms-dos'       compiled as an MS-DOS application.
    `windows-nt'   compiled as a native W32 application.
    `cygwin'       compiled using the Cygwin library.
  Anything else (in Emacs 24.1, the possibilities are: aix, berkeley-unix,
  hpux, irix, usg-unix-v) indicates some sort of Unix system.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar system-type (symbol &quot;jvm&quot;))</pre></td></tr><tr><td class="docs"><p>If non-nil, X resources, Windows Registry settings, and NS defaults are not used.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar inhibit-x-resources nil)</pre></td></tr><tr><td class="docs"><p>String containing the configuration options Emacs was built with.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar system-configuration-options nil)</pre></td></tr><tr><td class="docs"><p>Args passed by shell to Emacs, as a list of strings.
  Many arguments are deleted from the list as they are processed.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar command-line-args (alloc/list &quot;src/bootstrap-emacs&quot; &quot;-no-init-file&quot;))</pre></td></tr><tr><td class="docs"><p>The program name that was used to run Emacs.
  Any directory names are omitted.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar invocation-name nil)</pre></td></tr><tr><td class="docs"><p>System locale for messages.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar system-messages-locale nil)</pre></td></tr><tr><td class="docs"><p>Alist of dynamic libraries vs external files implementing them.
  Each element is a list (LIBRARY FILE...), where the car is a symbol
  representing a supported external library, and the rest are strings giving
  alternate filenames for that library.</p>

<p>  Emacs tries to load the library from the files in the order they appear on
  the list; if none is loaded, the running session of Emacs won't have access
  to that library.</p>

<p>  Note that image types <code>pbm' and</code>xbm' do not need entries in this variable
  because they do not depend on external libraries and are always available.</p>

<p>  Also note that this is not a generic facility for accessing external
  libraries; only those already known by Emacs will be loaded.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar dynamic-library-alist nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fns/put 'dynamic-library-alist 'risky-local-variable true)</pre></td></tr><tr><td class="docs"><p>Short copyright string for this version of Emacs.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar emacs-copyright &quot;Copyright (C) 2012 Free Software Foundation, Inc.&quot;)</pre></td></tr><tr><td class="docs"><p>System locale for time.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar system-time-locale nil)</pre></td></tr><tr><td class="docs"><p>String containing the character that separates directories in
  search paths, such as PATH and other similar environment variables.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar path-separator File/pathSeparator)</pre></td></tr><tr><td class="docs"><p>Value is string indicating configuration Emacs was built for.
  On MS-Windows, the value reflects the OS flavor and version on which
  Emacs is running.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar system-configuration (format &quot;jvm-%s_clojure-%s&quot;
                                     (System/getProperty &quot;java.version&quot;)
                                     (clojure-version)))</pre></td></tr><tr><td class="docs"><p>Hook to be run when `kill-emacs' is called.
  Since `kill-emacs' may be invoked when the terminal is disconnected (or
  in other similar situations), functions placed on this hook should not
  expect to be able to interact with the user.  To ask for confirmation,
  see `kill-emacs-query-functions' instead.</p>

<p>  Before Emacs 24.1, the hook was not run in batch mode, i.e., if
  `noninteractive' was non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar kill-emacs-hook nil)</pre></td></tr><tr><td class="docs"><p>Value of `current-time' before Emacs begins initialization.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar before-init-time nil)</pre></td></tr><tr><td class="docs"><p>Value of `current-time' after loading the init files.
  This is nil during initialization.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar after-init-time nil)</pre></td></tr><tr><td class="docs"><p>Most recently used system locale for time.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar previous-system-time-locale nil)</pre></td></tr><tr><td class="docs"><p>Return the directory name in which the Emacs executable was located.</p>
</td><td class="codes"><pre class="brush: clojure">(defun invocation-directory ())</pre></td></tr><tr><td class="docs"><p>Return the program name that was used to run Emacs.
  Any directory names are omitted.</p>
</td><td class="codes"><pre class="brush: clojure">(defun invocation-name ())</pre></td></tr><tr><td class="docs"><p>Mark the Emacs daemon as being initialized.
  This finishes the daemonization process by doing the other half of detaching
  from the parent process and its tty file descriptors.</p>
</td><td class="codes"><pre class="brush: clojure">(defun daemon-initialized ()
  (el/throw 'error &quot;This function can only be called if emacs is run as a daemon&quot;))</pre></td></tr><tr><td class="docs"><p>Return non-nil if the current emacs process is a daemon.
  If the daemon was given a name argument, return that name.</p>
</td><td class="codes"><pre class="brush: clojure">(defun daemonp ()
  nil)</pre></td></tr><tr><td class="docs"><p>Exit the Emacs job and kill it.
  If ARG is an integer, return ARG as the exit program code.
  If ARG is a string, stuff it as keyboard input.</p>

<p>  This function is called upon receipt of the signals SIGTERM
  or SIGHUP, and upon SIGINT in batch mode.</p>

<p>  The value of `kill-emacs-hook', if not void,
  is a list of functions (of no args),
  all of which are called before Emacs is actually killed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun kill-emacs (&amp;optional arg)
  (interactive &quot;P&quot;)
  (doall (map #(%) globals/kill-emacs-hook))
  (terminal/delete-terminal)
  (System/exit (if (integer? arg) arg 0)))</pre></td></tr><tr><td class="docs"><p>Dump current state of Emacs into executable file FILENAME.
  Take symbols from SYMFILE (presumably the file you executed to run Emacs).
  This is used in the file `loadup.el' when building Emacs.</p>

<p>  You must run Emacs in batch mode in order to dump it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun dump-emacs (filename symfile))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs.frame" name="deuce.emacs.frame"><h1 class="project-name">deuce.emacs.frame</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs.frame
  (:use [deuce.emacs-lisp :only (defun defvar) :as el])
  (:require [clojure.core :as c]
            [lanterna.screen :as s]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.buffer :as buffer]
            [deuce.emacs.data :as data]
            [deuce.emacs-lisp.cons :as cons]
            [deuce.emacs-lisp.globals :as globals])
  (:import [deuce.emacs.data Frame Window])
  (:refer-clojure :exclude []))</pre></td></tr><tr><td class="docs"><p>Non-nil if Menu-Bar mode is enabled.
  See the command `menu-bar-mode' for a description of this minor mode.
  Setting this variable directly does not take effect;
  either customize it (see the info node `Easy Customization')
  or call the function `menu-bar-mode'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar menu-bar-mode true)</pre></td></tr><tr><td class="docs"><p>Functions to be run before deleting a frame.
  The functions are run with one arg, the frame to be deleted.
  See `delete-frame'.</p>

<p>  Note that functions in this list may be called just before the frame is
  actually deleted, or some time later (or even both when an earlier function
  in <code>delete-frame-functions' (indirectly) calls</code>delete-frame'
  recursively).</p>
</td><td class="codes"><pre class="brush: clojure">(defvar delete-frame-functions nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, make pointer invisible while typing.
  The pointer becomes visible again when the mouse is moved.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar make-pointer-invisible nil)</pre></td></tr><tr><td class="docs"><p>Name of window system through which the selected frame is displayed.
  The value is a symbol:
   nil for a termcap frame (a character-only terminal),
   'x' for an Emacs frame that is really an X window,
   'w32' for an Emacs frame that is a window on MS-Windows display,
   'ns' for an Emacs frame on a GNUstep or Macintosh Cocoa display,
   'pc' for a direct-write MS-DOS frame.</p>

<p>  Use of this variable as a boolean is deprecated.  Instead,
  use <code>display-graphic-p' or any of the other</code>display-*-p'
  predicates which report frame's specific UI-related capabilities.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar window-system nil)</pre></td></tr><tr><td class="docs"><p>The initial frame-object, which represents Emacs's stdout.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar terminal-frame nil)</pre></td></tr><tr><td class="docs"><p>Alist of default values for frame creation.
  These may be set in your init file, like this:
    (setq default-frame-alist '((width . 80) (height . 55) (menu-bar-lines . 1)))
  These override values given in window system configuration data,
   including X Windows' defaults database.
  For values specific to the first Emacs frame, see `initial-frame-alist'.
  For window-system specific values, see `window-system-default-frame-alist'.
  For values specific to the separate minibuffer frame, see
   `minibuffer-frame-alist'.
  The `menu-bar-lines' element of the list controls whether new frames
   have menu bars; `menu-bar-mode' works by altering this element.
  Setting this variable does not affect existing frames, only new ones.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-frame-alist nil)</pre></td></tr><tr><td class="docs"><p>Non-nil if window system changes focus when you move the mouse.
  You should set this variable to tell Emacs how your window manager
  handles focus, since there is no way in general for Emacs to find out
  automatically.  See also `mouse-autoselect-window'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar focus-follows-mouse nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, clickable text is highlighted when mouse is over it.
  If the value is an integer, highlighting is only shown after moving the
  mouse, while keyboard input turns off the highlight even when the mouse
  is over the clickable text.  However, the mouse shape still indicates
  when the mouse is over clickable text.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar mouse-highlight nil)</pre></td></tr><tr><td class="docs"><p>Non-nil if Tool-Bar mode is enabled.
  See the command `tool-bar-mode' for a description of this minor mode.
  Setting this variable directly does not take effect;
  either customize it (see the info node `Easy Customization')
  or call the function `tool-bar-mode'.</p>

<p>  You can customize this variable.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar tool-bar-mode nil)</pre></td></tr><tr><td class="docs"><p>If non-nil, function to transform normal value of `mouse-position'.
  `mouse-position' calls this function, passing its usual return value as
  argument, and returns whatever this function returns.
  This abnormal hook exists for the benefit of packages like `xt-mouse.el'
  which need to do mouse handling at the Lisp level.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar mouse-position-function nil)</pre></td></tr><tr><td class="docs"><p>Default position of scroll bars on this window-system.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-frame-scroll-bars 'right)</pre></td></tr><tr><td class="docs"><p>Minibufferless frames use this frame's minibuffer.</p>

<p>  Emacs cannot create minibufferless frames unless this is set to an
  appropriate surrogate.</p>

<p>  Emacs consults this variable only when creating minibufferless
  frames; once the frame is created, it sticks with its assigned
  minibuffer, no matter what this variable is set to.  This means that
  this variable doesn't necessarily say anything meaningful about the
  current set of frames, or where the minibuffer is currently being
  displayed.</p>

<p>  This variable is local to the current terminal and cannot be buffer-local.</p>
</td><td class="codes"><pre class="brush: clojure">(defvar default-minibuffer-frame globals/terminal-frame)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private make-initial-frame []
  (let [allocate-window (ns-resolve 'deuce.emacs.window 'allocate-window)
        root-window (allocate-window false nil 0 1 10 9)
        selected-window (atom root-window)
        minibuffer-window (allocate-window true nil 0 9 10 1)
        terminal (atom nil)]
    (reset! (.next ^Window root-window) minibuffer-window)
    (reset! (.prev ^Window minibuffer-window) root-window)
    (Frame. &quot;F1&quot; root-window selected-window minibuffer-window terminal)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare selected-frame frame-pixel-width frame-pixel-height)</pre></td></tr><tr><td class="docs"><p>Delete FRAME, permanently eliminating it from use.
  FRAME defaults to the selected frame.</p>

<p>  A frame may not be deleted if its minibuffer is used by other frames.
  Normally, you may not delete a frame if all other frames are invisible,
  but if the second optional argument FORCE is non-nil, you may do so.</p>

<p>  This function runs `delete-frame-functions' before actually
  deleting the frame, unless the frame is a tooltip.
  The functions are run with one argument, the frame to be deleted.</p>
</td><td class="codes"><pre class="brush: clojure">(defun delete-frame (&amp;optional frame force)
  (interactive))</pre></td></tr><tr><td class="docs"><p>Send FRAME to the back, so it is occluded by any frames that overlap it.
  If you don't specify a frame, the selected frame is used.
  If Emacs is displaying on an ordinary terminal or some other device which
  doesn't support multiple overlapping frames, this function does nothing.</p>
</td><td class="codes"><pre class="brush: clojure">(defun lower-frame (&amp;optional frame)
  (interactive))</pre></td></tr><tr><td class="docs"><p>Bring FRAME to the front, so it occludes any frames it overlaps.
  If FRAME is invisible or iconified, make it visible.
  If you don't specify a frame, the selected frame is used.
  If Emacs is displaying on an ordinary terminal or some other device which
  doesn't support multiple overlapping frames, this function selects FRAME.</p>
</td><td class="codes"><pre class="brush: clojure">(defun raise-frame (&amp;optional frame)
  (interactive))</pre></td></tr><tr><td class="docs"><p>Return the parameters-alist of frame FRAME.
  It is a list of elements of the form (PARM . VALUE), where PARM is a symbol.
  The meaningful PARMs depend on the kind of frame.
  If FRAME is omitted, return information on the currently selected frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-parameters (&amp;optional frame)
  (let [frame (el/check-type 'framep (or frame (selected-frame)))]
    (list (cons/pair 'width (frame-pixel-width frame))
          (cons/pair 'height (frame-pixel-height frame))
          (cons/pair 'name (.name ^Frame frame)))))</pre></td></tr><tr><td class="docs"><p>Return FRAME's value for parameter PARAMETER.
  If FRAME is nil, describe the currently selected frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-parameter (frame parameter)
  ((el/fun 'assq) parameter (frame-parameters (or frame (selected-frame)))))</pre></td></tr><tr><td class="docs"><p>Return non-nil if OBJECT is a frame.
  Value is:
    t for a termcap frame (a character-only terminal),
   'x' for an Emacs frame that is really an X window,
   'w32' for an Emacs frame that is a window on MS-Windows display,
   'ns' for an Emacs frame on a GNUstep or Macintosh Cocoa display,
   'pc' for a direct-write MS-DOS frame.
  See also `frame-live-p'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun framep (object)
  (instance? Frame object))</pre></td></tr><tr><td class="docs"><p>Return t if FRAME is "visible" (actually in use for display).
  Return the symbol `icon' if FRAME is iconified or "minimized".
  Return nil if FRAME was made invisible, via `make-frame-invisible'.
  On graphical displays, invisible frames are not updated and are
  usually not displayed at all, even in a window system's "taskbar".</p>

<p>  If FRAME is a text-only terminal frame, this always returns t.
  Such frames are always considered visible, whether or not they are
  currently being displayed on the terminal.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-visible-p (frame)
  (framep frame))</pre></td></tr><tr><td class="docs"><p>Create an additional terminal frame, possibly on another terminal.
  This function takes one argument, an alist specifying frame parameters.</p>

<p>  You can create multiple frames on a single text-only terminal, but
  only one of them (the selected terminal frame) is actually displayed.</p>

<p>  In practice, generally you don't need to specify any parameters,
  except when you want to create a new frame on another terminal.
  In that case, the `tty' parameter specifies the device file to open,
  and the `tty-type' parameter specifies the terminal type.  Example:</p>

<pre><code> (make-terminal-frame '((tty . "/dev/pts/5") (tty-type . "xterm")))
</code></pre>

<p>  Note that changing the size of one terminal frame automatically
  affects all frames on the same terminal device.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-terminal-frame (parms))</pre></td></tr><tr><td class="docs"><p>Modify the parameters of frame FRAME according to ALIST.
  If FRAME is nil, it defaults to the selected frame.
  ALIST is an alist of parameters to change and their new values.
  Each element of ALIST has the form (PARM . VALUE), where PARM is a symbol.
  The meaningful PARMs depend on the kind of frame.
  Undefined PARMs are ignored, but stored in the frame's parameter list
  so that `frame-parameters' will return them.</p>

<p>  The value of frame parameter FOO can also be accessed
  as a frame-local binding for the variable FOO, if you have
  enabled such bindings for that variable with `make-variable-frame-local'.
  Note that this functionality is obsolete as of Emacs 22.2, and its
  use is not recommended.  Explicitly check for a frame-parameter instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defun modify-frame-parameters (frame alist))</pre></td></tr><tr><td class="docs"><p>Handle a switch-frame event EVENT.
  Switch-frame events are usually bound to this function.
  A switch-frame event tells Emacs that the window manager has requested
  that the user's events be directed to the frame mentioned in the event.
  This function selects the selected window of the frame of EVENT.</p>

<p>  If EVENT is frame object, handle it as if it were a switch-frame event
  to that frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun handle-switch-frame (event)
  (interactive &quot;e&quot;))</pre></td></tr><tr><td class="docs"><p>Make the frame FRAME visible (assuming it is an X window).
  If omitted, FRAME defaults to the currently selected frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-frame-visible (&amp;optional frame)
  (interactive))</pre></td></tr><tr><td class="docs"><p>Return a list of all live frames.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-list ()
  (alloc/list (selected-frame)))</pre></td></tr><tr><td class="docs"><p>Sets size of FRAME to COLS by ROWS, measured in characters.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-frame-size (frame cols rows))</pre></td></tr><tr><td class="docs"><p>The name of the window system that FRAME is displaying through.
  The value is a symbol:
   nil for a termcap frame (a character-only terminal),
   'x' for an Emacs frame that is really an X window,
   'w32' for an Emacs frame that is a window on MS-Windows display,
   'ns' for an Emacs frame on a GNUstep or Macintosh Cocoa display,
   'pc' for a direct-write MS-DOS frame.</p>

<p>  FRAME defaults to the currently selected frame.</p>

<p>  Use of this function as a predicate is deprecated.  Instead,
  use <code>display-graphic-p' or any of the other</code>display-*-p'
  predicates which report frame's specific UI-related capabilities.</p>
</td><td class="codes"><pre class="brush: clojure">(defun window-system (&amp;optional frame)
  nil)</pre></td></tr><tr><td class="docs"><p>Return the previous frame in the frame list before FRAME.
  It considers only frames on the same terminal as FRAME.
  By default, skip minibuffer-only frames.
  If omitted, FRAME defaults to the selected frame.
  If optional argument MINIFRAME is nil, exclude minibuffer-only frames.
  If MINIFRAME is a window, include only its own frame
  and any frame now using that window as the minibuffer.
  If MINIFRAME is `visible', include all visible frames.
  If MINIFRAME is 0, include all visible and iconified frames.
  Otherwise, include all frames.</p>
</td><td class="codes"><pre class="brush: clojure">(defun previous-frame (&amp;optional frame miniframe))</pre></td></tr><tr><td class="docs"><p>Move the mouse pointer to pixel position (X,Y) in FRAME.
  The position is given in pixels, where (0, 0) is the upper-left corner
  of the frame, X is the horizontal offset, and Y is the vertical offset.</p>

<p>  Note, this is a no-op for an X frame that is not visible.
  If you have just created a frame, you must wait for it to become visible
  before calling this function on it, like this.
    (while (not (frame-visible-p frame)) (sleep-for .5))</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-mouse-pixel-position (frame x y))</pre></td></tr><tr><td class="docs"><p>Return a FRAME's height in pixels.
  If FRAME is omitted, the selected frame is used.  The exact value
  of the result depends on the window-system and toolkit in use:</p>

<p>  In the Gtk+ version of Emacs, it includes only any window (including
  the minibuffer or echo area), mode line, and header line.  It does not
  include the tool bar or menu bar.</p>

<p>  With the Motif or Lucid toolkits, it also includes the tool bar (but
  not the menu bar).</p>

<p>  In a graphical version with no toolkit, it includes both the tool bar
  and menu bar.</p>

<p>  For a text-only terminal, it includes the menu bar.  In this case, the
  result is really in characters rather than pixels (i.e., is identical
  to `frame-height').</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-pixel-height (&amp;optional frame)
  (let [^Frame frame (el/check-type 'framep (or frame (selected-frame)))]
    (if-let [s  @(.terminal frame)]
      (second (s/get-size s))
      0)))</pre></td></tr><tr><td class="docs"><p>Return non-nil if OBJECT is a frame which has not been deleted.
  Value is nil if OBJECT is not a live frame.  If object is a live
  frame, the return value indicates what sort of terminal device it is
  displayed on.  See the documentation of `framep' for possible
  return values.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-live-p (object)
  (framep object))</pre></td></tr><tr><td class="docs"><p>Specify that the frame FRAME has COLS columns.
  Optional third arg non-nil means that redisplay should use COLS columns
  but that the idea of the actual width of the frame should not be changed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-frame-width (frame cols &amp;optional pretend))</pre></td></tr><tr><td class="docs"><p>Select FRAME.
  Subsequent editing commands apply to its selected window.
  Optional argument NORECORD means to neither change the order of
  recently selected windows nor the buffer list.</p>

<p>  The selection of FRAME lasts until the next time the user does
  something to select a different frame, or until the next time
  this function is called.  If you are using a window system, the
  previously selected frame may be restored as the selected frame
  when returning to the command loop, because it still may have
  the window system's input focus.  On a text-only terminal, the
  next redisplay will display FRAME.</p>

<p>  This function returns FRAME, or nil if FRAME has been deleted.</p>
</td><td class="codes"><pre class="brush: clojure">(defun select-frame (frame &amp;optional norecord)
  (interactive &quot;e&quot;))</pre></td></tr><tr><td class="docs"><p>Return the next frame in the frame list after FRAME.
  It considers only frames on the same terminal as FRAME.
  By default, skip minibuffer-only frames.
  If omitted, FRAME defaults to the selected frame.
  If optional argument MINIFRAME is nil, exclude minibuffer-only frames.
  If MINIFRAME is a window, include only its own frame
  and any frame now using that window as the minibuffer.
  If MINIFRAME is `visible', include all visible frames.
  If MINIFRAME is 0, include all visible and iconified frames.
  Otherwise, include all frames.</p>
</td><td class="codes"><pre class="brush: clojure">(defun next-frame (&amp;optional frame miniframe))</pre></td></tr><tr><td class="docs"><p>Return FRAME's width in pixels.
  For a terminal frame, the result really gives the width in characters.
  If FRAME is omitted, the selected frame is used.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-pixel-width (&amp;optional frame)
  (let [^Frame frame (el/check-type 'framep (or frame (selected-frame)))]
    (if-let [s @(.terminal frame)]
      (first (s/get-size s))
      0)))</pre></td></tr><tr><td class="docs"><p>Specify that the frame FRAME has LINES lines.
  Optional third arg non-nil means that redisplay should use LINES lines
  but that the idea of the actual height of the frame should not be changed.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-frame-height (frame lines &amp;optional pretend))</pre></td></tr><tr><td class="docs"><p>Return the frame to which FRAME's keystrokes are currently being sent.
  This returns nil if FRAME's focus is not redirected.
  See `redirect-frame-focus'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-focus (frame))</pre></td></tr><tr><td class="docs"><p>Return t if the mouse pointer displayed on FRAME is visible.
  Otherwise it returns nil.  FRAME omitted or nil means the
  selected frame.  This is useful when `make-pointer-invisible' is set.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-pointer-visible-p (&amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Sets position of FRAME in pixels to XOFFSET by YOFFSET.
  This is actually the position of the upper left corner of the frame.
  Negative values for XOFFSET or YOFFSET are interpreted relative to
  the rightmost or bottommost possible position (that stays within the screen).</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-frame-position (frame xoffset yoffset))</pre></td></tr><tr><td class="docs"><p>Make the frame FRAME into an icon.
  If omitted, FRAME defaults to the currently selected frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defun iconify-frame (&amp;optional frame)
  (interactive))</pre></td></tr><tr><td class="docs"><p>Make the frame FRAME invisible.
  If omitted, FRAME defaults to the currently selected frame.
  On graphical displays, invisible frames are not updated and are
  usually not displayed at all, even in a window system's "taskbar".</p>

<p>  Normally you may not make FRAME invisible if all other frames are invisible,
  but if the second optional argument FORCE is non-nil, you may do so.</p>

<p>  This function has no effect on text-only terminal frames.  Such frames
  are always considered visible, whether or not they are currently being
  displayed in the terminal.</p>
</td><td class="codes"><pre class="brush: clojure">(defun make-frame-invisible (&amp;optional frame force)
  (interactive))</pre></td></tr><tr><td class="docs"><p>Width in pixels of characters in the font in frame FRAME.
  If FRAME is omitted, the selected frame is used.
  On a graphical screen, the width is the standard width of the default font.
  For a terminal screen, the value is always 1.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-char-width (&amp;optional frame)
  1)</pre></td></tr><tr><td class="docs"><p>Return a list (FRAME X . Y) giving the current mouse frame and position.
  The position is given in character cells, where (0, 0) is the
  upper-left corner of the frame, X is the horizontal offset, and Y is
  the vertical offset.
  If Emacs is running on a mouseless terminal or hasn't been programmed
  to read the mouse position, it returns the selected frame for FRAME
  and nil for X and Y.
  If <code>mouse-position-function' is non-nil,</code>mouse-position' calls it,
  passing the normal return value to that function as an argument,
  and returns whatever that function returns.</p>
</td><td class="codes"><pre class="brush: clojure">(defun mouse-position ())</pre></td></tr><tr><td class="docs"><p>Move the mouse pointer to the center of character cell (X,Y) in FRAME.
  Coordinates are relative to the frame, not a window,
  so the coordinates of the top left character in the frame
  may be nonzero due to left-hand scroll bars or the menu bar.</p>

<p>  The position is given in character cells, where (0, 0) is the
  upper-left corner of the frame, X is the horizontal offset, and Y is
  the vertical offset.</p>

<p>  This function is a no-op for an X frame that is not visible.
  If you have just created a frame, you must wait for it to become visible
  before calling this function on it, like this.
    (while (not (frame-visible-p frame)) (sleep-for .5))</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-mouse-position (frame x y))</pre></td></tr><tr><td class="docs"><p>Return the frame that is now selected.</p>
</td><td class="codes"><pre class="brush: clojure">(defun selected-frame ()
  globals/terminal-frame)</pre></td></tr><tr><td class="docs"><p>Arrange for keystrokes typed at FRAME to be sent to FOCUS-FRAME.
  In other words, switch-frame events caused by events in FRAME will
  request a switch to FOCUS-FRAME, and `last-event-frame' will be
  FOCUS-FRAME after reading an event typed at FRAME.</p>

<p>  If FOCUS-FRAME is omitted or nil, any existing redirection is
  canceled, and the frame again receives its own keystrokes.</p>

<p>  Focus redirection is useful for temporarily redirecting keystrokes to
  a surrogate minibuffer frame when a frame doesn't have its own
  minibuffer window.</p>

<p>  A frame's focus redirection can be changed by `select-frame'.  If frame
  FOO is selected, and then a different frame BAR is selected, any
  frames redirecting their focus to FOO are shifted to redirect their
  focus to BAR.  This allows focus redirection to work properly when the
  user switches from one frame to another using `select-window'.</p>

<p>  This means that a frame whose focus is redirected to itself is treated
  differently from a frame whose focus is redirected to nil; the former
  is affected by `select-frame', while the latter is not.</p>

<p>  The redirection lasts until `redirect-frame-focus' is called to change it.</p>
</td><td class="codes"><pre class="brush: clojure">(defun redirect-frame-focus (frame &amp;optional focus-frame))</pre></td></tr><tr><td class="docs"><p>Return width in pixels of FRAME's tool bar.
  The result is greater than zero only when the tool bar is on the left
  or right side of FRAME.  If FRAME is omitted, the selected frame is
  used.</p>
</td><td class="codes"><pre class="brush: clojure">(defun tool-bar-pixel-width (&amp;optional frame))</pre></td></tr><tr><td class="docs"><p>Return a list of all frames now "visible" (being updated).</p>
</td><td class="codes"><pre class="brush: clojure">(defun visible-frame-list ()
  (frame-list))</pre></td></tr><tr><td class="docs"><p>Height in pixels of a line in the font in frame FRAME.
  If FRAME is omitted, the selected frame is used.
  For a terminal frame, the value is always 1.</p>
</td><td class="codes"><pre class="brush: clojure">(defun frame-char-height (&amp;optional frame)
  1)</pre></td></tr><tr><td class="docs"><p>Return a list (FRAME X . Y) giving the current mouse frame and position.
  The position is given in pixel units, where (0, 0) is the
  upper-left corner of the frame, X is the horizontal offset, and Y is
  the vertical offset.
  If Emacs is running on a mouseless terminal or hasn't been programmed
  to read the mouse position, it returns the selected frame for FRAME
  and nil for X and Y.</p>
</td><td class="codes"><pre class="brush: clojure">(defun mouse-pixel-position ())</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs-lisp.globals" name="deuce.emacs-lisp.globals"><h1 class="project-name">deuce.emacs-lisp.globals</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs-lisp.globals
  (:refer-clojure :only []))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs-lisp.printer" name="deuce.emacs-lisp.printer"><h1 class="project-name">deuce.emacs-lisp.printer</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs-lisp.printer
  (:require [clojure.java.io :as io]
            [clojure.string :as s]
            [fipp.edn :as fp-edn]
            [fipp.clojure :as fp]
            [deuce.emacs-lisp :as el]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *pretty-style* :el)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol fp/IPretty
  java.lang.Object
  (-pretty [x ctx]
    (binding [*print-dup* true]
      [:text (pr-str x)]))

  clojure.lang.ISeq
  (-pretty [s ctx]
    (if-let [pretty-special (get (:symbols ctx) (first s))]
      (pretty-special s ctx)
      (fp/list-group [:align (if (symbol? (first s)) 1 0) (interpose :line (map #(fp/pretty % ctx) s))]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol fp-edn/IPretty
  java.lang.Object
  (-pretty [x ctx]
    (binding [*print-dup* true]
      [:text (pr-str x)])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private pretty-docstring [docstring ctx]
  (if (string? docstring)
    [:group
     (concat [&quot;  \]
             (interpose :break (map #(let [[t s] (fp/-pretty % ctx)]
                                       [:text (subs s 1 (dec (count s)))])
                                    (s/split docstring #&quot;\n&quot;)))
             [&quot;\])]
    [(fp/pretty docstring ctx)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private pretty-defun [[head fn-name params &amp; more] ctx]
  (let [[docstring body] (fp/maybe-a string? more)]
    (fp/list-group
     (fp/-pretty head ctx) &quot; &quot; (fp/pretty fn-name ctx) &quot; &quot; (fp/-pretty params (dissoc ctx :symbols))
     (when docstring [:group :break (pretty-docstring docstring ctx)])
     (when (or docstring (seq body)) :break)
     (fp/block (map #(fp/pretty % ctx) body)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private pretty-defvar [[head symbol &amp; [initvalue docstring]] ctx]
  (fp/list-group
   (fp/-pretty head ctx) &quot; &quot; (fp/pretty symbol ctx) :line (fp/block [(fp/-pretty initvalue ctx)])
   (when docstring [:group :break (pretty-docstring docstring ctx)])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private pretty-let [[head varlist &amp; body :as form] ctx]
  (let [varlist (for [kv varlist]
                  (if-let [[k v] (and (seq? kv) kv)]
                    [:span &quot;(&quot; (fp/-pretty k (dissoc ctx :symbols)) &quot; &quot; [:align (fp/pretty v ctx)] &quot;)&quot;]
                    [:span (fp/-pretty kv (dissoc ctx :symbols))]))]
    (fp/list-group
     (fp/-pretty head ctx) &quot; &quot;
     [:group &quot;(&quot; [:align (interpose :break varlist)] &quot;)&quot;]
     (when (seq body) :break)
     (fp/block (map #(fp/pretty % ctx) body)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private pretty-cond [[head &amp; clauses] ctx]
  (let [clauses (for [c clauses]
                  [:group (concat [:span &quot;(&quot; (fp/-pretty (first c) ctx)]
                                  (when (&gt; (count c) 1)
                                    [:span :line [:nest 1 (interpose :line (map #(fp/pretty % ctx) (rest c)))]])
                                  [&quot;)&quot;])])]
    (fp/list-group
     (fp/-pretty head ctx) &quot; &quot;
     [:align (interpose :break clauses)])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private pretty-if [[head cond then &amp; else] ctx]
  (fp/list-group
   (fp/-pretty head ctx) &quot; &quot; (fp/pretty cond ctx) :line
   (fp/block [(fp/pretty then ctx)]) (when (seq else) :line)
   (fp/block (map #(fp/pretty % ctx) else))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private pretty-block [break [head stmnt &amp; block] ctx]
  (fp/list-group
   (fp/-pretty head ctx) &quot; &quot; (fp/pretty stmnt ctx) (when (seq block) break)
   (fp/block (map #(fp/pretty % ctx) block))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private pretty-lambda [[head args &amp; block] ctx]
  (fp/list-group
   (fp/-pretty head ctx) &quot; &quot; (fp/pretty args (dissoc ctx :symbols)) (when (seq block) :line)
   (fp/block (map #(fp/pretty % ctx) block))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private pretty-quote [[macro arg] ctx]
  [:span &quot;'&quot; (fp-edn/pretty arg (dissoc ctx :symbols))])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private el-symbols
  (fp/build-symbol-map
   {pretty-defun '[defmacro defun]
    pretty-defvar '[defvar defconst]
    pretty-let '[let let*]
    pretty-if '[deuce.emacs-lisp/if if]
    (partial pretty-block :line) '[setq set and or not]
    (partial pretty-block :break) '[while when unless dotimes dolist]
    pretty-lambda '[lambda closure]
    pretty-cond '[cond]
    pretty-quote '[quote]
    fp/pretty-ns '[ns]
    fp-edn/pretty '[#el/sym &quot;\\`&quot;]}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pprint-el
  ([form] (pprint-el form {}))
  ([form options]
   (fp/pprint form (merge {:symbols el-symbols :width 100} options))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn write-clojure [el-form clj-file]
  (io/make-parents clj-file)
  (binding [*out* (io/writer clj-file)]
    (doseq [form (concat '[(ns deuce.emacs (:refer-clojure :only []))]
                         (map el/el-&gt;clj el-form))]
      (case *pretty-style*
        :edn (fp-edn/pprint form)
        :el (pprint-el form)
        (pr form))
      (println))
    (flush)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs-lisp.cons" name="deuce.emacs-lisp.cons"><h1 class="project-name">deuce.emacs-lisp.cons</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs-lisp.cons
  (:require [clojure.core :as c])
  (:refer-clojure :exclude [list cons])
  (:import [clojure.lang Seqable Sequential
            IPersistentCollection ISeq Cons
            IPersistentList PersistentList LazySeq]
           [java.io Writer]
           [java.lang.reflect Field]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IList
  (car [this])
  (cdr [this]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ICons
  (setcar [this val])
  (setcdr [this val]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type nil
  IList
  (car [this] nil)
  (cdr [this] nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private array-class (Class/forName &quot;[Ljava.lang.Object;&quot;))</pre></td></tr><tr><td class="docs"><p>(satisfies? IList object) is slow - not sure if I trust this old comment..</p>
</td><td class="codes"><pre class="brush: clojure">(defn listp [object]
  (or (nil? object) (and (sequential? object)
                         (not= array-class (type object)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn consp [object]
  (instance? PersistentList object))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn dotted-list? [x]
  (and (seq? x) (= '. (last (butlast x)))
       (listp (last x))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn dotted-list-ending-in-pair? [x]
  (and (seq? x) (= '. (last (butlast x)))
       (not (listp (last x)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn dotted-pair? [x]
  (and (seq? x) (= 3 (count x)) (= '. (last (butlast x)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type IPersistentCollection
  IList
  (car [this] (first this))
  (cdr [this]
    (let [cdr (next this)]
      (if (= '. (first cdr))
        (second cdr)
        cdr))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn field-accessor [prefix field class]
  (eval `(def ^{:private true :tag `Field}
           ~(symbol (str prefix (name field))) (doto (.getDeclaredField ~class ~(name field))
                                              (.setAccessible true)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doseq [field '[_first _rest _count]]
  (field-accessor &quot;l&quot; field PersistentList))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare list)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type PersistentList
  ICons
  (setcar [^PersistentList this val]
    (do (.set ^Field l_first this val)
        val))
  (setcdr [^PersistentList this val]
    (if (or (instance? IPersistentList val) (nil? val) (= () val))
      (do
        (.set ^Field l_rest this val)
        (.set ^Field l_count this (int (inc (count val))))) ;; this gets out of sync when changing part of the tail.
      (if (dotted-pair? this)
        (setcar (rest (rest this)) val)
        (do
          (.set ^Field l_rest this (c/list '. val))
          (.set ^Field l_count this (int 3)))))
    val))</pre></td></tr><tr><td class="docs"><p>This should really be eval-expression-print-length, maybe move this to deuce.emacs.print
There's also eval-expression-print-level which controls nesting.
There's also print-level and print-lenght, seem to be nil in Emacs.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:private max-print-length 12)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ellipsis [coll]
  (let [s (seq coll)]
    (seq (concat (doall (take max-print-length s))
                 (when (&lt; max-print-length (count s))
                   ['...])))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn print-list [c ^Writer w]
  (.write w &quot;(&quot;)
  (loop [c c idx 1]
    (if (&gt; idx max-print-length)
      (.write w &quot;...)&quot;)
      (do
        (.write w (pr-str (car c)))
        (cond
         (not (listp (cdr c))) (.write w (str &quot; . &quot; (pr-str (cdr c)) &quot;)&quot;))
         (seq (cdr c)) (do
                         (.write w &quot; &quot;)
                         (recur (cdr c) (inc idx)))
         :else (.write w &quot;)&quot;))))))</pre></td></tr><tr><td class="docs"><p>(defmethod print-method PersistentList [c ^Writer w]
  (print-list c w))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defmethod print-method Cons [c ^Writer w]
  (print-list c w))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pair [car cdr]
  (if (listp cdr)
    (doto (c/list car)
      (setcdr cdr))
    (c/list car '. cdr)))</pre></td></tr><tr><td class="docs"><p>Fix uses of (apply cons/list ...) to something saner</p>
</td><td class="codes"><pre class="brush: clojure">(defn list [&amp; objects]
  (when (seq objects)
    (pair (car objects)
          (apply list (cdr objects)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn last-cons [l]
  (if (not (consp (cdr l))) l (recur (cdr l))))</pre></td></tr><tr><td class="docs"><p>Figure out where this is actually needed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn maybe-seq [x]
  (if (and (seq? x)
;           (not (dotted-pair? x))
           (not (consp x)))
    (if (dotted-list-ending-in-pair? x)
      (apply c/list x)
      (apply list x))
    x))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs-lisp.parser" name="deuce.emacs-lisp.parser"><h1 class="project-name">deuce.emacs-lisp.parser</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs-lisp.parser
  (:require [clojure.walk :as w]
            [clojure.string :as s]
            [clojure.pprint :as pp]
            [deuce.emacs-lisp :as el]
            [deuce.emacs-lisp.cons :refer [car cdr] :as cons]
            [deuce.emacs.alloc :as alloc]
            [deuce.emacs.casefiddle :as casefiddle]
            [deuce.emacs.textprop :as textprop])
  (:import [java.io InputStream]
           [java.lang.reflect Field]
           [java.util Scanner]
           [java.util.regex Pattern]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare tokenize)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def character-modifier-symbols '{&quot;\\A&quot; alt &quot;\\s&quot; super &quot;\\H&quot; hyper
                                  &quot;\\S&quot; shift &quot;\\C&quot; control &quot;\\M&quot; meta})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def character-modifier-bits '{alt 0x0400000
                               super 0x0800000
                               hyper 0x1000000
                               shift 0x2000000
                               control 0x4000000
                               meta 0x8000000})</pre></td></tr><tr><td class="docs"><p>In theory escape characters in strings should be escaped inside Emacs strings somewhat like this:</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private parse-control-char [maybe-control &amp; [for-string?]]
  (cond
   (&gt; maybe-control 127) (when for-string?
                           (char (- maybe-control 96)))
   (= (int \?) maybe-control) \ ;; DEL
   ;; This case results in a normal xor modifier in event-convert-list-internal by returning nul.
   (or (&gt; (int \?)  maybe-control (int \space))
       (&gt;=  maybe-control (int \{))
       (#{\tab \return \newline} (char maybe-control)))
   (when for-string? (el/throw* 'error &quot;Invalid modifier in string&quot;))
   :else (char (mod maybe-control 32))))</pre></td></tr><tr><td class="docs"><p>See http://www.gnu.org/software/emacs/manual/html_node/elisp/Nonprinting-Characters.html</p>
</td><td class="codes"><pre class="brush: clojure">(defn resolve-control-chars [s]
  (-&gt; s
      (s/replace #&quot;\\d&quot; &quot;&quot;) ;; DEL
      (s/replace #&quot;\\e&quot; &quot;&quot;) ;; ESC
      (s/replace #&quot;\\s&quot; &quot; &quot;)
      (s/replace #&quot;\\t&quot; &quot;\t&quot;)
      (s/replace #&quot;(?s)\\+(?:C-|\^)(\\?.)&quot; ;; Optional backslash handling somewhat confusing.
                 (fn [[control base]]
                   (if (re-find #&quot;^\\\\&quot; control) ;; Can be a quoted control char
                     control
                     (str (parse-control-char (int (last base)) :for-string)))))
      (s/replace #&quot;\\M-(\\?.)&quot;   ;; &quot;\M-i&quot; converts into &quot;�&quot;. This only works for 7-bit ASCII.
                 (fn [[meta base]]
                   (let [c (int (last base))]
                     (if (&lt; c 128)
                       (str (char (bit-xor 128 c)))
                       (el/throw* 'error &quot;Invalid modifier in string&quot;)))))))</pre></td></tr><tr><td class="docs"><p>This takes an actual quoted String. Can easiest be called from the REPL by chaining (pr-str "...")</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private parse-string [s]
  (reduce (fn [s [m r]] (s/replace s m r))
          (subs s 1 (dec (count s)))
          [[&quot;\\\n&quot; ]
           [&quot;\\\ &quot;\]
           [&quot;\\\\&quot; &quot;\\&quot;]
           [#&quot;\\(\d+)&quot; (fn [[_ n]]
                         (str (char (Integer/parseInt n 8))))]
           [#&quot;\\x(\p{XDigit}+)&quot; (fn [[_ n]]
                                  (str (char (Integer/parseInt n 16))))]
           [&quot;\\n&quot; &quot;\n&quot;]
           [&quot;\\r&quot; &quot;\r&quot;]
           [&quot;\\b&quot; &quot;\b&quot;]
           [&quot;\\t&quot; &quot;\t&quot;]]))</pre></td></tr><tr><td class="docs"><p>Like Emacs, certain characters can be read both with single and double backslash. Not necessarily the same ones.</p>
</td><td class="codes"><pre class="brush: clojure">(def emacs-problem-chars {&quot;\\&quot; \\ &quot;\\s&quot; \space
                          &quot;\\-&quot; \- &quot;-&quot; \- &quot;\ \&quot;})</pre></td></tr><tr><td class="docs"><p>Various ctrl-characters are broken, many ways they can be specified, this simplified take doesn't fit the Emacs model.
Should be rewritten with some thought behind it. Maybe a test.
http://www.gnu.org/software/emacs/manual/html_node/elisp/Character-Type.html doesn't really cover it in all it's glory.
Looks like edmacro/edmacro-parse-keys actually contains a lot of the logic.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Here's an attempt at doing something more correct, see deuce.emacs.keyboard/event-convert-list:</p>
</td><td class="codes"><pre class="brush: clojure">(defn event-convert-list-internal [mods base &amp; [no-modifier-conversion]]    ;; no-modifiers-conversion is used when parsing chars.
  (let [[mods base] [(set mods) (int base)]
        [mods base] (if-let [control-char (and (mods 'control)              ;; This turns '(control \space) into 0: &quot;\^@&quot;
                                               (and (not (&lt;= (int base) (int \space)))
                                                    no-modifier-conversion) ;; Don't reparse actual lower control characters.
                                               (parse-control-char base))]
                      [(disj (if (and (not no-modifier-conversion)          ;; It is a valid 5 bit or 127 control char
                                      (Character/isUpperCase (char base)))  ;; Remove control modifier as its baked in.
                               (conj mods 'shift)                           ;; If original was upper case, add shift modifier
                               mods) 'control) (int control-char)]
                      [mods base])
        [mods base] (if (and (mods 'shift) (not no-modifier-conversion)     ;; Turns '(shift \a) into \A
                             (Character/isLowerCase (char base))            ;; If and only if a 7 bit ASCII char, upper case it
                             (&lt; base 128))
                      [(disj mods 'shift) (casefiddle/upcase base)]         ;; Remove shift modifier as its baked in.
                      [mods base])]                                         ;; (But upper case characters can have 'shift as well.)
    (reduce bit-xor base (replace character-modifier-bits mods))))          ;; XOR in the modifiers.</pre></td></tr><tr><td class="docs"><p>XOR in the modifiers.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Takes an Emacs-style charcter specifier without the leading ?
Turns "C-a" into \
Returns characters for things that fit below Character/MAX_VALUE, otherwise ints.
We may want our own real type for this. It parses the base character as a string first.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private parse-character [c]
  (if-let [c (emacs-problem-chars c)]
    c
    (let [parts  (if (re-find #&quot;.+--$&quot; c)
                   (vec (concat (s/split c #&quot;-&quot;) [&quot;-&quot;]))
                   (s/split c #&quot;-&quot;))
          [mods c] [(set (butlast parts)) (last parts)]
          c (cond
             (character-modifier-symbols c) -1
             (re-find #&quot;\\\d+&quot; c) (Integer/parseInt (subs c 1) 8)
             (re-find #&quot;\\x\p{XDigit}+&quot; c) (Integer/parseInt (subs c 2) 16)
             :else (int (first (resolve-control-chars (parse-string (str \&quot; c \&quot;))))))]
      (if (= -1 c) c
          (let [c (event-convert-list-internal
                   (replace character-modifier-symbols mods) c :no-modifier-conversion)]
            (if (&lt;= c (int (Character/MAX_VALUE)))
              (char c)
              (long c)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private strip-comments [form]
  (remove (every-pred seq? (comp `#{comment} first)) form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private as-vector [form]
  (object-array (vec form)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ^Pattern re-str #&quot;(?s)([^\&quot;\\]*(?:\\.[^\&quot;\\]*)*)\)
(def ^:private ^Pattern re-char #&quot;(?s)((\\[CSMAHs]-)*(\\x?\p{XDigit}+|(\\\^?)?.))&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parse-characters [s meta-prefix-char]
  (seq (map (comp parse-character first)
            (re-seq re-char (resolve-control-chars (s/replace s &quot;\\M-&quot; (str (char meta-prefix-char))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private unmodifiers (zipmap (vals character-modifier-bits) (keys character-modifier-bits)))</pre></td></tr><tr><td class="docs"><p>Turns #el/vec [67108911] into '(control \/), not sure how to read them from keyboard using lanterna.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unmodify-key [k]
  (let [keys (reduce
              (fn [[key &amp; modifiers :as k] modifier]
                (if (&gt; (bit-and key modifier) 0)
                  (cons (bit-and-not key modifier)
                        (cons (unmodifiers modifier) modifiers))
                  k)) k (keys unmodifiers))]
    (reverse (cons (char (first keys)) (rest keys)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private tokenize-all [^Scanner sc]
  (strip-comments (take-while (complement #{`end}) (repeatedly (partial tokenize sc)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private tokenize [^Scanner sc]
  (let [find (fn [^Pattern re h] (.findWithinHorizon sc re (int h)))]
    (condp find 1
      #&quot;\s&quot; (recur sc)
      #&quot;[)\]]&quot; `end
      #&quot;\(&quot; (tokenize-all sc)
      #&quot;\[&quot; (as-vector (tokenize-all sc))
      #&quot;,&quot; (list (if (find #&quot;@&quot; 1) '#el/sym &quot;\\,@&quot; '#el/sym &quot;\\,&quot;) (tokenize sc))
      #&quot;'&quot; (list 'quote (tokenize sc))
      #&quot;`&quot; (let [form  (tokenize sc)]
             (if (symbol? form)
               (list 'quote form)
               (list '#el/sym &quot;\\`&quot; form)))
      #&quot;:&quot; (keyword (.next sc))
      #&quot;\?&quot; (parse-character (find re-char 0))
      #&quot;\ (parse-string (str \&quot; (find re-str 0)))
      ;; Deal with: ;;; -*- lexical-binding: t -*- or autoload      ;;;###autoload      ;;; Code
      #&quot;;&quot; (list `comment (.nextLine sc))
      #&quot;#&quot; (condp find 1
             ;; #&quot;^&quot; is a CharTable looking like this: #^[nil nil keymap ...]
             #&quot;'&quot; (list 'function (tokenize sc))
             #&quot;\(&quot; (let [[object start end properties] (tokenize-all sc)]
                     (list `textprop/set-text-properties start end properties object))
             #&quot;x&quot; (.nextInt sc (int 16))
             #&quot;o&quot; (.nextInt sc (int 8))
             #&quot;b&quot; (.nextInt sc (int 2))
             (when (.hasNext sc #&quot;\d+r\S+&quot;)
               (let [radix (find #&quot;\d+&quot; 0)]
                 (find #&quot;r&quot; 1)
                 (.nextInt sc (Integer/parseInt radix)))))
      (cond
       (.hasNextLong sc) (.nextLong sc)
       (.hasNextDouble sc) (.nextDouble sc)
       (.hasNext sc) (let [s (find #&quot;[^\s\[\]\(\)\&quot;\;]+&quot; 0)]
                       (case s
                         &quot;t&quot; true
                         &quot;nil&quot; nil
                         (symbol nil s)))
       :else `end))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def scanner-position (doto (.getDeclaredField Scanner &quot;position&quot;)
                        (.setAccessible true)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parse-internal [r &amp; [all?]]
  (let [scanner (doto (if (string? r) (Scanner. ^String r) (Scanner. ^InputStream r &quot;UTF-8&quot;))
                  (.useDelimiter #&quot;(\s|\]|\)|\&quot;|;)&quot;))]
    (cons/pair
     ((if all? tokenize-all tokenize) scanner)
     (.get ^Field scanner-position scanner))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parse [r]
  (cons/car (parse-internal r :all)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#deuce.emacs" name="deuce.emacs"><h1 class="project-name">deuce.emacs</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns deuce.emacs
  (:require [clojure.core :as c]
            [deuce.emacs-lisp :as el]
            [deuce.emacs-lisp.globals :as globals])
  (:refer-clojure :only [])
  (:use [deuce.emacs-lisp :only [and apply-partially catch cond condition-case defconst define-compiler-macro defmacro
                                 defun defvar function if interactive lambda let let* or prog1 prog2 progn quote
                                 save-current-buffer save-excursion save-restriction setq setq-default
                                 unwind-protect while throw]]
        [deuce.emacs.alloc]
        [deuce.emacs.buffer]
        [deuce.emacs.bytecode]
        [deuce.emacs.callint]
        [deuce.emacs.callproc]
        [deuce.emacs.casefiddle]
        [deuce.emacs.casetab]
        [deuce.emacs.category]
        [deuce.emacs.ccl]
        [deuce.emacs.character]
        [deuce.emacs.charset]
        [deuce.emacs.chartab]
        [deuce.emacs.cmds]
        [deuce.emacs.coding]
        [deuce.emacs.composite]
        [deuce.emacs.data]
        [deuce.emacs.dired]
        [deuce.emacs.dispnew]
        [deuce.emacs.doc]
        [deuce.emacs.editfns]
        [deuce.emacs.emacs]
        [deuce.emacs.eval]
        [deuce.emacs.fileio]
        [deuce.emacs.filelock]
        [deuce.emacs.floatfns]
        [deuce.emacs.fns]
        [deuce.emacs.font]
        [deuce.emacs.frame]
        [deuce.emacs.indent]
        [deuce.emacs.insdel]
        [deuce.emacs.keyboard]
        [deuce.emacs.keymap]
        [deuce.emacs.lread]
        [deuce.emacs.macros]
        [deuce.emacs.marker]
        [deuce.emacs.menu]
        [deuce.emacs.minibuf]
        [deuce.emacs.print]
        [deuce.emacs.process]
        [deuce.emacs.search]
        [deuce.emacs.syntax]
        [deuce.emacs.term]
        [deuce.emacs.terminal]
        [deuce.emacs.textprop]
        [deuce.emacs.undo]
        [deuce.emacs.window]
        [deuce.emacs.xdisp]
        [deuce.emacs.xfaces]
        [deuce.emacs.xml]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(setq t true)</pre></td></tr><tr><td class="docs"><p>Stubs for running without MULE:
These keymaps are referenced from menu-bar.</p>
</td><td class="codes"><pre class="brush: clojure">(setq mule-menu-keymap (make-sparse-keymap))
(setq describe-language-environment-map (make-sparse-keymap))
(setq buffer-file-coding-system-explicit nil)</pre></td></tr><tr><td class="docs"><p>Used by startup/normal-top-level to set the locale, called with nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defun set-locale-environment (&amp;optional locale-name frame))
(setq current-language-environment &quot;English&quot;)</pre></td></tr><tr><td class="docs"><p>(({"English" {(quote tutorial) "TUTORIAL"}} lang-env {}) key)</p>

<p>Used by startup/fancy-about-text to find localized tutorial.</p>
</td><td class="codes"><pre class="brush: clojure">(defun get-language-info (lang-env key)
  (({&quot;English&quot; {'tutorial &quot;TUTORIAL&quot;}} lang-env {}) key))</pre></td></tr><tr><td class="docs"><p>Used by env.</p>
</td><td class="codes"><pre class="brush: clojure">(defun find-coding-systems-string (string))</pre></td></tr><tr><td class="docs"><p>These are used by the mode line</p>

<p>(symbol-value ({0 (quote eol-mnemonic-unix), 1 (quote eol-mnemonic-dos), 2 (quote eol-mnemonic-mac)} (coding-system-eol-type coding-system) (quote eol-mnemonic-undecided)))</p>
</td><td class="codes"><pre class="brush: clojure">(setq current-input-method)
(defun coding-system-eol-type-mnemonic (coding-system)
  (symbol-value ({0 'eol-mnemonic-unix 1 'eol-mnemonic-dos 2 'eol-mnemonic-mac}
                 (coding-system-eol-type coding-system) 'eol-mnemonic-undecided)))</pre></td></tr><tr><td class="docs"><p>I'm the one and only Frame</p>
</td><td class="codes"><pre class="brush: clojure">(setq terminal-frame ((c/ns-resolve 'deuce.emacs.frame 'make-initial-frame)))
(setq last-event-frame terminal-frame)</pre></td></tr><tr><td class="docs"><p>(c/require (quote deuce.main))</p>

<p>Callback run by faces/tty-run-terminal-initialization based on deuce.emacs.term/tty-type returning "lanterna"</p>
</td><td class="codes"><pre class="brush: clojure">(defun terminal-init-lanterna ()
  (c/require 'deuce.main)
  ((c/ns-resolve 'deuce.main 'terminal-init-lanterna)))</pre></td></tr><tr><td class="docs"><p>Create <em>Deuce</em> log buffer first so it won't get selected.</p>
</td><td class="codes"><pre class="brush: clojure">(get-buffer-create &quot;*Deuce*&quot;)</pre></td></tr><tr><td class="docs"><p><em>Messages</em> is created by xdisp.c</p>
</td><td class="codes"><pre class="brush: clojure">(get-buffer-create &quot;*Messages*&quot;)</pre></td></tr><tr><td class="docs"><p><em>scratch</em> is created by buffer.c</p>
</td><td class="codes"><pre class="brush: clojure">(set-window-buffer (selected-window)
                   (get-buffer-create &quot;*scratch*&quot;))</pre></td></tr><tr><td class="docs"><p>Minibuffer 0 is the empty one, this is either created by frame.c or minibuffer.c
Not the leading space for buffers in the minibuffer window. <em>Minibuf-1</em> etc. gets created once it gets activated.
You can switch to these buffers in a normal window in Emacs and see them change as they're used.</p>
</td><td class="codes"><pre class="brush: clojure">(set-window-buffer (minibuffer-window)
                   (get-buffer-create &quot; *Minibuf-0*&quot;))</pre></td></tr><tr><td class="docs"><p>ensure<em>echo</em>area_buffers in xdisp.c creates (at least) two echo areas.</p>
</td><td class="codes"><pre class="brush: clojure">(get-buffer-create &quot; *Echo Area 0*&quot;)
(get-buffer-create &quot; *Echo Area 1*&quot;)</pre></td></tr><tr><td class="docs"><p>Hack for a predicate in cl.el, this is defined in emacs-lisp/bytecomp.el, which we're not using</p>
</td><td class="codes"><pre class="brush: clojure">(defun byte-compile-file-form (form))</pre></td></tr><tr><td class="docs"><p> AOT cl.el gets confused by this alias</p>
</td><td class="codes"><pre class="brush: clojure">(defalias 'cl-block-wrapper 'identity)
(defmacro declare (&amp;rest _specs) nil)</pre></td></tr><tr><td class="docs"><p>with-no-warnings in byte-run.el needs this</p>
</td><td class="codes"><pre class="brush: clojure">(defun last (list &amp;optional n))</pre></td></tr><tr><td class="docs"><p>subr defines a simpler dolist, which custom uses, which gets redefined by cl-macs.
During AOT custom loads the latter dolist definition, requiring 'block' - not yet defined.
cl cannot be loaded first, as it depends on help-fns, which depend on custom.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro block (name &amp;rest body) (cons 'progn body))</pre></td></tr><tr><td class="docs"><p>Hack as delayed-eval doesn't (like some other things) work properly inside let-bindings.
Needs to be fixed properly, but let's see if we can get through the boot with this hack.
cl-setf-simple-store-p is used in  cl-macs/cl-setf-do-modify, delayed-eval call refers to earlier binding 'method'.</p>
</td><td class="codes"><pre class="brush: clojure">(defun cl-setf-simple-store-p (sym form))</pre></td></tr><tr><td class="docs"><p>Same issue in regexp-opt/regexp-opt. Calls this fn with earlier binding 'sorted-strings'</p>
</td><td class="codes"><pre class="brush: clojure">(defun regexp-opt-group (strings &amp;optional paren lax))</pre></td></tr><tr><td class="docs"><p>Keymap setup, should in theory be in deuce.emacs.keymap, but cannot for a reason I forgot.</p>
</td><td class="codes"><pre class="brush: clojure">(setq global-map (make-keymap))
(use-global-map (symbol-value 'global-map))</pre></td></tr><tr><td class="docs"><p>These use internal-define-key in Emacs, which doesn't define the prefix as symbol, unlike define-prefix-command.</p>
</td><td class="codes"><pre class="brush: clojure">(setq esc-map (make-keymap))
(fset 'ESC-prefix (symbol-value 'esc-map))
(setq ctl-x-map (make-keymap))
(fset 'Control-X-prefix (symbol-value 'ctl-x-map))</pre></td></tr><tr><td class="docs"><p>\e</p>

<p>Main prefix keymaps setup from keymap.c</p>

<p>\C-x</p>
</td><td class="codes"><pre class="brush: clojure">(define-key globals/global-map &quot;\\e&quot; 'ESC-prefix)
(define-key globals/global-map &quot;\\C-x&quot; 'Control-X-prefix)</pre></td></tr><tr><td class="docs"><p>\C-i</p>

<p>self-insert-command for standard keys setup in cmds.c</p>
</td><td class="codes"><pre class="brush: clojure">(define-key globals/global-map &quot;\\C-i&quot; 'self-insert-command)
(c/doseq [n (c/range 32 (c/inc 127))]
         (define-key globals/global-map (make-string 1 n) 'self-insert-command))
(c/doseq [n (c/range 160 (c/inc 256))]
         (define-key globals/global-map (make-string 1 n) 'self-insert-command))</pre></td></tr><tr><td class="docs"><p>b</p>

<p>buffer commands from buffer.c</p>

<p>k</p>
</td><td class="codes"><pre class="brush: clojure">(define-key globals/ctl-x-map  'switch-to-buffer)
(define-key globals/ctl-x-map  'kill-buffer)</pre></td></tr><tr><td class="docs"><p>\C-u</p>

<p>case commands from casefiddle.c</p>

<p>\C-l</p>
</td><td class="codes"><pre class="brush: clojure">(define-key globals/ctl-x-map &quot;\\C-u&quot; 'upcase-region)
(put 'upcase-region 'disabled true)
(define-key globals/ctl-x-map &quot;\\C-l&quot; 'downcase-region)
(put 'downcase-region 'disabled true)</pre></td></tr><tr><td class="docs"><p>u</p>

<p>l</p>

<p>c</p>
</td><td class="codes"><pre class="brush: clojure">(define-key globals/esc-map  'upcase-word)
(define-key globals/esc-map  'downcase-word)
(define-key globals/esc-map  'capitalize-word)</pre></td></tr><tr><td class="docs"><p>\C-a</p>

<p>basic movement commands setup in cmds.c</p>

<p>\C-b</p>

<p>\C-e</p>

<p>\C-f</p>
</td><td class="codes"><pre class="brush: clojure">(define-key globals/global-map &quot;\\C-a&quot; 'beginning-of-line)
(define-key globals/global-map &quot;\\C-b&quot; 'backward-char)
(define-key globals/global-map &quot;\\C-e&quot; 'end-of-line)
(define-key globals/global-map &quot;\\C-f&quot; 'forward-char)</pre></td></tr><tr><td class="docs"><p>\C-z</p>

<p>basic commands setup in keyboard.c</p>

<p>\C-z</p>

<p>\C-c</p>

<p>\C-]</p>

<p>x</p>
</td><td class="codes"><pre class="brush: clojure">(define-key globals/global-map &quot;\\C-z&quot; 'suspend-emacs)
(define-key globals/ctl-x-map &quot;\\C-z&quot; 'suspend-emacs)
(define-key globals/esc-map &quot;\\C-c&quot; 'exit-recursive-edit)
(define-key globals/global-map &quot;\\C-]&quot; 'abort-recursive-edit)
(define-key globals/esc-map  'execute-extended-command)</pre></td></tr><tr><td class="docs"><p>There's also a bunch of initial<em>define</em>lispy_key I skip here</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>&lt;</p>

<p>scolling commands in window.c</p>

<p>></p>
</td><td class="codes"><pre class="brush: clojure">(define-key globals/ctl-x-map,  'scroll-left)
(define-key globals/ctl-x-map  'scroll-right)</pre></td></tr><tr><td class="docs"><p>\C-v</p>

<p>\C-v</p>

<p>v</p>
</td><td class="codes"><pre class="brush: clojure">(define-key globals/global-map &quot;\\C-v&quot; 'scroll-up-command)
(define-key globals/esc-map &quot;\\C-v&quot; 'scroll-other-window)
(define-key globals/esc-map  'scroll-down-command)</pre></td></tr><tr><td class="docs"><p>var is definied in keyboard.clj</p>
</td><td class="codes"><pre class="brush: clojure">(setq function-key-map (make-sparse-keymap))</pre></td></tr><tr><td class="docs"><p>This map has a few low-level (like delete-frame) key defs in keybaoard.c</p>
</td><td class="codes"><pre class="brush: clojure">(setq special-event-map (make-sparse-keymap))
(setq local-function-key-map (make-sparse-keymap))
(set-keymap-parent globals/local-function-key-map globals/function-key-map)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(setq input-decode-map (make-sparse-keymap))
(setq key-translation-map (make-sparse-keymap))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(setq minibuffer-local-map (make-sparse-keymap))
(setq minibuffer-local-ns-map (make-sparse-keymap))
(set-keymap-parent globals/minibuffer-local-ns-map globals/minibuffer-local-map)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/gdeer81/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a><div id="floating-toc"><ul><li class="floating-toc-li" id="floating-toc_data_readers.clj">data_readers.clj</li><li class="floating-toc-li" id="floating-toc_deuce.main">deuce.main</li><li class="floating-toc-li" id="floating-toc_deuce.emacs-lisp">deuce.emacs-lisp</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.keyboard">deuce.emacs.keyboard</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.casefiddle">deuce.emacs.casefiddle</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.composite">deuce.emacs.composite</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.lread">deuce.emacs.lread</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.indent">deuce.emacs.indent</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.floatfns">deuce.emacs.floatfns</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.insdel">deuce.emacs.insdel</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.font">deuce.emacs.font</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.textprop">deuce.emacs.textprop</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.doc">deuce.emacs.doc</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.editfns">deuce.emacs.editfns</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.minibuf">deuce.emacs.minibuf</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.menu">deuce.emacs.menu</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.fileio">deuce.emacs.fileio</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.window">deuce.emacs.window</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.fns">deuce.emacs.fns</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.data">deuce.emacs.data</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.callproc">deuce.emacs.callproc</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.bytecode">deuce.emacs.bytecode</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.ccl">deuce.emacs.ccl</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.buffer">deuce.emacs.buffer</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.chartab">deuce.emacs.chartab</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.filelock">deuce.emacs.filelock</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.casetab">deuce.emacs.casetab</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.coding">deuce.emacs.coding</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.marker">deuce.emacs.marker</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.category">deuce.emacs.category</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.print">deuce.emacs.print</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.xfaces">deuce.emacs.xfaces</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.macros">deuce.emacs.macros</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.dired">deuce.emacs.dired</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.undo">deuce.emacs.undo</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.charset">deuce.emacs.charset</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.process">deuce.emacs.process</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.character">deuce.emacs.character</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.xdisp">deuce.emacs.xdisp</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.eval">deuce.emacs.eval</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.cmds">deuce.emacs.cmds</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.dispnew">deuce.emacs.dispnew</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.keymap">deuce.emacs.keymap</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.xml">deuce.emacs.xml</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.terminal">deuce.emacs.terminal</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.syntax">deuce.emacs.syntax</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.search">deuce.emacs.search</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.callint">deuce.emacs.callint</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.alloc">deuce.emacs.alloc</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.term">deuce.emacs.term</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.emacs">deuce.emacs.emacs</li><li class="floating-toc-li" id="floating-toc_deuce.emacs.frame">deuce.emacs.frame</li><li class="floating-toc-li" id="floating-toc_deuce.emacs-lisp.globals">deuce.emacs-lisp.globals</li><li class="floating-toc-li" id="floating-toc_deuce.emacs-lisp.printer">deuce.emacs-lisp.printer</li><li class="floating-toc-li" id="floating-toc_deuce.emacs-lisp.cons">deuce.emacs-lisp.cons</li><li class="floating-toc-li" id="floating-toc_deuce.emacs-lisp.parser">deuce.emacs-lisp.parser</li><li class="floating-toc-li" id="floating-toc_deuce.emacs">deuce.emacs</li></ul></div></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
SyntaxHighlighter.all();

// hackity hack
$(window).load(function() {
    var ft = $("#floating-toc");
    var ul = ft.find('ul');
    var lis = ft.find('li');
    var liHeight = $(lis.first()).height();

    ul.css('margin', '0px');
    ft.css('height', liHeight + 'px');

    showNs = function(ns) {
        var index = 0;

        for(i in nsPositions.nss) {
            if(ns == nsPositions.nss[i]) index = i;
        }

        if(index != lastNsIndex) {
            lastNsIndex = index;
            ul.animate({marginTop: (-1 * liHeight * index) + 'px'},
               300);
        }

    }

    var calcNsPositions = function() {
        var hheight = $('.docs-header').first().height();
        var nss = [];
        var anchors = [];
        var positions = [];
        $.each(lis, function(i, el) {
            var ns = $(el).attr('id').split('_')[1];
            nss.push(ns);
            var a = $("a[name='"+ns+"']");
            anchors.push(a);
            positions.push(a.offset().top - hheight);
            // console.log(a.offset().top)
        });

        return {nss: nss, positions: positions};
    }

    var nsPositions = calcNsPositions();
    // console.log(nsPositions)
    var lastNsIndex = -1;
    var $window = $(window);

    var currentSection = function(nsp) {
        var ps = nsp.positions;
        var scroll = $window.scrollTop();
        var nsIndex = -1;

        for(var i = 0, length = ps.length; i < length; i++) {
            if(ps[i] >= scroll) {
                nsIndex = i-1;
                break;
            }
        }

        if(nsIndex == -1) {
             if(scroll >= ps[0]) {
                 nsIndex = ps.length - 1;
             } else {
                 nsIndex = 0;
             }
        }

        return nsp.nss[nsIndex];
    }

    $(window).scroll(function(e) {
        showNs(currentSection(nsPositions));
    });
});
</script></body></html>