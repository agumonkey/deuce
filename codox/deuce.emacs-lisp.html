<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>deuce.emacs-lisp documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Deuce 0.1.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deuce</span></div></div></li><li class="depth-2 current"><a href="deuce.emacs-lisp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>emacs-lisp</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs-lisp.cons.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cons</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs-lisp.globals.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>globals</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs-lisp.parser.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parser</span></div></a></li><li class="depth-3"><a href="deuce.emacs-lisp.printer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>printer</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>emacs</span></div></div></li><li class="depth-3 branch"><a href="deuce.emacs.alloc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>alloc</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.buffer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buffer</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.bytecode.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bytecode</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.callint.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>callint</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.callproc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>callproc</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.casefiddle.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>casefiddle</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.casetab.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>casetab</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.category.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>category</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.ccl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ccl</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.character.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>character</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.charset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>charset</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.chartab.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>chartab</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.cmds.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cmds</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.coding.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>coding</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.composite.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>composite</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.dired.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dired</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.dispnew.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dispnew</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.doc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>doc</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.editfns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>editfns</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.emacs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>emacs</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.eval.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>eval</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.fileio.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fileio</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.filelock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>filelock</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.floatfns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>floatfns</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.fns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fns</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.font.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>font</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.frame.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>frame</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.indent.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>indent</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.insdel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>insdel</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.keyboard.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>keyboard</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.keymap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>keymap</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.lread.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lread</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.macros.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macros</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.marker.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>marker</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.menu.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>menu</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.minibuf.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>minibuf</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.print.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>print</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.process.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>process</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.search.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>search</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.syntax.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>syntax</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.term.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>term</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.terminal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>terminal</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.textprop.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>textprop</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.undo.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>undo</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.window.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>window</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.xdisp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xdisp</span></div></a></li><li class="depth-3 branch"><a href="deuce.emacs.xfaces.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xfaces</span></div></a></li><li class="depth-3"><a href="deuce.emacs.xml.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xml</span></div></a></li><li class="depth-2"><a href="deuce.main.html"><div class="inner"><span class="tree" style="top: -1540px;"><span class="top" style="height: 1549px;"></span><span class="bottom"></span></span><span>main</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="deuce.emacs-lisp.html#var-*disallow-undefined*"><div class="inner"><span>*disallow-undefined*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-*dynamic-vars*"><div class="inner"><span>*dynamic-vars*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-and"><div class="inner"><span>and</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-apply-partially"><div class="inner"><span>apply-partially</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-buffer-locals"><div class="inner"><span>buffer-locals</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-catch"><div class="inner"><span>catch</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-cause"><div class="inner"><span>cause</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-check-type"><div class="inner"><span>check-type</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-clojure-special-forms"><div class="inner"><span>clojure-special-forms</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-clojure-syntax-quote"><div class="inner"><span>clojure-syntax-quote</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-compile"><div class="inner"><span>compile</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-cond"><div class="inner"><span>cond</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-condition-case"><div class="inner"><span>condition-case</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-def-helper*"><div class="inner"><span>def-helper*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-def-helper-process-var*"><div class="inner"><span>def-helper-process-var*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-defconst"><div class="inner"><span>defconst</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-define-compiler-macro"><div class="inner"><span>define-compiler-macro</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-defmacro"><div class="inner"><span>defmacro</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-defun"><div class="inner"><span>defun</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-defvar"><div class="inner"><span>defvar</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-defvar-helper*"><div class="inner"><span>defvar-helper*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-delayed-eval"><div class="inner"><span>delayed-eval</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-delayed-eval*"><div class="inner"><span>delayed-eval*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-dynamic-binding.3F"><div class="inner"><span>dynamic-binding?</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-el-.3Eclj"><div class="inner"><span>el-&gt;clj</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-el-var"><div class="inner"><span>el-var</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-el-var-buffer-local"><div class="inner"><span>el-var-buffer-local</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-el-var-get"><div class="inner"><span>el-var-get</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-el-var-get*"><div class="inner"><span>el-var-get*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-el-var-set"><div class="inner"><span>el-var-set</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-el-var-set*"><div class="inner"><span>el-var-set*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-el-var-set-default"><div class="inner"><span>el-var-set-default</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-el-var-set-default*"><div class="inner"><span>el-var-set-default*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-emacs-lisp-backquote"><div class="inner"><span>emacs-lisp-backquote</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-emacs-lisp-error"><div class="inner"><span>emacs-lisp-error</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-eval"><div class="inner"><span>eval</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-expand-dotted-lists"><div class="inner"><span>expand-dotted-lists</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-fun"><div class="inner"><span>fun</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-function"><div class="inner"><span>function</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-global"><div class="inner"><span>global</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-if"><div class="inner"><span>if</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-interactive"><div class="inner"><span>interactive</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-lambda"><div class="inner"><span>lambda</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-let"><div class="inner"><span>let</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-let*"><div class="inner"><span>let*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-let-helper*"><div class="inner"><span>let-helper*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-maybe-splice-dotted-list"><div class="inner"><span>maybe-splice-dotted-list</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-maybe-sym"><div class="inner"><span>maybe-sym</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-meta-walk"><div class="inner"><span>meta-walk</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-normalize-form-for-macro"><div class="inner"><span>normalize-form-for-macro</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-not-null.3F"><div class="inner"><span>not-null?</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-or"><div class="inner"><span>or</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-override.3F"><div class="inner"><span>override?</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-parse-doc-string"><div class="inner"><span>parse-doc-string</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-prog1"><div class="inner"><span>prog1</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-prog2"><div class="inner"><span>prog2</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-progn"><div class="inner"><span>progn</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-quote"><div class="inner"><span>quote</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-save-current-buffer"><div class="inner"><span>save-current-buffer</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-save-excursion"><div class="inner"><span>save-excursion</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-save-restriction"><div class="inner"><span>save-restriction</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-scope"><div class="inner"><span>scope</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-setq"><div class="inner"><span>setq</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-setq-default"><div class="inner"><span>setq-default</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-setq-helper*"><div class="inner"><span>setq-helper*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-sym"><div class="inner"><span>sym</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-symbol-plists"><div class="inner"><span>symbol-plists</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-symbol-reader"><div class="inner"><span>symbol-reader</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-syntax-quote*"><div class="inner"><span>syntax-quote*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-throw"><div class="inner"><span>throw</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-throw*"><div class="inner"><span>throw*</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-try-with-tag"><div class="inner"><span>try-with-tag</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-unwind-protect"><div class="inner"><span>unwind-protect</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-vector-reader"><div class="inner"><span>vector-reader</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-while"><div class="inner"><span>while</span></div></a></li><li class="depth-1"><a href="deuce.emacs-lisp.html#var-with-local-el-vars"><div class="inner"><span>with-local-el-vars</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">deuce.emacs-lisp</h2><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-*disallow-undefined*"><h3>*disallow-undefined*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-*dynamic-vars*"><h3>*dynamic-vars*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-and"><h3>and</h3><h4 class="type">macro</h4><div class="usage"><code>(and CONDITIONS...)</code></div><div class="doc"><pre class="plaintext">Eval args until one of them yields nil, then return nil.
The remaining args are not evalled at all.
If no arg yields nil, return the last arg&apos;s value.</pre></div></div><div class="public anchor" id="var-apply-partially"><h3>apply-partially</h3><div class="usage"><code>(apply-partially fun &amp; args)</code></div><div class="doc"><pre class="plaintext">Return a function that is a partial application of FUN to ARGS.
ARGS is a list of the first N arguments to pass to FUN.
The result is a new function which does the same as FUN, except that
the first N arguments are fixed at the values with which this function
was called.</pre></div></div><div class="public anchor" id="var-buffer-locals"><h3>buffer-locals</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-catch"><h3>catch</h3><h4 class="type">macro</h4><div class="usage"><code>(catch TAG BODY...)</code></div><div class="doc"><pre class="plaintext">Eval BODY allowing nonlocal exits using `throw&apos;.
TAG is evalled to get the tag to use; it must not be nil.

Then the BODY is executed.
Within BODY, a call to `throw&apos; with the same TAG exits BODY and this `catch&apos;.
If no throw happens, `catch&apos; returns the value of the last BODY form.
If a throw happens, it specifies the value to return from `catch&apos;.</pre></div></div><div class="public anchor" id="var-cause"><h3>cause</h3><div class="usage"><code>(cause e)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-check-type"><h3>check-type</h3><div class="usage"><code>(check-type pred x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-clojure-special-forms"><h3>clojure-special-forms</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-clojure-syntax-quote"><h3>clojure-syntax-quote</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-compile"><h3>compile</h3><div class="usage"><code>(compile emacs-lisp)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-cond"><h3>cond</h3><h4 class="type">macro</h4><div class="usage"><code>(cond CLAUSES...)</code></div><div class="doc"><pre class="plaintext">Try each clause until one succeeds.
Each clause looks like (CONDITION BODY...).  CONDITION is evaluated
and, if the value is non-nil, this clause succeeds:
then the expressions in BODY are evaluated and the last one&apos;s
value is the value of the cond-form.
If no clause succeeds, cond returns nil.
If a clause has one element, as in (CONDITION),
CONDITION&apos;s value if non-nil is returned from the cond-form.</pre></div></div><div class="public anchor" id="var-condition-case"><h3>condition-case</h3><h4 class="type">macro</h4><div class="usage"><code>(condition-case VAR BODYFORM &amp;rest HANDLERS)</code></div><div class="doc"><pre class="plaintext">Regain control when an error is signaled.
Executes BODYFORM and returns its value if no error happens.
Each element of HANDLERS looks like (CONDITION-NAME BODY...)
where the BODY is made of Lisp expressions.

A handler is applicable to an error
if CONDITION-NAME is one of the error&apos;s condition names.
If an error happens, the first applicable handler is run.

The car of a handler may be a list of condition names instead of a
single condition name; then it handles all of them.  If the special
condition name `debug&apos; is present in this list, it allows another
condition in the list to run the debugger if `debug-on-error&apos; and the
other usual mechanisms says it should (otherwise, `condition-case&apos;
suppresses the debugger).

When a handler handles an error, control returns to the `condition-case&apos;
and it executes the handler&apos;s BODY...
with VAR bound to (ERROR-SYMBOL . SIGNAL-DATA) from the error.
(If VAR is nil, the handler can&apos;t access that information.)
Then the value of the last BODY form is returned from the `condition-case&apos;
expression.

See also the function `signal&apos; for more info.</pre></div></div><div class="public anchor" id="var-def-helper*"><h3>def-helper*</h3><h4 class="type">macro</h4><div class="usage"><code>(def-helper* what name arglist &amp; body)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-def-helper-process-var*"><h3>def-helper-process-var*</h3><div class="usage"><code>(def-helper-process-var* f needs-intern? name doc interactive emacs-lisp? el-arglist)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-defconst"><h3>defconst</h3><h4 class="type">macro</h4><div class="usage"><code>(defconst SYMBOL INITVALUE [DOCSTRING])</code></div><div class="doc"><pre class="plaintext">Define SYMBOL as a constant variable.
This declares that neither programs nor users should ever change the
value.  This constancy is not actually enforced by Emacs Lisp, but
SYMBOL is marked as a special variable so that it is never lexically
bound.

The `defconst&apos; form always sets the value of SYMBOL to the result of
evalling INITVALUE.  If SYMBOL is buffer-local, its default value is
what is set; buffer-local values are not affected.  If SYMBOL has a
local binding, then this form sets the local binding&apos;s value.
However, you should normally not make local bindings for variables
defined with this form.

The optional DOCSTRING specifies the variable&apos;s documentation string.</pre></div></div><div class="public anchor" id="var-define-compiler-macro"><h3>define-compiler-macro</h3><h4 class="type">macro</h4><div class="usage"><code>(define-compiler-macro FUNC ARGS &amp;rest BODY)</code></div><div class="doc"><pre class="plaintext">Define a compiler-only macro.
This is like `defmacro&apos;, but macro expansion occurs only if the call to
FUNC is compiled (i.e., not interpreted).  Compiler macros should be used
for optimizing the way calls to FUNC are compiled; the form returned by
BODY should do the same thing as a call to the normal function called
FUNC, though possibly more efficiently.  Note that, like regular macros,
compiler macros are expanded repeatedly until no further expansions are
possible.  Unlike regular macros, BODY can decide to &quot;punt&quot; and leave the
original function call alone by declaring an initial `&amp;whole foo&apos; parameter
and then returning foo.</pre></div></div><div class="public anchor" id="var-defmacro"><h3>defmacro</h3><h4 class="type">macro</h4><div class="usage"><code>(defmacro NAME ARGLIST [DOCSTRING] [DECL] BODY...)</code></div><div class="doc"><pre class="plaintext">Define NAME as a macro.
The actual definition looks like
 (macro lambda ARGLIST [DOCSTRING] [DECL] BODY...).
When the macro is called, as in (NAME ARGS...),
the function (lambda ARGLIST BODY...) is applied to
the list ARGS... as it appears in the expression,
and the result should be a form to be evaluated instead of the original.

DECL is a declaration, optional, which can specify how to indent
calls to this macro, how Edebug should handle it, and which argument
should be treated as documentation.  It looks like this:
  (declare SPECS...)
The elements can look like this:
  (indent INDENT)
	Set NAME&apos;s `lisp-indent-function&apos; property to INDENT.

  (debug DEBUG)
	Set NAME&apos;s `edebug-form-spec&apos; property to DEBUG.  (This is
	equivalent to writing a `def-edebug-spec&apos; for the macro.)

  (doc-string ELT)
	Set NAME&apos;s `doc-string-elt&apos; property to ELT.</pre></div></div><div class="public anchor" id="var-defun"><h3>defun</h3><h4 class="type">macro</h4><div class="usage"><code>(defun NAME ARGLIST [DOCSTRING] BODY...)</code></div><div class="doc"><pre class="plaintext">Define NAME as a function.
The definition is (lambda ARGLIST [DOCSTRING] BODY...).
See also the function `interactive&apos;.</pre></div></div><div class="public anchor" id="var-defvar"><h3>defvar</h3><h4 class="type">macro</h4><div class="usage"><code>(defvar SYMBOL &amp;optional INITVALUE DOCSTRING)</code></div><div class="doc"><pre class="plaintext">Define SYMBOL as a variable, and return SYMBOL.
You are not required to define a variable in order to use it, but
defining it lets you supply an initial value and documentation, which
can be referred to by the Emacs help facilities and other programming
tools.  The `defvar&apos; form also declares the variable as &quot;special&quot;,
so that it is always dynamically bound even if `lexical-binding&apos; is t.

The optional argument INITVALUE is evaluated, and used to set SYMBOL,
only if SYMBOL&apos;s value is void.  If SYMBOL is buffer-local, its
default value is what is set; buffer-local values are not affected.
If INITVALUE is missing, SYMBOL&apos;s value is not set.

If SYMBOL has a local binding, then this form affects the local
binding.  This is usually not what you want.  Thus, if you need to
load a file defining variables, with this form or with `defconst&apos; or
`defcustom&apos;, you should always load that file _outside_ any bindings
for these variables.  (`defconst&apos; and `defcustom&apos; behave similarly in
this respect.)

The optional argument DOCSTRING is a documentation string for the
variable.

To define a user option, use `defcustom&apos; instead of `defvar&apos;.
The function `user-variable-p&apos; also identifies a variable as a user
option if its DOCSTRING starts with *, but this behavior is obsolete.</pre></div></div><div class="public anchor" id="var-defvar-helper*"><h3>defvar-helper*</h3><div class="usage"><code>(defvar-helper* ns symbol &amp; [initvalue docstring])</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-delayed-eval"><h3>delayed-eval</h3><h4 class="type">macro</h4><div class="usage"><code>(delayed-eval expr)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-delayed-eval*"><h3>delayed-eval*</h3><div class="usage"><code>(delayed-eval* expr)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-dynamic-binding.3F"><h3>dynamic-binding?</h3><div class="usage"><code>(dynamic-binding?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-el-.3Eclj"><h3>el-&gt;clj</h3><div class="usage"><code>(el-&gt;clj x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-el-var"><h3>el-var</h3><div class="usage"><code>(el-var name)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-el-var-buffer-local"><h3>el-var-buffer-local</h3><div class="usage"><code>(el-var-buffer-local needs-to-exist? name)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-el-var-get"><h3>el-var-get</h3><h4 class="type">macro</h4><div class="usage"><code>(el-var-get name)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-el-var-get*"><h3>el-var-get*</h3><div class="usage"><code>(el-var-get* name)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-el-var-set"><h3>el-var-set</h3><h4 class="type">macro</h4><div class="usage"><code>(el-var-set name value)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-el-var-set*"><h3>el-var-set*</h3><div class="usage"><code>(el-var-set* name-or-var value)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-el-var-set-default"><h3>el-var-set-default</h3><h4 class="type">macro</h4><div class="usage"><code>(el-var-set-default name value)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-el-var-set-default*"><h3>el-var-set-default*</h3><div class="usage"><code>(el-var-set-default* name value)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-emacs-lisp-backquote"><h3>emacs-lisp-backquote</h3><div class="usage"><code>(emacs-lisp-backquote form)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-emacs-lisp-error"><h3>emacs-lisp-error</h3><div class="usage"><code>(emacs-lisp-error tag value)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-eval"><h3>eval</h3><div class="usage"><code>(eval body &amp; [lexical])</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-expand-dotted-lists"><h3>expand-dotted-lists</h3><div class="usage"><code>(expand-dotted-lists x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-fun"><h3>fun</h3><div class="usage"><code>(fun s)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-function"><h3>function</h3><h4 class="type">macro</h4><div class="usage"><code>(function ARG)</code></div><div class="doc"><pre class="plaintext">Like `quote&apos;, but preferred for objects which are functions.
In byte compilation, `function&apos; causes its argument to be compiled.
`quote&apos; cannot do that.</pre></div></div><div class="public anchor" id="var-global"><h3>global</h3><div class="usage"><code>(global s)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-if"><h3>if</h3><h4 class="type">macro</h4><div class="usage"><code>(if COND THEN ELSE...)</code></div><div class="doc"><pre class="plaintext">If COND yields non-nil, do THEN, else do ELSE...
Returns the value of THEN or the value of the last of the ELSE&apos;s.
THEN must be one expression, but ELSE... can be zero or more expressions.
If COND yields nil, and there are no ELSE&apos;s, the value is nil.</pre></div></div><div class="public anchor" id="var-interactive"><h3>interactive</h3><h4 class="type">macro</h4><div class="usage"><code>(interactive &amp;optional ARGS)</code></div><div class="doc"><pre class="plaintext">Specify a way of parsing arguments for interactive use of a function.
For example, write
 (defun foo (arg buf) &quot;Doc string&quot; (interactive &quot;P\nbbuffer: &quot;) .... )
 to make ARG be the raw prefix argument, and set BUF to an existing buffer,
 when `foo&apos; is called as a command.
The &quot;call&quot; to `interactive&apos; is actually a declaration rather than a function;
 it tells `call-interactively&apos; how to read arguments
 to pass to the function.
When actually called, `interactive&apos; just returns nil.

Usually the argument of `interactive&apos; is a string containing a code letter
 followed optionally by a prompt.  (Some code letters do not use I/O to get
 the argument and do not use prompts.)  To get several arguments, concatenate
 the individual strings, separating them by newline characters.
Prompts are passed to format, and may use % escapes to print the
 arguments that have already been read.
If the argument is not a string, it is evaluated to get a list of
 arguments to pass to the function.
Just `(interactive)&apos; means pass no args when calling interactively.

Code letters available are:
a -- Function name: symbol with a function definition.
b -- Name of existing buffer.
B -- Name of buffer, possibly nonexistent.
c -- Character (no input method is used).
C -- Command name: symbol with interactive function definition.
d -- Value of point as number.  Does not do I/O.
D -- Directory name.
e -- Parameterized event (i.e., one that&apos;s a list) that invoked this command.
     If used more than once, the Nth `e&apos; returns the Nth parameterized event.
     This skips events that are integers or symbols.
f -- Existing file name.
F -- Possibly nonexistent file name.
G -- Possibly nonexistent file name, defaulting to just directory name.
i -- Ignored, i.e. always nil.  Does not do I/O.
k -- Key sequence (downcase the last event if needed to get a definition).
K -- Key sequence to be redefined (do not downcase the last event).
m -- Value of mark as number.  Does not do I/O.
M -- Any string.  Inherits the current input method.
n -- Number read using minibuffer.
N -- Numeric prefix arg, or if none, do like code `n&apos;.
p -- Prefix arg converted to number.  Does not do I/O.
P -- Prefix arg in raw form.  Does not do I/O.
r -- Region: point and mark as 2 numeric args, smallest first.  Does no I/O.
s -- Any string.  Does not inherit the current input method.
S -- Any symbol.
U -- Mouse up event discarded by a previous k or K argument.
v -- Variable name: symbol that is user-variable-p.
x -- Lisp expression read but not evaluated.
X -- Lisp expression read and evaluated.
z -- Coding system.
Z -- Coding system, nil if no prefix arg.

In addition, if the string begins with `*&apos;, an error is signaled if
  the buffer is read-only.
If `@&apos; appears at the beginning of the string, and if the key sequence
 used to invoke the command includes any mouse events, then the window
 associated with the first of those events is selected before the
 command is run.
If the string begins with `^&apos; and `shift-select-mode&apos; is non-nil,
 Emacs first calls the function `handle-shift-selection&apos;.
You may use `@&apos;, `*&apos;, and `^&apos; together.  They are processed in the
 order that they appear, before reading any arguments.</pre></div></div><div class="public anchor" id="var-lambda"><h3>lambda</h3><h4 class="type">macro</h4><div class="usage"><code>(lambda ARGS [DOCSTRING] [INTERACTIVE] BODY)</code></div><div class="doc"><pre class="plaintext">Return a lambda expression.
A call of the form (lambda ARGS DOCSTRING INTERACTIVE BODY) is
self-quoting; the result of evaluating the lambda expression is the
expression itself.  The lambda expression may then be treated as a
function, i.e., stored as the function value of a symbol, passed to
`funcall&apos; or `mapcar&apos;, etc.

ARGS should take the same form as an argument list for a `defun&apos;.
DOCSTRING is an optional documentation string.
 If present, it should describe how to call the function.
 But documentation strings are usually not useful in nameless functions.
INTERACTIVE should be a call to the function `interactive&apos;, which see.
It may also be omitted.
BODY should be a list of Lisp expressions.</pre></div></div><div class="public anchor" id="var-let"><h3>let</h3><h4 class="type">macro</h4><div class="usage"><code>(let VARLIST BODY...)</code></div><div class="doc"><pre class="plaintext">Bind variables according to VARLIST then eval BODY.
The value of the last form in BODY is returned.
Each element of VARLIST is a symbol (which is bound to nil)
or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).
All the VALUEFORMs are evalled before any symbols are bound.</pre></div></div><div class="public anchor" id="var-let*"><h3>let*</h3><h4 class="type">macro</h4><div class="usage"><code>(let* VARLIST BODY...)</code></div><div class="doc"><pre class="plaintext">Bind variables according to VARLIST then eval BODY.
The value of the last form in BODY is returned.
Each element of VARLIST is a symbol (which is bound to nil)
or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).
Each VALUEFORM can refer to the symbols already bound by this VARLIST.</pre></div></div><div class="public anchor" id="var-let-helper*"><h3>let-helper*</h3><h4 class="type">macro</h4><div class="usage"><code>(let-helper* can-refer? varlist &amp; body)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-maybe-splice-dotted-list"><h3>maybe-splice-dotted-list</h3><div class="usage"><code>(maybe-splice-dotted-list x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-maybe-sym"><h3>maybe-sym</h3><div class="usage"><code>(maybe-sym x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-meta-walk"><h3>meta-walk</h3><div class="usage"><code>(meta-walk inner outer form)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-normalize-form-for-macro"><h3>normalize-form-for-macro</h3><div class="usage"><code>(normalize-form-for-macro form)</code><code>(normalize-form-for-macro f form)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-not-null.3F"><h3>not-null?</h3><div class="usage"><code>(not-null? object)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-or"><h3>or</h3><h4 class="type">macro</h4><div class="usage"><code>(or CONDITIONS...)</code></div><div class="doc"><pre class="plaintext">Eval args until one of them yields non-nil, then return that value.
The remaining args are not evalled at all.
If all args return nil, return nil.</pre></div></div><div class="public anchor" id="var-override.3F"><h3>override?</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-parse-doc-string"><h3>parse-doc-string</h3><div class="usage"><code>(parse-doc-string [doc &amp; rst :as body])</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-prog1"><h3>prog1</h3><h4 class="type">macro</h4><div class="usage"><code>(prog1 FIRST BODY...)</code></div><div class="doc"><pre class="plaintext">Eval FIRST and BODY sequentially; return value from FIRST.
The value of FIRST is saved during the evaluation of the remaining args,
whose values are discarded.</pre></div></div><div class="public anchor" id="var-prog2"><h3>prog2</h3><h4 class="type">macro</h4><div class="usage"><code>(prog2 FORM1 FORM2 BODY...)</code></div><div class="doc"><pre class="plaintext">Eval FORM1, FORM2 and BODY sequentially; return value from FORM2.
The value of FORM2 is saved during the evaluation of the
remaining args, whose values are discarded.</pre></div></div><div class="public anchor" id="var-progn"><h3>progn</h3><h4 class="type">macro</h4><div class="usage"><code>(progn BODY...)</code></div><div class="doc"><pre class="plaintext">Eval BODY forms sequentially and return value of last one.
</pre></div></div><div class="public anchor" id="var-quote"><h3>quote</h3><h4 class="type">macro</h4><div class="usage"><code>(quote ARG)</code></div><div class="doc"><pre class="plaintext">Return the argument, without evaluating it.  `(quote x)&apos; yields `x&apos;.
Warning: `quote&apos; does not construct its return value, but just returns
the value that was pre-constructed by the Lisp reader (see info node
`(elisp)Printed Representation&apos;).
This means that &apos;(a . b) is not identical to (cons &apos;a &apos;b): the former
does not cons.  Quoting should be reserved for constants that will
never be modified by side-effects, unless you like self-modifying code.
See the common pitfall in info node `(elisp)Rearrangement&apos; for an example
of unexpected results when a quoted object is modified.</pre></div></div><div class="public anchor" id="var-save-current-buffer"><h3>save-current-buffer</h3><h4 class="type">macro</h4><div class="usage"><code>(save-current-buffer &amp;rest BODY)</code></div><div class="doc"><pre class="plaintext">Save the current buffer; execute BODY; restore the current buffer.
Executes BODY just like `progn&apos;.</pre></div></div><div class="public anchor" id="var-save-excursion"><h3>save-excursion</h3><h4 class="type">macro</h4><div class="usage"><code>(save-excursion &amp; body)</code></div><div class="doc"><pre class="plaintext">Save point, mark, and current buffer; execute BODY; restore those things.
Executes BODY just like `progn&apos;.
The values of point, mark and the current buffer are restored
even in case of abnormal exit (throw or error).
The state of activation of the mark is also restored.

This construct does not save `deactivate-mark&apos;, and therefore
functions that change the buffer will still cause deactivation
of the mark at the end of the command.  To prevent that, bind
`deactivate-mark&apos; with `let&apos;.

If you only want to save the current buffer but not point nor mark,
then just use `save-current-buffer&apos;, or even `with-current-buffer&apos;.</pre></div></div><div class="public anchor" id="var-save-restriction"><h3>save-restriction</h3><h4 class="type">macro</h4><div class="usage"><code>(save-restriction &amp;rest BODY)</code></div><div class="doc"><pre class="plaintext">Execute BODY, saving and restoring current buffer&apos;s restrictions.
The buffer&apos;s restrictions make parts of the beginning and end invisible.
(They are set up with `narrow-to-region&apos; and eliminated with `widen&apos;.)
This special form, `save-restriction&apos;, saves the current buffer&apos;s restrictions
when it is entered, and restores them when it is exited.
So any `narrow-to-region&apos; within BODY lasts only until the end of the form.
The old restrictions settings are restored
even in case of abnormal exit (throw or error).

The value returned is the value of the last form in BODY.

Note: if you are using both `save-excursion&apos; and `save-restriction&apos;,
use `save-excursion&apos; outermost:
    (save-excursion (save-restriction ...))</pre></div></div><div class="public anchor" id="var-scope"><h3>scope</h3><div class="usage"><code>(scope &amp;env)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-setq"><h3>setq</h3><h4 class="type">macro</h4><div class="usage"><code>(setq [SYM VAL] ...)</code></div><div class="doc"><pre class="plaintext">Set each SYM to the value of its VAL.
The symbols SYM are variables; they are literal (not evaluated).
The values VAL are expressions; they are evaluated.
Thus, (setq x (1+ y)) sets `x&apos; to the value of `(1+ y)&apos;.
The second VAL is not computed until after the first SYM is set, and so on;
each VAL can use the new value of variables set earlier in the `setq&apos;.
The return value of the `setq&apos; form is the value of the last VAL.</pre></div></div><div class="public anchor" id="var-setq-default"><h3>setq-default</h3><h4 class="type">macro</h4><div class="usage"><code>(setq-default [VAR VALUE] ...)</code></div><div class="doc"><pre class="plaintext">Set the default value of variable VAR to VALUE.
VAR, the variable name, is literal (not evaluated);
VALUE is an expression: it is evaluated and its value returned.
The default value of a variable is seen in buffers
that do not have their own values for the variable.

More generally, you can use multiple variables and values, as in
  (setq-default VAR VALUE VAR VALUE...)
This sets each VAR&apos;s default value to the corresponding VALUE.
The VALUE for the Nth VAR can refer to the new default values
of previous VARs.</pre></div></div><div class="public anchor" id="var-setq-helper*"><h3>setq-helper*</h3><h4 class="type">macro</h4><div class="usage"><code>(setq-helper* default? sym-vals)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-sym"><h3>sym</h3><div class="usage"><code>(sym s)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-symbol-plists"><h3>symbol-plists</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-symbol-reader"><h3>symbol-reader</h3><div class="usage"><code>(symbol-reader s)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-syntax-quote*"><h3>syntax-quote*</h3><div class="usage"><code>(syntax-quote* form)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-throw"><h3>throw</h3><h4 class="type">macro</h4><div class="usage"><code>(throw TAG VALUE)</code></div><div class="doc"><pre class="plaintext">Throw to the catch for TAG and return VALUE from it.
Both TAG and VALUE are evalled.</pre></div></div><div class="public anchor" id="var-throw*"><h3>throw*</h3><div class="usage"><code>(throw* tag value)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-try-with-tag"><h3>try-with-tag</h3><h4 class="type">macro</h4><div class="usage"><code>(try-with-tag &amp; exprs)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-unwind-protect"><h3>unwind-protect</h3><h4 class="type">macro</h4><div class="usage"><code>(unwind-protect BODYFORM UNWINDFORMS...)</code></div><div class="doc"><pre class="plaintext">Do BODYFORM, protecting with UNWINDFORMS.
If BODYFORM completes normally, its value is returned
after executing the UNWINDFORMS.
If BODYFORM exits nonlocally, the UNWINDFORMS are executed anyway.</pre></div></div><div class="public anchor" id="var-vector-reader"><h3>vector-reader</h3><div class="usage"><code>(vector-reader v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-while"><h3>while</h3><h4 class="type">macro</h4><div class="usage"><code>(while TEST BODY...)</code></div><div class="doc"><pre class="plaintext">If TEST yields non-nil, eval BODY... and repeat.
The order of execution is thus TEST, BODY, TEST, BODY and so on
until TEST returns nil.</pre></div></div><div class="public anchor" id="var-with-local-el-vars"><h3>with-local-el-vars</h3><h4 class="type">macro</h4><div class="usage"><code>(with-local-el-vars name-vals-vec &amp; body)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></body></html>